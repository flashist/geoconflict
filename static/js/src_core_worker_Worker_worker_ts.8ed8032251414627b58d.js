/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/version.txt":
/*!*******************************!*\
  !*** ./resources/version.txt ***!
  \*******************************/
/***/ ((module) => {

"use strict";
eval("{module.exports = \"EXPERIMENTAL BUILD\\nFOR INTERNAL USE ONLY\\n\";\n\n//# sourceURL=webpack://openfront-client/./resources/version.txt?\n}");

/***/ }),

/***/ "./src/client/Utils.ts":
/*!*****************************!*\
  !*** ./src/client/Utils.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   generateCryptoRandomUUID: () => (/* binding */ generateCryptoRandomUUID),\n/* harmony export */   getAltKey: () => (/* binding */ getAltKey),\n/* harmony export */   getGamesPlayed: () => (/* binding */ getGamesPlayed),\n/* harmony export */   getMessageTypeClasses: () => (/* binding */ getMessageTypeClasses),\n/* harmony export */   getModifierKey: () => (/* binding */ getModifierKey),\n/* harmony export */   incrementGamesPlayed: () => (/* binding */ incrementGamesPlayed),\n/* harmony export */   isInIframe: () => (/* binding */ isInIframe),\n/* harmony export */   renderDuration: () => (/* binding */ renderDuration),\n/* harmony export */   renderNumber: () => (/* binding */ renderNumber),\n/* harmony export */   renderTroops: () => (/* binding */ renderTroops),\n/* harmony export */   severityColors: () => (/* binding */ severityColors),\n/* harmony export */   translateText: () => (/* binding */ translateText)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! intl-messageformat */ \"./node_modules/intl-messageformat/lib/index.js\");\n/* harmony import */ var _core_game_Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/game/Game */ \"./src/core/game/Game.ts\");\n\n\nfunction renderDuration(totalSeconds) {\n    if (totalSeconds <= 0)\n        return \"0s\";\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    let time = \"\";\n    if (minutes > 0)\n        time += `${minutes}min `;\n    time += `${seconds}s`;\n    return time.trim();\n}\nfunction renderTroops(troops) {\n    return renderNumber(troops / 10);\n}\nfunction renderNumber(num, fixedPoints) {\n    num = Number(num);\n    num = Math.max(num, 0);\n    if (num >= 10000000) {\n        const value = Math.floor(num / 100000) / 10;\n        return value.toFixed(fixedPoints ?? 1) + \"M\";\n    }\n    else if (num >= 1000000) {\n        const value = Math.floor(num / 10000) / 100;\n        return value.toFixed(fixedPoints ?? 2) + \"M\";\n    }\n    else if (num >= 100000) {\n        return Math.floor(num / 1000) + \"K\";\n    }\n    else if (num >= 10000) {\n        const value = Math.floor(num / 100) / 10;\n        return value.toFixed(fixedPoints ?? 1) + \"K\";\n    }\n    else if (num >= 1000) {\n        const value = Math.floor(num / 10) / 100;\n        return value.toFixed(fixedPoints ?? 2) + \"K\";\n    }\n    else {\n        return Math.floor(num).toString();\n    }\n}\nfunction createCanvas() {\n    const canvas = document.createElement(\"canvas\");\n    // Set canvas style to fill the screen\n    canvas.style.position = \"fixed\";\n    canvas.style.left = \"0\";\n    canvas.style.top = \"0\";\n    canvas.style.width = \"100%\";\n    canvas.style.height = \"100%\";\n    canvas.style.touchAction = \"none\";\n    return canvas;\n}\n/**\n * A polyfill for crypto.randomUUID that provides fallback implementations\n * for older browsers, particularly Safari versions < 15.4\n */\nfunction generateCryptoRandomUUID() {\n    // Type guard to check if randomUUID is available\n    if (crypto !== undefined && \"randomUUID\" in crypto) {\n        return crypto.randomUUID();\n    }\n    // Fallback using crypto.getRandomValues\n    if (crypto !== undefined && \"getRandomValues\" in crypto) {\n        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^\n            (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));\n    }\n    // Last resort fallback using Math.random\n    // Note: This is less cryptographically secure but ensures functionality\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16) | 0;\n        const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nconst translateText = (key, params = {}) => {\n    const self = translateText;\n    self.formatterCache ?? (self.formatterCache = new Map());\n    self.lastLang ?? (self.lastLang = null);\n    const langSelector = document.querySelector(\"lang-selector\");\n    if (!langSelector) {\n        console.warn(\"LangSelector not found in DOM\");\n        return key;\n    }\n    if (!langSelector.translations ||\n        Object.keys(langSelector.translations).length === 0) {\n        return key;\n    }\n    if (self.lastLang !== langSelector.currentLang) {\n        self.formatterCache.clear();\n        self.lastLang = langSelector.currentLang;\n    }\n    let message = langSelector.translations[key];\n    if (!message && langSelector.defaultTranslations) {\n        const defaultTranslations = langSelector.defaultTranslations;\n        if (defaultTranslations && defaultTranslations[key]) {\n            message = defaultTranslations[key];\n        }\n    }\n    if (!message)\n        return key;\n    try {\n        const locale = !langSelector.translations[key] && langSelector.currentLang !== \"en\"\n            ? \"en\"\n            : langSelector.currentLang;\n        const cacheKey = `${key}:${locale}:${message}`;\n        let formatter = self.formatterCache.get(cacheKey);\n        if (!formatter) {\n            formatter = new intl_messageformat__WEBPACK_IMPORTED_MODULE_0__[\"default\"](message, locale);\n            self.formatterCache.set(cacheKey, formatter);\n        }\n        return formatter.format(params);\n    }\n    catch (e) {\n        console.warn(\"ICU format error\", e);\n        return message;\n    }\n};\n/**\n * Severity colors mapping for message types\n */\nconst severityColors = {\n    fail: \"text-red-400\",\n    warn: \"text-yellow-400\",\n    success: \"text-green-400\",\n    info: \"text-gray-200\",\n    blue: \"text-blue-400\",\n    white: \"text-white\",\n};\n/**\n * Gets the CSS classes for styling message types based on their severity\n * @param type The message type to get styling for\n * @returns CSS class string for the message type\n */\nfunction getMessageTypeClasses(type) {\n    switch (type) {\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.SAM_HIT:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.CAPTURED_ENEMY_UNIT:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.RECEIVED_GOLD_FROM_TRADE:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.CONQUERED_PLAYER:\n            return severityColors[\"success\"];\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ATTACK_FAILED:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ALLIANCE_REJECTED:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ALLIANCE_BROKEN:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.UNIT_CAPTURED_BY_ENEMY:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.UNIT_DESTROYED:\n            return severityColors[\"fail\"];\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ATTACK_CANCELLED:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ATTACK_REQUEST:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ALLIANCE_ACCEPTED:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.SENT_GOLD_TO_PLAYER:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.SENT_TROOPS_TO_PLAYER:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.RECEIVED_GOLD_FROM_PLAYER:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.RECEIVED_TROOPS_FROM_PLAYER:\n            return severityColors[\"blue\"];\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.MIRV_INBOUND:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.NUKE_INBOUND:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.HYDROGEN_BOMB_INBOUND:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.SAM_MISS:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ALLIANCE_EXPIRED:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.NAVAL_INVASION_INBOUND:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.RENEW_ALLIANCE:\n            return severityColors[\"warn\"];\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.CHAT:\n        case _core_game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ALLIANCE_REQUEST:\n            return severityColors[\"info\"];\n        default:\n            console.warn(`Message type ${type} has no explicit color`);\n            return severityColors[\"white\"];\n    }\n}\nfunction getModifierKey() {\n    const isMac = /Mac/.test(navigator.userAgent);\n    if (isMac) {\n        return \"âŒ˜\"; // Command key\n    }\n    else {\n        return \"Ctrl\";\n    }\n}\nfunction getAltKey() {\n    const isMac = /Mac/.test(navigator.userAgent);\n    if (isMac) {\n        return \"âŒ¥\"; // Option key\n    }\n    else {\n        return \"Alt\";\n    }\n}\nfunction getGamesPlayed() {\n    try {\n        return parseInt(localStorage.getItem(\"gamesPlayed\") ?? \"0\", 10) || 0;\n    }\n    catch (error) {\n        console.warn(\"Failed to read games played from localStorage:\", error);\n        return 0;\n    }\n}\nfunction incrementGamesPlayed() {\n    try {\n        localStorage.setItem(\"gamesPlayed\", (getGamesPlayed() + 1).toString());\n    }\n    catch (error) {\n        console.warn(\"Failed to increment games played in localStorage:\", error);\n    }\n}\nfunction isInIframe() {\n    try {\n        return window.self !== window.top;\n    }\n    catch (e) {\n        // If we can't access window.top due to cross-origin restrictions,\n        // we're definitely in an iframe\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/client/Utils.ts?\n}");

/***/ }),

/***/ "./src/client/graphics/NameBoxCalculator.ts":
/*!**************************************************!*\
  !*** ./src/client/graphics/NameBoxCalculator.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateFontSize: () => (/* binding */ calculateFontSize),\n/* harmony export */   createGrid: () => (/* binding */ createGrid),\n/* harmony export */   findLargestInscribedRectangle: () => (/* binding */ findLargestInscribedRectangle),\n/* harmony export */   largestRectangleInHistogram: () => (/* binding */ largestRectangleInHistogram),\n/* harmony export */   placeName: () => (/* binding */ placeName)\n/* harmony export */ });\n/* harmony import */ var _core_game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _core_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/Util */ \"./src/core/Util.ts\");\n\n\nfunction placeName(game, player) {\n    const boundingBox = player.largestClusterBoundingBox ??\n        (0,_core_Util__WEBPACK_IMPORTED_MODULE_1__.calculateBoundingBox)(game, player.borderTiles());\n    let scalingFactor = 1;\n    const width = boundingBox.max.x - boundingBox.min.x;\n    const height = boundingBox.max.y - boundingBox.min.y;\n    const size = Math.min(width, height);\n    if (size < 25) {\n        scalingFactor = 1;\n    }\n    else if (size < 50) {\n        scalingFactor = 2;\n    }\n    else if (size < 100) {\n        scalingFactor = 4;\n    }\n    else if (size < 250) {\n        scalingFactor = 8;\n    }\n    else if (size < 500) {\n        scalingFactor = 16;\n    }\n    else {\n        scalingFactor = 32;\n    }\n    const grid = createGrid(game, player, boundingBox, scalingFactor);\n    const largestRectangle = findLargestInscribedRectangle(grid);\n    largestRectangle.x = largestRectangle.x * scalingFactor;\n    largestRectangle.y = largestRectangle.y * scalingFactor;\n    largestRectangle.width = largestRectangle.width * scalingFactor;\n    largestRectangle.height = largestRectangle.height * scalingFactor;\n    let center = new _core_game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(Math.floor(largestRectangle.x + largestRectangle.width / 2 + boundingBox.min.x), Math.floor(largestRectangle.y + largestRectangle.height / 2 + boundingBox.min.y));\n    const fontSize = calculateFontSize(largestRectangle, player.name());\n    center = new _core_game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(center.x, center.y - fontSize / 3);\n    return {\n        x: Math.ceil(center.x),\n        y: Math.ceil(center.y),\n        size: fontSize,\n    };\n}\nfunction createGrid(game, player, boundingBox, scalingFactor) {\n    const scaledBoundingBox = {\n        min: {\n            x: Math.floor(boundingBox.min.x / scalingFactor),\n            y: Math.floor(boundingBox.min.y / scalingFactor),\n        },\n        max: {\n            x: Math.floor(boundingBox.max.x / scalingFactor),\n            y: Math.floor(boundingBox.max.y / scalingFactor),\n        },\n    };\n    const width = scaledBoundingBox.max.x - scaledBoundingBox.min.x + 1;\n    const height = scaledBoundingBox.max.y - scaledBoundingBox.min.y + 1;\n    const grid = Array(width)\n        .fill(null)\n        .map(() => Array(height).fill(false));\n    for (let x = scaledBoundingBox.min.x; x <= scaledBoundingBox.max.x; x++) {\n        for (let y = scaledBoundingBox.min.y; y <= scaledBoundingBox.max.y; y++) {\n            const cell = new _core_game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(x * scalingFactor, y * scalingFactor);\n            if (game.isOnMap(cell)) {\n                const tile = game.ref(cell.x, cell.y);\n                grid[x - scaledBoundingBox.min.x][y - scaledBoundingBox.min.y] =\n                    game.isLake(tile) ||\n                        game.owner(tile) === player ||\n                        game.hasFallout(tile);\n            }\n        }\n    }\n    return grid;\n}\nfunction findLargestInscribedRectangle(grid) {\n    const rows = grid[0].length;\n    const cols = grid.length;\n    const heights = new Array(cols).fill(0);\n    let largestRect = { x: 0, y: 0, width: 0, height: 0 };\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            if (grid[col][row]) {\n                heights[col]++;\n            }\n            else {\n                heights[col] = 0;\n            }\n        }\n        const rectForRow = largestRectangleInHistogram(heights);\n        if (rectForRow.width * rectForRow.height >\n            largestRect.width * largestRect.height) {\n            largestRect = {\n                x: rectForRow.x,\n                y: row - rectForRow.height + 1,\n                width: rectForRow.width,\n                height: rectForRow.height,\n            };\n        }\n    }\n    return largestRect;\n}\nfunction largestRectangleInHistogram(widths) {\n    const stack = [];\n    let maxArea = 0;\n    let largestRect = { x: 0, y: 0, width: 0, height: 0 };\n    for (let i = 0; i <= widths.length; i++) {\n        const h = i === widths.length ? 0 : widths[i];\n        while (stack.length > 0 && h < widths[stack[stack.length - 1]]) {\n            const height = widths[stack.pop()];\n            const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            if (height * width > maxArea) {\n                maxArea = height * width;\n                largestRect = {\n                    x: stack.length === 0 ? 0 : stack[stack.length - 1] + 1,\n                    y: 0,\n                    width: width,\n                    height: height,\n                };\n            }\n        }\n        stack.push(i);\n    }\n    return largestRect;\n}\nfunction calculateFontSize(rectangle, name) {\n    // This is a simplified calculation. You might want to adjust it based on your specific font and rendering system.\n    const widthConstrained = (rectangle.width / name.length) * 2;\n    const heightConstrained = rectangle.height / 3;\n    return Math.min(widthConstrained, heightConstrained);\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/client/graphics/NameBoxCalculator.ts?\n}");

/***/ }),

/***/ "./src/core/GameRunner.ts":
/*!********************************!*\
  !*** ./src/core/GameRunner.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameRunner: () => (/* binding */ GameRunner),\n/* harmony export */   createGameRunner: () => (/* binding */ createGameRunner)\n/* harmony export */ });\n/* harmony import */ var _client_graphics_NameBoxCalculator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/graphics/NameBoxCalculator */ \"./src/client/graphics/NameBoxCalculator.ts\");\n/* harmony import */ var _configuration_ConfigLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./configuration/ConfigLoader */ \"./src/core/configuration/ConfigLoader.ts\");\n/* harmony import */ var _execution_ExecutionManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./execution/ExecutionManager */ \"./src/core/execution/ExecutionManager.ts\");\n/* harmony import */ var _execution_WinCheckExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./execution/WinCheckExecution */ \"./src/core/execution/WinCheckExecution.ts\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _game_GameImpl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./game/GameImpl */ \"./src/core/game/GameImpl.ts\");\n/* harmony import */ var _game_GameUpdates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./game/GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n/* harmony import */ var _game_TerrainMapLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./game/TerrainMapLoader */ \"./src/core/game/TerrainMapLoader.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _validations_username__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./validations/username */ \"./src/core/validations/username.ts\");\n\n\n\n\n\n\n\n\n\n\n\nasync function createGameRunner(gameStart, clientID, mapLoader, callBack) {\n    const config = await (0,_configuration_ConfigLoader__WEBPACK_IMPORTED_MODULE_1__.getConfig)(gameStart.config, null);\n    const gameMap = await (0,_game_TerrainMapLoader__WEBPACK_IMPORTED_MODULE_7__.loadTerrainMap)(gameStart.config.gameMap, gameStart.config.gameMapSize, mapLoader);\n    const random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_8__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_9__.simpleHash)(gameStart.gameID));\n    const humans = gameStart.players.map((p) => new _game_Game__WEBPACK_IMPORTED_MODULE_4__.PlayerInfo(p.clientID === clientID\n        ? (0,_Util__WEBPACK_IMPORTED_MODULE_9__.sanitize)(p.username)\n        : (0,_validations_username__WEBPACK_IMPORTED_MODULE_10__.fixProfaneUsername)((0,_Util__WEBPACK_IMPORTED_MODULE_9__.sanitize)(p.username)), _game_Game__WEBPACK_IMPORTED_MODULE_4__.PlayerType.Human, p.clientID, random.nextID()));\n    const nations = gameStart.config.disableNPCs\n        ? []\n        : gameMap.nations.map((n) => new _game_Game__WEBPACK_IMPORTED_MODULE_4__.Nation(new _game_Game__WEBPACK_IMPORTED_MODULE_4__.Cell(n.coordinates[0], n.coordinates[1]), n.strength, new _game_Game__WEBPACK_IMPORTED_MODULE_4__.PlayerInfo(n.name, _game_Game__WEBPACK_IMPORTED_MODULE_4__.PlayerType.FakeHuman, null, random.nextID())));\n    const game = (0,_game_GameImpl__WEBPACK_IMPORTED_MODULE_5__.createGame)(humans, nations, gameMap.gameMap, gameMap.miniGameMap, config);\n    const gr = new GameRunner(game, new _execution_ExecutionManager__WEBPACK_IMPORTED_MODULE_2__.Executor(game, gameStart.gameID, clientID), callBack);\n    gr.init();\n    return gr;\n}\nclass GameRunner {\n    constructor(game, execManager, callBack) {\n        this.game = game;\n        this.execManager = execManager;\n        this.callBack = callBack;\n        this.turns = [];\n        this.currTurn = 0;\n        this.isExecuting = false;\n        this.playerViewData = {};\n    }\n    init() {\n        if (this.game.config().bots() > 0) {\n            this.game.addExecution(...this.execManager.spawnBots(this.game.config().numBots()));\n        }\n        if (this.game.config().spawnNPCs()) {\n            this.game.addExecution(...this.execManager.fakeHumanExecutions());\n        }\n        this.game.addExecution(new _execution_WinCheckExecution__WEBPACK_IMPORTED_MODULE_3__.WinCheckExecution());\n    }\n    addTurn(turn) {\n        this.turns.push(turn);\n    }\n    executeNextTick() {\n        if (this.isExecuting) {\n            return;\n        }\n        if (this.currTurn >= this.turns.length) {\n            return;\n        }\n        this.isExecuting = true;\n        this.game.addExecution(...this.execManager.createExecs(this.turns[this.currTurn]));\n        this.currTurn++;\n        let updates;\n        try {\n            updates = this.game.executeNextTick();\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                console.error(\"Game tick error:\", error.message);\n                this.callBack({\n                    errMsg: error.message,\n                    stack: error.stack,\n                });\n            }\n            else {\n                console.error(\"Game tick error:\", error);\n            }\n            return;\n        }\n        if (this.game.inSpawnPhase() && this.game.ticks() % 2 === 0) {\n            this.game\n                .players()\n                .filter((p) => p.type() === _game_Game__WEBPACK_IMPORTED_MODULE_4__.PlayerType.Human || p.type() === _game_Game__WEBPACK_IMPORTED_MODULE_4__.PlayerType.FakeHuman)\n                .forEach((p) => (this.playerViewData[p.id()] = (0,_client_graphics_NameBoxCalculator__WEBPACK_IMPORTED_MODULE_0__.placeName)(this.game, p)));\n        }\n        if (this.game.ticks() < 3 || this.game.ticks() % 30 === 0) {\n            this.game.players().forEach((p) => {\n                this.playerViewData[p.id()] = (0,_client_graphics_NameBoxCalculator__WEBPACK_IMPORTED_MODULE_0__.placeName)(this.game, p);\n            });\n        }\n        // Many tiles are updated to pack it into an array\n        const packedTileUpdates = updates[_game_GameUpdates__WEBPACK_IMPORTED_MODULE_6__.GameUpdateType.Tile].map((u) => u.update);\n        updates[_game_GameUpdates__WEBPACK_IMPORTED_MODULE_6__.GameUpdateType.Tile] = [];\n        this.callBack({\n            tick: this.game.ticks(),\n            packedTileUpdates: new BigUint64Array(packedTileUpdates),\n            updates: updates,\n            playerNameViewData: this.playerViewData,\n        });\n        this.isExecuting = false;\n    }\n    playerActions(playerID, x, y) {\n        const player = this.game.player(playerID);\n        const tile = x !== undefined && y !== undefined ? this.game.ref(x, y) : null;\n        const actions = {\n            canAttack: tile !== null && player.canAttack(tile),\n            buildableUnits: player.buildableUnits(tile),\n            canSendEmojiAllPlayers: player.canSendEmoji(_game_Game__WEBPACK_IMPORTED_MODULE_4__.AllPlayers),\n        };\n        if (tile !== null && this.game.hasOwner(tile)) {\n            const other = this.game.owner(tile);\n            actions.interaction = {\n                sharedBorder: player.sharesBorderWith(other),\n                canSendEmoji: player.canSendEmoji(other),\n                canTarget: player.canTarget(other),\n                canSendAllianceRequest: player.canSendAllianceRequest(other),\n                canBreakAlliance: player.isAlliedWith(other),\n                canDonateGold: player.canDonateGold(other),\n                canDonateTroops: player.canDonateTroops(other),\n                canEmbargo: !player.hasEmbargoAgainst(other),\n            };\n            const alliance = player.allianceWith(other);\n            if (alliance) {\n                actions.interaction.allianceExpiresAt = alliance.expiresAt();\n            }\n        }\n        return actions;\n    }\n    playerProfile(playerID) {\n        const player = this.game.playerBySmallID(playerID);\n        if (!player.isPlayer()) {\n            throw new Error(`player with id ${playerID} not found`);\n        }\n        return player.playerProfile();\n    }\n    playerBorderTiles(playerID) {\n        const player = this.game.player(playerID);\n        if (!player.isPlayer()) {\n            throw new Error(`player with id ${playerID} not found`);\n        }\n        return {\n            borderTiles: player.borderTiles(),\n        };\n    }\n    attackAveragePosition(playerID, attackID) {\n        const player = this.game.playerBySmallID(playerID);\n        if (!player.isPlayer()) {\n            throw new Error(`player with id ${playerID} not found`);\n        }\n        const condition = (a) => a.id() === attackID;\n        const attack = player.outgoingAttacks().find(condition) ??\n            player.incomingAttacks().find(condition);\n        if (attack === undefined) {\n            return null;\n        }\n        return attack.averagePosition();\n    }\n    bestTransportShipSpawn(playerID, targetTile) {\n        const player = this.game.player(playerID);\n        if (!player.isPlayer()) {\n            throw new Error(`player with id ${playerID} not found`);\n        }\n        return player.bestTransportShipSpawn(targetTile);\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/GameRunner.ts?\n}");

/***/ }),

/***/ "./src/core/PseudoRandom.ts":
/*!**********************************!*\
  !*** ./src/core/PseudoRandom.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PseudoRandom: () => (/* binding */ PseudoRandom)\n/* harmony export */ });\n/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! seedrandom */ \"./node_modules/seedrandom/index.js\");\n/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);\n\nclass PseudoRandom {\n    constructor(seed) {\n        this.rng = seedrandom__WEBPACK_IMPORTED_MODULE_0___default()(String(seed));\n    }\n    // Generates the next pseudorandom number between 0 and 1.\n    next() {\n        return this.rng();\n    }\n    // Generates a random integer between min (inclusive) and max (exclusive).\n    nextInt(min, max) {\n        return Math.floor(this.rng() * (max - min)) + min;\n    }\n    // Generates a random float between min (inclusive) and max (exclusive).\n    nextFloat(min, max) {\n        return this.rng() * (max - min) + min;\n    }\n    // Generates a random ID (8 characters, alphanumeric).\n    nextID() {\n        return Math.floor(this.rng() * PseudoRandom.POW36_8)\n            .toString(36)\n            .padStart(8, \"0\");\n    }\n    // Selects a random element from an array.\n    randElement(arr) {\n        if (arr.length === 0) {\n            throw new Error(\"array must not be empty\");\n        }\n        return arr[this.nextInt(0, arr.length)];\n    }\n    // Selects a random element from a set.\n    randFromSet(set) {\n        const size = set.size;\n        if (size === 0) {\n            throw new Error(\"set must not be empty\");\n        }\n        const index = this.nextInt(0, size);\n        let i = 0;\n        for (const item of set) {\n            if (i === index) {\n                return item;\n            }\n            i++;\n        }\n        // This should never happen\n        throw new Error(\"Unexpected error selecting element from set\");\n    }\n    // Returns true with probability 1/odds.\n    chance(odds) {\n        return this.nextInt(0, odds) === 0;\n    }\n    // Returns a shuffled copy of the array using Fisher-Yates algorithm.\n    shuffleArray(array) {\n        const result = [...array];\n        for (let i = result.length - 1; i > 0; i--) {\n            const j = this.nextInt(0, i + 1);\n            [result[i], result[j]] = [result[j], result[i]];\n        }\n        return result;\n    }\n}\nPseudoRandom.POW36_8 = Math.pow(36, 8); // Pre-compute 36^8\n\n\n//# sourceURL=webpack://openfront-client/./src/core/PseudoRandom.ts?\n}");

/***/ }),

/***/ "./src/core/StatsSchemas.ts":
/*!**********************************!*\
  !*** ./src/core/StatsSchemas.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATTACK_INDEX_CANCEL: () => (/* binding */ ATTACK_INDEX_CANCEL),\n/* harmony export */   ATTACK_INDEX_RECV: () => (/* binding */ ATTACK_INDEX_RECV),\n/* harmony export */   ATTACK_INDEX_SENT: () => (/* binding */ ATTACK_INDEX_SENT),\n/* harmony export */   BOAT_INDEX_ARRIVE: () => (/* binding */ BOAT_INDEX_ARRIVE),\n/* harmony export */   BOAT_INDEX_CAPTURE: () => (/* binding */ BOAT_INDEX_CAPTURE),\n/* harmony export */   BOAT_INDEX_DESTROY: () => (/* binding */ BOAT_INDEX_DESTROY),\n/* harmony export */   BOAT_INDEX_SENT: () => (/* binding */ BOAT_INDEX_SENT),\n/* harmony export */   BOMB_INDEX_INTERCEPT: () => (/* binding */ BOMB_INDEX_INTERCEPT),\n/* harmony export */   BOMB_INDEX_LAND: () => (/* binding */ BOMB_INDEX_LAND),\n/* harmony export */   BOMB_INDEX_LAUNCH: () => (/* binding */ BOMB_INDEX_LAUNCH),\n/* harmony export */   BigIntStringSchema: () => (/* binding */ BigIntStringSchema),\n/* harmony export */   BoatUnitSchema: () => (/* binding */ BoatUnitSchema),\n/* harmony export */   BombUnitSchema: () => (/* binding */ BombUnitSchema),\n/* harmony export */   GOLD_INDEX_STEAL: () => (/* binding */ GOLD_INDEX_STEAL),\n/* harmony export */   GOLD_INDEX_TRADE: () => (/* binding */ GOLD_INDEX_TRADE),\n/* harmony export */   GOLD_INDEX_WAR: () => (/* binding */ GOLD_INDEX_WAR),\n/* harmony export */   GOLD_INDEX_WORK: () => (/* binding */ GOLD_INDEX_WORK),\n/* harmony export */   OTHER_INDEX_BUILT: () => (/* binding */ OTHER_INDEX_BUILT),\n/* harmony export */   OTHER_INDEX_CAPTURE: () => (/* binding */ OTHER_INDEX_CAPTURE),\n/* harmony export */   OTHER_INDEX_DESTROY: () => (/* binding */ OTHER_INDEX_DESTROY),\n/* harmony export */   OTHER_INDEX_LOST: () => (/* binding */ OTHER_INDEX_LOST),\n/* harmony export */   OTHER_INDEX_UPGRADE: () => (/* binding */ OTHER_INDEX_UPGRADE),\n/* harmony export */   OtherUnitSchema: () => (/* binding */ OtherUnitSchema),\n/* harmony export */   PlayerStatsSchema: () => (/* binding */ PlayerStatsSchema),\n/* harmony export */   boatUnits: () => (/* binding */ boatUnits),\n/* harmony export */   bombUnits: () => (/* binding */ bombUnits),\n/* harmony export */   otherUnits: () => (/* binding */ otherUnits),\n/* harmony export */   unitTypeToBombUnit: () => (/* binding */ unitTypeToBombUnit),\n/* harmony export */   unitTypeToOtherUnit: () => (/* binding */ unitTypeToOtherUnit)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"./node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game/Game */ \"./src/core/game/Game.ts\");\n\n\nconst bombUnits = [\"abomb\", \"hbomb\", \"mirv\", \"mirvw\"];\nconst BombUnitSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"](bombUnits);\nconst unitTypeToBombUnit = {\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.AtomBomb]: \"abomb\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.HydrogenBomb]: \"hbomb\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MIRV]: \"mirv\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MIRVWarhead]: \"mirvw\",\n};\nconst boatUnits = [\"trade\", \"trans\"];\nconst BoatUnitSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"](boatUnits);\n// export const unitTypeToBoatUnit = {\n//   [UnitType.TradeShip]: \"trade\",\n//   [UnitType.TransportShip]: \"trans\",\n// } as const satisfies Record<BoatUnitType, BoatUnit>;\nconst otherUnits = [\n    \"city\",\n    \"defp\",\n    \"port\",\n    \"wshp\",\n    \"silo\",\n    \"saml\",\n    \"fact\",\n];\nconst OtherUnitSchema = zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"](otherUnits);\nconst unitTypeToOtherUnit = {\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.City]: \"city\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.DefensePost]: \"defp\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MissileSilo]: \"silo\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port]: \"port\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.SAMLauncher]: \"saml\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Warship]: \"wshp\",\n    [_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Factory]: \"fact\",\n};\n// Attacks\nconst ATTACK_INDEX_SENT = 0; // Outgoing attack troops\nconst ATTACK_INDEX_RECV = 1; // Incmoing attack troops\nconst ATTACK_INDEX_CANCEL = 2; // Cancelled attack troops\n// Boats\nconst BOAT_INDEX_SENT = 0; // Boats launched\nconst BOAT_INDEX_ARRIVE = 1; // Boats arrived\nconst BOAT_INDEX_CAPTURE = 2; // Boats captured\nconst BOAT_INDEX_DESTROY = 3; // Boats destroyed\n// Bombs\nconst BOMB_INDEX_LAUNCH = 0; // Bombs launched\nconst BOMB_INDEX_LAND = 1; // Bombs landed\nconst BOMB_INDEX_INTERCEPT = 2; // Bombs intercepted\n// Gold\nconst GOLD_INDEX_WORK = 0; // Gold earned by workers\nconst GOLD_INDEX_WAR = 1; // Gold earned by conquering players\nconst GOLD_INDEX_TRADE = 2; // Gold earned by trade ships\nconst GOLD_INDEX_STEAL = 3; // Gold earned by capturing trade ships\n// Other Units\nconst OTHER_INDEX_BUILT = 0; // Structures and warships built\nconst OTHER_INDEX_DESTROY = 1; // Structures and warships destroyed\nconst OTHER_INDEX_CAPTURE = 2; // Structures captured\nconst OTHER_INDEX_LOST = 3; // Structures/warships destroyed/captured by others\nconst OTHER_INDEX_UPGRADE = 4; // Structures upgraded\nconst BigIntStringSchema = zod__WEBPACK_IMPORTED_MODULE_0__.preprocess((val) => {\n    if (typeof val === \"string\" && /^-?\\d+$/.test(val))\n        return BigInt(val);\n    if (typeof val === \"bigint\")\n        return val;\n    return val;\n}, zod__WEBPACK_IMPORTED_MODULE_0__.bigint());\nconst AtLeastOneNumberSchema = BigIntStringSchema.array().min(1);\nconst PlayerStatsSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    attacks: AtLeastOneNumberSchema.optional(),\n    betrayals: BigIntStringSchema.optional(),\n    killedAt: BigIntStringSchema.optional(),\n    conquests: BigIntStringSchema.optional(),\n    boats: zod__WEBPACK_IMPORTED_MODULE_0__.partialRecord(BoatUnitSchema, AtLeastOneNumberSchema).optional(),\n    bombs: zod__WEBPACK_IMPORTED_MODULE_0__.partialRecord(BombUnitSchema, AtLeastOneNumberSchema).optional(),\n    gold: AtLeastOneNumberSchema.optional(),\n    units: zod__WEBPACK_IMPORTED_MODULE_0__.partialRecord(OtherUnitSchema, AtLeastOneNumberSchema).optional(),\n})\n    .optional();\n\n\n//# sourceURL=webpack://openfront-client/./src/core/StatsSchemas.ts?\n}");

/***/ }),

/***/ "./src/core/Util.ts":
/*!**************************!*\
  !*** ./src/core/Util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   boundingBoxTiles: () => (/* binding */ boundingBoxTiles),\n/* harmony export */   calculateBoundingBox: () => (/* binding */ calculateBoundingBox),\n/* harmony export */   calculateBoundingBoxCenter: () => (/* binding */ calculateBoundingBoxCenter),\n/* harmony export */   createPartialGameRecord: () => (/* binding */ createPartialGameRecord),\n/* harmony export */   createRandomName: () => (/* binding */ createRandomName),\n/* harmony export */   decompressGameRecord: () => (/* binding */ decompressGameRecord),\n/* harmony export */   distSort: () => (/* binding */ distSort),\n/* harmony export */   distSortUnit: () => (/* binding */ distSortUnit),\n/* harmony export */   emojiTable: () => (/* binding */ emojiTable),\n/* harmony export */   flattenedEmojiTable: () => (/* binding */ flattenedEmojiTable),\n/* harmony export */   generateID: () => (/* binding */ generateID),\n/* harmony export */   getMode: () => (/* binding */ getMode),\n/* harmony export */   inscribed: () => (/* binding */ inscribed),\n/* harmony export */   manhattanDistWrapped: () => (/* binding */ manhattanDistWrapped),\n/* harmony export */   maxInt: () => (/* binding */ maxInt),\n/* harmony export */   minInt: () => (/* binding */ minInt),\n/* harmony export */   onlyImages: () => (/* binding */ onlyImages),\n/* harmony export */   replacer: () => (/* binding */ replacer),\n/* harmony export */   sanitize: () => (/* binding */ sanitize),\n/* harmony export */   sigmoid: () => (/* binding */ sigmoid),\n/* harmony export */   simpleHash: () => (/* binding */ simpleHash),\n/* harmony export */   toInt: () => (/* binding */ toInt),\n/* harmony export */   within: () => (/* binding */ within),\n/* harmony export */   withinInt: () => (/* binding */ withinInt)\n/* harmony export */ });\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.es.mjs\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nanoid */ \"./node_modules/nanoid/index.browser.js\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _execution_utils_BotNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./execution/utils/BotNames */ \"./src/core/execution/utils/BotNames.ts\");\n\n\n\n\nfunction manhattanDistWrapped(c1, c2, width) {\n    // Calculate x distance\n    let dx = Math.abs(c1.x - c2.x);\n    // Check if wrapping around the x-axis is shorter\n    dx = Math.min(dx, width - dx);\n    // Calculate y distance (no wrapping for y-axis)\n    const dy = Math.abs(c1.y - c2.y);\n    // Return the sum of x and y distances\n    return dx + dy;\n}\nfunction within(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\nfunction distSort(gm, target) {\n    return (a, b) => {\n        return gm.manhattanDist(a, target) - gm.manhattanDist(b, target);\n    };\n}\nfunction distSortUnit(gm, target) {\n    const targetRef = typeof target === \"number\" ? target : target.tile();\n    return (a, b) => {\n        return (gm.manhattanDist(a.tile(), targetRef) -\n            gm.manhattanDist(b.tile(), targetRef));\n    };\n}\nfunction simpleHash(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n}\nfunction calculateBoundingBox(gm, borderTiles) {\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    borderTiles.forEach((tile) => {\n        const cell = gm.cell(tile);\n        minX = Math.min(minX, cell.x);\n        minY = Math.min(minY, cell.y);\n        maxX = Math.max(maxX, cell.x);\n        maxY = Math.max(maxY, cell.y);\n    });\n    return { min: new _game_Game__WEBPACK_IMPORTED_MODULE_2__.Cell(minX, minY), max: new _game_Game__WEBPACK_IMPORTED_MODULE_2__.Cell(maxX, maxY) };\n}\nfunction boundingBoxTiles(gm, center, radius) {\n    const tiles = [];\n    const centerX = gm.x(center);\n    const centerY = gm.y(center);\n    const minX = centerX - radius;\n    const maxX = centerX + radius;\n    const minY = centerY - radius;\n    const maxY = centerY + radius;\n    // Top and bottom edges (full width)\n    for (let x = minX; x <= maxX; x++) {\n        if (gm.isValidCoord(x, minY)) {\n            tiles.push(gm.ref(x, minY));\n        }\n        if (gm.isValidCoord(x, maxY) && minY !== maxY) {\n            tiles.push(gm.ref(x, maxY));\n        }\n    }\n    // Left and right edges (exclude corners already added)\n    for (let y = minY + 1; y < maxY; y++) {\n        if (gm.isValidCoord(minX, y)) {\n            tiles.push(gm.ref(minX, y));\n        }\n        if (gm.isValidCoord(maxX, y) && minX !== maxX) {\n            tiles.push(gm.ref(maxX, y));\n        }\n    }\n    return tiles;\n}\nfunction getMode(counts) {\n    let mode = null;\n    let maxCount = 0;\n    for (const [item, count] of counts) {\n        if (count > maxCount) {\n            maxCount = count;\n            mode = item;\n        }\n    }\n    return mode;\n}\nfunction calculateBoundingBoxCenter(gm, borderTiles) {\n    const { min, max } = calculateBoundingBox(gm, borderTiles);\n    return new _game_Game__WEBPACK_IMPORTED_MODULE_2__.Cell(min.x + Math.floor((max.x - min.x) / 2), min.y + Math.floor((max.y - min.y) / 2));\n}\nfunction inscribed(outer, inner) {\n    return (outer.min.x <= inner.min.x &&\n        outer.min.y <= inner.min.y &&\n        outer.max.x >= inner.max.x &&\n        outer.max.y >= inner.max.y);\n}\nfunction sanitize(name) {\n    return Array.from(name)\n        .join(\"\")\n        .replace(/[^\\p{L}\\p{N}\\s\\p{Emoji}\\p{Emoji_Component}[\\]_]/gu, \"\");\n}\nfunction onlyImages(html) {\n    return dompurify__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sanitize(html, {\n        ALLOWED_TAGS: [\"span\", \"img\"],\n        ALLOWED_ATTR: [\"src\", \"alt\", \"class\", \"style\"],\n        ALLOWED_URI_REGEXP: /^https:\\/\\/cdn\\.jsdelivr\\.net\\/gh\\/twitter\\/twemoji/,\n        ADD_ATTR: [\"style\"],\n    });\n}\nfunction createPartialGameRecord(gameID, config, \n// username does not need to be set.\nplayers, allTurns, start, end, winner) {\n    const duration = Math.floor((end - start) / 1000);\n    const num_turns = allTurns.length;\n    const turns = allTurns.filter((t) => t.intents.length !== 0 || t.hash !== undefined);\n    const record = {\n        info: {\n            gameID,\n            config,\n            players,\n            start,\n            end,\n            duration,\n            num_turns,\n            winner,\n        },\n        version: \"v0.0.2\",\n        turns,\n    };\n    return record;\n}\nfunction decompressGameRecord(gameRecord) {\n    const turns = [];\n    let lastTurnNum = -1;\n    for (const turn of gameRecord.turns) {\n        while (lastTurnNum < turn.turnNumber - 1) {\n            lastTurnNum++;\n            turns.push({\n                turnNumber: lastTurnNum,\n                intents: [],\n            });\n        }\n        turns.push(turn);\n        lastTurnNum = turn.turnNumber;\n    }\n    const turnLength = turns.length;\n    for (let i = turnLength; i < gameRecord.info.num_turns; i++) {\n        turns.push({\n            turnNumber: i,\n            intents: [],\n        });\n    }\n    gameRecord.turns = turns;\n    return gameRecord;\n}\nfunction assertNever(x) {\n    throw new Error(\"Unexpected value: \" + x);\n}\nfunction generateID() {\n    const nanoid = (0,nanoid__WEBPACK_IMPORTED_MODULE_1__.customAlphabet)(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", 8);\n    return nanoid();\n}\nfunction toInt(num) {\n    if (num === Infinity) {\n        return BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    if (num === -Infinity) {\n        return BigInt(Number.MIN_SAFE_INTEGER);\n    }\n    return BigInt(Math.floor(num));\n}\nfunction maxInt(a, b) {\n    return a > b ? a : b;\n}\nfunction minInt(a, b) {\n    return a < b ? a : b;\n}\nfunction withinInt(num, min, max) {\n    const atLeastMin = maxInt(num, min);\n    return minInt(atLeastMin, max);\n}\nfunction createRandomName(name, playerType) {\n    let randomName = null;\n    if (playerType === \"HUMAN\") {\n        const hash = simpleHash(name);\n        const prefixIndex = hash % _execution_utils_BotNames__WEBPACK_IMPORTED_MODULE_3__.BOT_NAME_PREFIXES.length;\n        const suffixIndex = Math.floor(hash / _execution_utils_BotNames__WEBPACK_IMPORTED_MODULE_3__.BOT_NAME_PREFIXES.length) % _execution_utils_BotNames__WEBPACK_IMPORTED_MODULE_3__.BOT_NAME_SUFFIXES.length;\n        randomName = `ðŸ‘¤ ${_execution_utils_BotNames__WEBPACK_IMPORTED_MODULE_3__.BOT_NAME_PREFIXES[prefixIndex]} ${_execution_utils_BotNames__WEBPACK_IMPORTED_MODULE_3__.BOT_NAME_SUFFIXES[suffixIndex]}`;\n    }\n    return randomName;\n}\nconst emojiTable = [\n    [\"ðŸ˜€\", \"ðŸ˜Š\", \"ðŸ¥°\", \"ðŸ˜‡\", \"ðŸ˜Ž\"],\n    [\"ðŸ˜ž\", \"ðŸ¥º\", \"ðŸ˜­\", \"ðŸ˜±\", \"ðŸ˜¡\"],\n    [\"ðŸ˜ˆ\", \"ðŸ¤¡\", \"ðŸ–•\", \"ðŸ¥±\", \"ðŸ¤¦â€â™‚ï¸\"],\n    [\"ðŸ‘‹\", \"ðŸ‘\", \"ðŸ¤Œ\", \"ðŸ’ª\", \"ðŸ«¡\"],\n    [\"ðŸ‘\", \"ðŸ‘Ž\", \"â“\", \"ðŸ”\", \"ðŸ€\"],\n    [\"ðŸ¤\", \"ðŸ†˜\", \"ðŸ•Šï¸\", \"ðŸ³ï¸\", \"â³\"],\n    [\"ðŸ”¥\", \"ðŸ’¥\", \"ðŸ’€\", \"â˜¢ï¸\", \"âš ï¸\"],\n    [\"â†–ï¸\", \"â¬†ï¸\", \"â†—ï¸\", \"ðŸ‘‘\", \"ðŸ¥‡\"],\n    [\"â¬…ï¸\", \"ðŸŽ¯\", \"âž¡ï¸\", \"ðŸ¥ˆ\", \"ðŸ¥‰\"],\n    [\"â†™ï¸\", \"â¬‡ï¸\", \"â†˜ï¸\", \"â¤ï¸\", \"ðŸ’”\"],\n    [\"ðŸ’°\", \"âš“\", \"â›µ\", \"ðŸ¡\", \"ðŸ›¡ï¸\"],\n];\n// 2d to 1d array\nconst flattenedEmojiTable = emojiTable.flat();\n/**\n * JSON.stringify replacer function that converts bigint values to strings.\n */\nfunction replacer(_key, value) {\n    return typeof value === \"bigint\" ? value.toString() : value;\n}\nfunction sigmoid(value, decayRate, midpoint) {\n    return 1 / (1 + Math.exp(-decayRate * (value - midpoint)));\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/Util.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/ColorAllocator.ts":
/*!**************************************************!*\
  !*** ./src/core/configuration/ColorAllocator.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColorAllocator: () => (/* binding */ ColorAllocator),\n/* harmony export */   selectDistinctColorIndex: () => (/* binding */ selectDistinctColorIndex)\n/* harmony export */ });\n/* harmony import */ var colord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colord */ \"./node_modules/colord/index.mjs\");\n/* harmony import */ var colord_plugins_lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colord/plugins/lab */ \"./node_modules/colord/plugins/lab.mjs\");\n/* harmony import */ var colord_plugins_lch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! colord/plugins/lch */ \"./node_modules/colord/plugins/lch.mjs\");\n/* harmony import */ var colorjs_io__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! colorjs.io */ \"./node_modules/colorjs.io/dist/color.js\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Colors */ \"./src/core/configuration/Colors.ts\");\n\n\n\n\n\n\n\n\n(0,colord__WEBPACK_IMPORTED_MODULE_0__.extend)([colord_plugins_lch__WEBPACK_IMPORTED_MODULE_2__[\"default\"]]);\n(0,colord__WEBPACK_IMPORTED_MODULE_0__.extend)([colord_plugins_lab__WEBPACK_IMPORTED_MODULE_1__[\"default\"]]);\nclass ColorAllocator {\n    constructor(colors, fallback) {\n        this.assigned = new Map();\n        this.teamPlayerColors = new Map();\n        this.availableColors = [...colors];\n        this.fallbackColors = [...colors, ...fallback];\n    }\n    getTeamColorVariations(team) {\n        switch (team) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Blue:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.blueTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Red:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.redTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Teal:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.tealTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Purple:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.purpleTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Yellow:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.yellowTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Orange:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.orangeTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Green:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.greenTeamColors;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Bot:\n                return _Colors__WEBPACK_IMPORTED_MODULE_7__.botTeamColors;\n            default:\n                return [this.assignColor(team)];\n        }\n    }\n    assignColor(id) {\n        if (this.assigned.has(id)) {\n            return this.assigned.get(id);\n        }\n        if (this.availableColors.length === 0) {\n            this.availableColors = [...this.fallbackColors];\n        }\n        let selectedIndex = 0;\n        if (this.assigned.size === 0 || this.assigned.size > 50) {\n            // Randomly pick the first color if no colors have been assigned yet.\n            //\n            // Or if more than 50 colors assigned just pick a random one for perf reasons,\n            // as selecting a distinct color is O(n^2), and the color palette is mostly exhausted anyways.\n            const rand = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_5__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_6__.simpleHash)(id));\n            selectedIndex = rand.nextInt(0, this.availableColors.length);\n        }\n        else {\n            const assignedColors = Array.from(this.assigned.values());\n            selectedIndex =\n                selectDistinctColorIndex(this.availableColors, assignedColors) ?? 0;\n        }\n        const color = this.availableColors.splice(selectedIndex, 1)[0];\n        this.assigned.set(id, color);\n        return color;\n    }\n    assignTeamColor(team) {\n        const teamColors = this.getTeamColorVariations(team);\n        return teamColors[0];\n    }\n    assignTeamPlayerColor(team, playerId) {\n        if (this.teamPlayerColors.has(playerId)) {\n            return this.teamPlayerColors.get(playerId);\n        }\n        const teamColors = this.getTeamColorVariations(team);\n        const hashValue = (0,_Util__WEBPACK_IMPORTED_MODULE_6__.simpleHash)(playerId);\n        const colorIndex = hashValue % teamColors.length;\n        const color = teamColors[colorIndex];\n        this.teamPlayerColors.set(playerId, color);\n        return color;\n    }\n}\n// Select a distinct color index from the available colors that\n// is most different from the assigned colors\nfunction selectDistinctColorIndex(availableColors, assignedColors) {\n    if (assignedColors.length === 0) {\n        throw new Error(\"No assigned colors\");\n    }\n    const assignedLabColors = assignedColors.map(toColor);\n    let maxDeltaE = 0;\n    let maxIndex = 0;\n    for (let i = 0; i < availableColors.length; i++) {\n        const color = availableColors[i];\n        const deltaE = minDeltaE(toColor(color), assignedLabColors);\n        if (deltaE > maxDeltaE) {\n            maxDeltaE = deltaE;\n            maxIndex = i;\n        }\n    }\n    return maxIndex;\n}\nfunction minDeltaE(lab1, assignedLabColors) {\n    return assignedLabColors.reduce((min, assigned) => {\n        return Math.min(min, deltaE2000(lab1, assigned));\n    }, Infinity);\n}\nfunction deltaE2000(c1, c2) {\n    return c1.deltaE(c2, \"2000\");\n}\nfunction toColor(colord) {\n    const lab = colord.toLab();\n    return new colorjs_io__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"lab\", [lab.l, lab.a, lab.b]);\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/ColorAllocator.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/Colors.ts":
/*!******************************************!*\
  !*** ./src/core/configuration/Colors.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blue: () => (/* binding */ blue),\n/* harmony export */   blueTeamColors: () => (/* binding */ blueTeamColors),\n/* harmony export */   botColor: () => (/* binding */ botColor),\n/* harmony export */   botColors: () => (/* binding */ botColors),\n/* harmony export */   botTeamColors: () => (/* binding */ botTeamColors),\n/* harmony export */   fallbackColors: () => (/* binding */ fallbackColors),\n/* harmony export */   green: () => (/* binding */ green),\n/* harmony export */   greenTeamColors: () => (/* binding */ greenTeamColors),\n/* harmony export */   humanColors: () => (/* binding */ humanColors),\n/* harmony export */   nationColors: () => (/* binding */ nationColors),\n/* harmony export */   orange: () => (/* binding */ orange),\n/* harmony export */   orangeTeamColors: () => (/* binding */ orangeTeamColors),\n/* harmony export */   purple: () => (/* binding */ purple),\n/* harmony export */   purpleTeamColors: () => (/* binding */ purpleTeamColors),\n/* harmony export */   red: () => (/* binding */ red),\n/* harmony export */   redTeamColors: () => (/* binding */ redTeamColors),\n/* harmony export */   teal: () => (/* binding */ teal),\n/* harmony export */   tealTeamColors: () => (/* binding */ tealTeamColors),\n/* harmony export */   yellow: () => (/* binding */ yellow),\n/* harmony export */   yellowTeamColors: () => (/* binding */ yellowTeamColors)\n/* harmony export */ });\n/* harmony import */ var colord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colord */ \"./node_modules/colord/index.mjs\");\n/* harmony import */ var colord_plugins_lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! colord/plugins/lab */ \"./node_modules/colord/plugins/lab.mjs\");\n/* harmony import */ var colord_plugins_lch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! colord/plugins/lch */ \"./node_modules/colord/plugins/lch.mjs\");\n\n\n\n(0,colord__WEBPACK_IMPORTED_MODULE_0__.extend)([colord_plugins_lch__WEBPACK_IMPORTED_MODULE_2__[\"default\"]]);\n(0,colord__WEBPACK_IMPORTED_MODULE_0__.extend)([colord_plugins_lab__WEBPACK_IMPORTED_MODULE_1__[\"default\"]]);\nconst red = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 0, s: 82, l: 56 });\nconst blue = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 224, s: 100, l: 58 });\nconst teal = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 172, s: 66, l: 50 });\nconst purple = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 271, s: 81, l: 56 });\nconst yellow = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 45, s: 93, l: 47 });\nconst orange = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 25, s: 95, l: 53 });\nconst green = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 128, s: 49, l: 50 });\nconst botColor = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ h: 36, s: 10, l: 80 });\nconst redTeamColors = generateTeamColors(red);\nconst blueTeamColors = generateTeamColors(blue);\nconst tealTeamColors = generateTeamColors(teal);\nconst purpleTeamColors = generateTeamColors(purple);\nconst yellowTeamColors = generateTeamColors(yellow);\nconst orangeTeamColors = generateTeamColors(orange);\nconst greenTeamColors = generateTeamColors(green);\nconst botTeamColors = [(0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)(botColor)];\nfunction generateTeamColors(baseColor) {\n    const { h: baseHue, s: baseSaturation, l: baseLightness } = baseColor.toHsl();\n    const colorCount = 64;\n    return Array.from({ length: colorCount }, (_, index) => {\n        const progression = index / (colorCount - 1);\n        const saturation = baseSaturation * (1.0 - 0.3 * progression);\n        const lightness = Math.min(100, baseLightness + progression * 30);\n        return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n            h: baseHue,\n            s: saturation,\n            l: lightness,\n        });\n    });\n}\nconst nationColors = [\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 100, b: 100 }), // Bright Red\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 180, b: 230 }), // Sky Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 180, b: 80 }), // Golden Yellow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 100, b: 230 }), // Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 80, g: 200, b: 120 }), // Emerald Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 130, b: 180 }), // Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 160, b: 80 }), // Olive Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 150, b: 100 }), // Peach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 80, g: 130, b: 190 }), // Navy Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 210, b: 100 }), // Lime Yellow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 100, b: 130 }), // Maroon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 210, b: 210 }), // Turquoise\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 140, b: 80 }), // Light Orange\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 110, b: 190 }), // Lavender\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 210, b: 120 }), // Light Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 100, b: 160 }), // Hot Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 140, b: 110 }), // Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 180, b: 180 }), // Light Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 120, b: 190 }), // Periwinkle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 170, b: 100 }), // Sand\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 180, b: 160 }), // Aquamarine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 160, b: 200 }), // Orchid\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 190, b: 100 }), // Yellow Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 130, b: 150 }), // Steel Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 140, b: 140 }), // Salmon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 180, b: 220 }), // Light Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 160, b: 110 }), // Tan\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 130, b: 180 }), // Plum\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 200, b: 130 }), // Light Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 120, b: 120 }), // Coral\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 160, b: 200 }), // Cornflower Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 200, b: 140 }), // Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 120, b: 160 }), // Purple Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 180, b: 140 }), // Dark Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 130, b: 110 }), // Dark Salmon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 170, b: 190 }), // Cadet Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 180, b: 160 }), // Tan Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 140, b: 190 }), // Medium Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 190, b: 160 }), // Pale Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 150, b: 130 }), // Rosy Brown\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 150, b: 180 }), // Light Slate Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 170, b: 140 }), // Dark Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 130, b: 150 }), // Thistle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 190, b: 180 }), // Pale Blue Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 140, b: 150 }), // Puce\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 180, b: 170 }), // Medium Aquamarine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 160, b: 180 }), // Mauve\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 180, b: 140 }), // Dark Olive Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 150, b: 170 }), // Dusty Rose\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 180, b: 230 }), // Sky Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 180, b: 80 }), // Golden Yellow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 100, b: 230 }), // Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 80, g: 200, b: 120 }), // Emerald Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 130, b: 180 }), // Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 160, b: 80 }), // Olive Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 150, b: 100 }), // Peach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 80, g: 130, b: 190 }), // Navy Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 210, b: 100 }), // Lime Yellow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 100, b: 130 }), // Maroon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 210, b: 210 }), // Turquoise\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 140, b: 80 }), // Light Orange\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 110, b: 190 }), // Lavender\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 210, b: 120 }), // Light Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 100, b: 160 }), // Hot Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 140, b: 110 }), // Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 180, b: 180 }), // Light Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 120, b: 190 }), // Periwinkle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 170, b: 100 }), // Sand\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 180, b: 160 }), // Aquamarine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 160, b: 200 }), // Orchid\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 190, b: 100 }), // Yellow Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 130, b: 150 }), // Steel Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 140, b: 140 }), // Salmon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 180, b: 220 }), // Light Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 160, b: 110 }), // Tan\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 130, b: 180 }), // Plum\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 200, b: 130 }), // Light Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 120, b: 120 }), // Coral\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 160, b: 200 }), // Cornflower Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 200, b: 140 }), // Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 120, b: 160 }), // Purple Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 180, b: 140 }), // Dark Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 130, b: 110 }), // Dark Salmon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 170, b: 190 }), // Cadet Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 180, b: 160 }), // Tan Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 140, b: 190 }), // Medium Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 190, b: 160 }), // Pale Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 150, b: 130 }), // Rosy Brown\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 150, b: 180 }), // Light Slate Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 170, b: 140 }), // Dark Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 130, b: 150 }), // Thistle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 190, b: 180 }), // Pale Blue Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 140, b: 150 }), // Puce\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 180, b: 170 }), // Medium Aquamarine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 160, b: 180 }), // Mauve\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 180, b: 140 }), // Dark Olive Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 150, b: 170 }), // Dusty Rose\n];\n// Bright pastel theme with 64 colors\nconst humanColors = [\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 16, g: 185, b: 129 }), // Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 34, g: 197, b: 94 }), // Emerald\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 45, g: 212, b: 191 }), // Turquoise\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 48, g: 178, b: 180 }), // Teal\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 52, g: 211, b: 153 }), // Spearmint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 56, g: 189, b: 248 }), // Light Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 59, g: 130, b: 246 }), // Royal Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 67, g: 190, b: 84 }), // Fresh Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 74, g: 222, b: 128 }), // Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 79, g: 70, b: 229 }), // Indigo\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 82, g: 183, b: 136 }), // Jade\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 96, g: 165, b: 250 }), // Sky Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 99, g: 202, b: 253 }), // Azure\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 110, g: 231, b: 183 }), // Seafoam\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 124, g: 58, b: 237 }), // Royal Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 125, g: 211, b: 252 }), // Crystal Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 132, g: 204, b: 22 }), // Lime\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 133, g: 77, b: 14 }), // Chocolate\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 134, g: 239, b: 172 }), // Light Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 147, g: 51, b: 234 }), // Bright Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 147, g: 197, b: 253 }), // Powder Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 151, g: 255, b: 187 }), // Fresh Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 163, g: 230, b: 53 }), // Yellow Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 167, g: 139, b: 250 }), // Periwinkle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 168, g: 85, b: 247 }), // Vibrant Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 179, g: 136, b: 255 }), // Light Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 186, g: 255, b: 201 }), // Pale Emerald\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 92, b: 251 }), // Amethyst\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 192, g: 132, b: 252 }), // Lavender\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 202, g: 138, b: 4 }), // Rich Gold\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 202, g: 225, b: 255 }), // Baby Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 204, g: 204, b: 255 }), // Soft Lavender Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 217, g: 70, b: 239 }), // Fuchsia\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 38, b: 38 }), // Ruby\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 220, b: 255 }), // Meringue Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 240, b: 250 }), // Ice Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 250, b: 210 }), // Pastel Lime\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 255, b: 250 }), // Mint Whisper\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 233, g: 213, b: 255 }), // Light Lilac\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 234, g: 88, b: 12 }), // Burnt Orange\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 234, g: 179, b: 8 }), // Sunflower\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 235, g: 75, b: 75 }), // Bright Red\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 236, g: 72, b: 153 }), // Deep Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 239, g: 68, b: 68 }), // Crimson\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 240, g: 171, b: 252 }), // Orchid\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 240, g: 240, b: 200 }), // Light Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 244, g: 114, b: 182 }), // Rose\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 245, g: 101, b: 101 }), // Coral\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 245, g: 158, b: 11 }), // Amber\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 248, g: 113, b: 113 }), // Warm Red\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 249, g: 115, b: 22 }), // Tangerine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 250, g: 215, b: 225 }), // Cotton Candy\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 250, g: 250, b: 210 }), // Pastel Lemon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 251, g: 113, b: 133 }), // Watermelon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 251, g: 146, b: 60 }), // Light Orange\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 251, g: 191, b: 36 }), // Marigold\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 251, g: 235, b: 245 }), // Rose Powder\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 252, g: 165, b: 165 }), // Peach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 252, g: 211, b: 77 }), // Golden\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 253, g: 164, b: 175 }), // Salmon Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 204, b: 229 }), // Blush Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 223, b: 186 }), // Apricot Cream\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 240, b: 200 }), // Vanilla\n];\nconst botColors = [\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 120, b: 120 }), // Muted Red\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 160, b: 190 }), // Muted Sky Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 160, b: 100 }), // Muted Golden Yellow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 120, b: 190 }), // Muted Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 170, b: 130 }), // Muted Emerald Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 130, b: 160 }), // Muted Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 150, b: 100 }), // Muted Olive Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 140, b: 120 }), // Muted Peach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 120, b: 160 }), // Muted Navy Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 170, b: 120 }), // Muted Lime Yellow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 120, b: 130 }), // Muted Maroon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 170, b: 170 }), // Muted Turquoise\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 140, b: 100 }), // Muted Light Orange\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 120, b: 160 }), // Muted Lavender\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 170, b: 130 }), // Muted Light Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 120, b: 140 }), // Muted Hot Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 140, b: 120 }), // Muted Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 160, b: 160 }), // Muted Light Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 130, b: 160 }), // Muted Periwinkle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 150, b: 120 }), // Muted Sand\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 160, b: 150 }), // Muted Aquamarine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 150, b: 170 }), // Muted Orchid\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 160, b: 120 }), // Muted Yellow Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 130, b: 140 }), // Muted Steel Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 140, b: 140 }), // Muted Salmon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 160, b: 170 }), // Muted Light Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 150, b: 130 }), // Muted Tan\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 130, b: 160 }), // Muted Plum\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 170, b: 130 }), // Muted Light Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 130, b: 130 }), // Muted Coral\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 150, b: 170 }), // Muted Cornflower Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 170, b: 140 }), // Muted Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 130, b: 150 }), // Muted Purple Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 160, b: 140 }), // Muted Dark Sea Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 130, b: 120 }), // Muted Dark Salmon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 150, b: 160 }), // Muted Cadet Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 160, b: 150 }), // Muted Tan Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 140, b: 160 }), // Muted Medium Purple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 170, b: 150 }), // Muted Pale Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 140, b: 130 }), // Muted Rosy Brown\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 150, b: 160 }), // Muted Light Slate Gray\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 150, b: 140 }), // Muted Dark Khaki\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 130, b: 140 }), // Muted Thistle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 160, b: 160 }), // Muted Pale Blue Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 140, b: 150 }), // Muted Puce\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 160, b: 150 }), // Muted Medium Aquamarine\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 150, b: 160 }), // Muted Mauve\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 160, b: 140 }), // Muted Dark Olive Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 140, b: 150 }), // Muted Dusty Rose\n];\n// Fallback colors for when the color palette is exhausted. Currently 100 colors.\nconst fallbackColors = [\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 5, b: 0 }), // Black Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 15, b: 0 }), // Deep Forest\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 25, b: 0 }), // Jungle\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 35, b: 0 }), // Dark Emerald\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 45, b: 0 }), // Green Moss\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 55, b: 0 }), // Moss Shadow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 65, b: 0 }), // Dark Meadow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 75, b: 0 }), // Forest Fern\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 85, b: 0 }), // Pine Leaf\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 95, b: 0 }), // Shadow Grass\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 105, b: 0 }), // Classic Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 115, b: 0 }), // Deep Lime\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 125, b: 0 }), // Dense Leaf\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 135, b: 0 }), // Basil Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 145, b: 0 }), // Organic Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 155, b: 0 }), // Bitter Herb\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 165, b: 0 }), // Raw Spinach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 175, b: 0 }), // Woodland\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 185, b: 0 }), // Spring Weed\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 195, b: 5 }), // Apple Stem\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 205, b: 10 }), // Crisp Lettuce\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 215, b: 15 }), // Vibrant Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 225, b: 20 }), // Bright Herb\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 235, b: 25 }), // Green Splash\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 245, b: 30 }), // Mint Leaf\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 255, b: 35 }), // Fresh Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 10, g: 255, b: 45 }), // Neon Grass\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 20, g: 255, b: 55 }), // Lemon Balm\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 30, g: 255, b: 65 }), // Juicy Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 40, g: 255, b: 75 }), // Pear Tint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 50, g: 255, b: 85 }), // Avocado Pastel\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 60, g: 255, b: 95 }), // Lime Glow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 70, g: 255, b: 105 }), // Light Leaf\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 80, g: 255, b: 115 }), // Soft Fern\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 90, g: 255, b: 125 }), // Pastel Green\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 255, b: 135 }), // Green Melon\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 110, g: 255, b: 145 }), // Herbal Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 255, b: 155 }), // Kiwi Foam\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 255, b: 165 }), // Aloe Fresh\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 140, g: 255, b: 175 }), // Light Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 200, b: 255 }), // Cornflower Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 150, g: 255, b: 185 }), // Green Sorbet\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 215, b: 255 }), // Powder Blue\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 160, g: 255, b: 195 }), // Pastel Apple\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 190, b: 255 }), // Periwinkle Ice\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 225, b: 255 }), // Baby Sky\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 170, g: 255, b: 205 }), // Aloe Breeze\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 180, b: 255 }), // Pale Indigo\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 235, b: 250 }), // Aqua Pastel\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 180, g: 255, b: 215 }), // Pale Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 140, b: 195 }), // Fuchsia Tint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 245, b: 240 }), // Ice Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 190, g: 255, b: 225 }), // Mint Water\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 195, g: 145, b: 200 }), // Dusky Rose\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 150, b: 205 }), // Plum Frost\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 170, b: 255 }), // Lilac Bloom\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 255, b: 215 }), // Cool Aloe\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 200, g: 255, b: 235 }), // Cool Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 205, g: 155, b: 210 }), // Berry Foam\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 160, b: 215 }), // Grape Cloud\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 210, g: 255, b: 245 }), // Sea Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 215, g: 165, b: 220 }), // Light Bloom\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 215, g: 255, b: 200 }), // Fresh Mint\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 160, b: 255 }), // Violet Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 170, b: 225 }), // Cherry Blossom\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 220, g: 255, b: 255 }), // Pale Aqua\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 225, g: 175, b: 230 }), // Faded Rose\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 225, g: 255, b: 175 }), // Soft Lime\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 180, b: 235 }), // Dreamy Mauve\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 250, b: 255 }), // Sky Haze\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 235, g: 150, b: 255 }), // Orchid Glow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 235, g: 185, b: 240 }), // Powder Violet\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 240, g: 190, b: 245 }), // Pastel Violet\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 240, g: 240, b: 255 }), // Frosted Lilac\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 240, g: 250, b: 160 }), // Citrus Wash\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 245, g: 160, b: 240 }), // Rose Lilac\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 245, g: 195, b: 250 }), // Soft Magenta\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 245, g: 245, b: 175 }), // Lemon Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 250, g: 200, b: 255 }), // Lilac Cream\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 250, g: 230, b: 255 }), // Misty Mauve\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 170, b: 225 }), // Bubblegum Pink\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 185, b: 215 }), // Blush Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 195, b: 235 }), // Faded Fuchsia\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 200, b: 220 }), // Cotton Rose\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 205, b: 245 }), // Pastel Orchid\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 205, b: 255 }), // Violet Bloom\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 210, b: 230 }), // Pastel Blush\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 210, b: 250 }), // Lavender Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 210, b: 255 }), // Orchid Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 215, b: 195 }), // Apricot Glow\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 215, b: 245 }), // Rose Whisper\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 220, b: 235 }), // Pink Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 220, b: 250 }), // Powder Petal\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 225, b: 180 }), // Butter Peach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 225, b: 255 }), // Petal Mist\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 230, b: 245 }), // Light Rose\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 235, b: 200 }), // Cream Peach\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 235, b: 235 }), // Blushed Petal\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 240, b: 220 }), // Pastel Sand\n    (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 245, b: 210 }), // Soft Banana\n];\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/Colors.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/Config.ts":
/*!******************************************!*\
  !*** ./src/core/configuration/Config.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameEnv: () => (/* binding */ GameEnv)\n/* harmony export */ });\nvar GameEnv;\n(function (GameEnv) {\n    GameEnv[GameEnv[\"Dev\"] = 0] = \"Dev\";\n    GameEnv[GameEnv[\"Preprod\"] = 1] = \"Preprod\";\n    GameEnv[GameEnv[\"Prod\"] = 2] = \"Prod\";\n})(GameEnv || (GameEnv = {}));\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/Config.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/ConfigLoader.ts":
/*!************************************************!*\
  !*** ./src/core/configuration/ConfigLoader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cachedSC: () => (/* binding */ cachedSC),\n/* harmony export */   getConfig: () => (/* binding */ getConfig),\n/* harmony export */   getServerConfig: () => (/* binding */ getServerConfig),\n/* harmony export */   getServerConfigFromClient: () => (/* binding */ getServerConfigFromClient),\n/* harmony export */   getServerConfigFromServer: () => (/* binding */ getServerConfigFromServer)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/core/configuration/Config.ts\");\n/* harmony import */ var _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultConfig */ \"./src/core/configuration/DefaultConfig.ts\");\n/* harmony import */ var _DevConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DevConfig */ \"./src/core/configuration/DevConfig.ts\");\n/* harmony import */ var _PreprodConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PreprodConfig */ \"./src/core/configuration/PreprodConfig.ts\");\n/* harmony import */ var _ProdConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProdConfig */ \"./src/core/configuration/ProdConfig.ts\");\n\n\n\n\n\nlet cachedSC = null;\nasync function getConfig(gameConfig, userSettings, isReplay = false) {\n    const sc = await getServerConfigFromClient();\n    switch (sc.env()) {\n        case _Config__WEBPACK_IMPORTED_MODULE_0__.GameEnv.Dev:\n            return new _DevConfig__WEBPACK_IMPORTED_MODULE_2__.DevConfig(sc, gameConfig, userSettings, isReplay);\n        case _Config__WEBPACK_IMPORTED_MODULE_0__.GameEnv.Preprod:\n        case _Config__WEBPACK_IMPORTED_MODULE_0__.GameEnv.Prod:\n            console.log(\"using prod config\");\n            return new _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__.DefaultConfig(sc, gameConfig, userSettings, isReplay);\n        default:\n            throw Error(`unsupported server configuration: ${\"dev\"}`);\n    }\n}\nasync function getServerConfigFromClient() {\n    if (cachedSC) {\n        return cachedSC;\n    }\n    const response = await fetch(\"/api/env\");\n    if (!response.ok) {\n        throw new Error(`Failed to fetch server config: ${response.status} ${response.statusText}`);\n    }\n    const config = await response.json();\n    // Log the retrieved configuration\n    console.log(\"Server config loaded:\", config);\n    cachedSC = getServerConfig(config.game_env);\n    return cachedSC;\n}\nfunction getServerConfigFromServer() {\n    const gameEnv = \"dev\" ?? 0;\n    return getServerConfig(gameEnv);\n}\nfunction getServerConfig(gameEnv) {\n    switch (gameEnv) {\n        case \"dev\":\n            console.log(\"using dev server config\");\n            return new _DevConfig__WEBPACK_IMPORTED_MODULE_2__.DevServerConfig();\n        case \"staging\":\n            console.log(\"using preprod server config\");\n            return _PreprodConfig__WEBPACK_IMPORTED_MODULE_3__.preprodConfig;\n        case \"prod\":\n            console.log(\"using prod server config\");\n            return _ProdConfig__WEBPACK_IMPORTED_MODULE_4__.prodConfig;\n        default:\n            throw Error(`unsupported server configuration: ${gameEnv}`);\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/ConfigLoader.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/DefaultConfig.ts":
/*!*************************************************!*\
  !*** ./src/core/configuration/DefaultConfig.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultConfig: () => (/* binding */ DefaultConfig),\n/* harmony export */   DefaultServerConfig: () => (/* binding */ DefaultServerConfig)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"./node_modules/zod/v4/classic/schemas.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"./node_modules/zod/v4/core/errors.js\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Config */ \"./src/core/configuration/Config.ts\");\n/* harmony import */ var _PastelTheme__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PastelTheme */ \"./src/core/configuration/PastelTheme.ts\");\n/* harmony import */ var _PastelThemeDark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PastelThemeDark */ \"./src/core/configuration/PastelThemeDark.ts\");\n\n\n\n\n\n\nconst DEFENSE_DEBUFF_MIDPOINT = 150000;\nconst DEFENSE_DEBUFF_DECAY_RATE = Math.LN2 / 50000;\nconst JwksSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    keys: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        alg: zod__WEBPACK_IMPORTED_MODULE_0__.literal(\"EdDSA\"),\n        crv: zod__WEBPACK_IMPORTED_MODULE_0__.literal(\"Ed25519\"),\n        kty: zod__WEBPACK_IMPORTED_MODULE_0__.literal(\"OKP\"),\n        x: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    })\n        .array()\n        .min(1),\n});\nconst numPlayersConfig = {\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Africa]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Asia]: [50, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Australia]: [70, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Baikal]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.BetweenTwoSeas]: [70, 50, 40],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.BlackSea]: [50, 30, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Britannia]: [50, 30, 20],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.DeglaciatedAntarctica]: [50, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.EastAsia]: [50, 30, 20],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Europe]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.EuropeClassic]: [50, 30, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.FalklandIslands]: [50, 30, 20],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.FaroeIslands]: [20, 15, 10],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.GatewayToTheAtlantic]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.GiantWorldMap]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Halkidiki]: [100, 50, 40],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Iceland]: [50, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Italia]: [50, 30, 20],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Japan]: [20, 15, 10],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Mars]: [70, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Mena]: [70, 50, 40],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Montreal]: [60, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.NorthAmerica]: [70, 40, 30],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Oceania]: [10, 10, 10],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Pangaea]: [20, 15, 10],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Pluto]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.SouthAmerica]: [70, 50, 40],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.StraitOfGibraltar]: [100, 70, 50],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.World]: [50, 30, 20],\n    [_game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMapType.Yenisei]: [150, 100, 70],\n};\nclass DefaultServerConfig {\n    allowedFlares() {\n        return;\n    }\n    stripePublishableKey() {\n        return  null ?? \"\";\n    }\n    domain() {\n        return process.env.DOMAIN ?? \"\";\n    }\n    subdomain() {\n        return process.env.SUBDOMAIN ?? \"\";\n    }\n    cloudflareAccountId() {\n        return process.env.CF_ACCOUNT_ID ?? \"\";\n    }\n    cloudflareApiToken() {\n        return process.env.CF_API_TOKEN ?? \"\";\n    }\n    cloudflareConfigPath() {\n        return process.env.CF_CONFIG_PATH ?? \"\";\n    }\n    cloudflareCredsPath() {\n        return process.env.CF_CREDS_PATH ?? \"\";\n    }\n    jwtIssuer() {\n        const audience = this.jwtAudience();\n        return audience === \"localhost\"\n            ? \"http://localhost:8787\"\n            : `https://api.${audience}`;\n    }\n    async jwkPublicKey() {\n        if (this.publicKey)\n            return this.publicKey;\n        const jwksUrl = this.jwtIssuer() + \"/.well-known/jwks.json\";\n        console.log(`Fetching JWKS from ${jwksUrl}`);\n        const response = await fetch(jwksUrl);\n        const result = JwksSchema.safeParse(await response.json());\n        if (!result.success) {\n            const error = zod__WEBPACK_IMPORTED_MODULE_1__.prettifyError(result.error);\n            console.error(\"Error parsing JWKS\", error);\n            throw new Error(\"Invalid JWKS\");\n        }\n        this.publicKey = result.data.keys[0];\n        return this.publicKey;\n    }\n    otelEnabled() {\n        return (this.env() !== _Config__WEBPACK_IMPORTED_MODULE_4__.GameEnv.Dev &&\n            Boolean(this.otelEndpoint()) &&\n            Boolean(this.otelAuthHeader()));\n    }\n    otelEndpoint() {\n        return process.env.OTEL_EXPORTER_OTLP_ENDPOINT ?? \"\";\n    }\n    otelAuthHeader() {\n        return process.env.OTEL_AUTH_HEADER ?? \"\";\n    }\n    gitCommit() {\n        return \"73bf5834520daef3eec6c59d0db246d59fc0a486\" ?? 0;\n    }\n    r2Endpoint() {\n        return `https://${process.env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com`;\n    }\n    r2AccessKey() {\n        return process.env.R2_ACCESS_KEY ?? \"\";\n    }\n    r2SecretKey() {\n        return process.env.R2_SECRET_KEY ?? \"\";\n    }\n    r2Bucket() {\n        return process.env.R2_BUCKET ?? \"\";\n    }\n    apiKey() {\n        return process.env.API_KEY ?? \"\";\n    }\n    adminHeader() {\n        return \"x-admin-key\";\n    }\n    adminToken() {\n        return process.env.ADMIN_TOKEN ?? \"dummy-admin-token\";\n    }\n    turnIntervalMs() {\n        return 100;\n    }\n    gameCreationRate() {\n        return 60 * 1000;\n    }\n    lobbyMaxPlayers(map, mode, numPlayerTeams) {\n        const [l, m, s] = numPlayersConfig[map] ?? [50, 30, 20];\n        const r = Math.random();\n        const base = r < 0.3 ? l : r < 0.6 ? m : s;\n        let p = Math.min(mode === _game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMode.Team ? Math.ceil(base * 1.5) : base, l);\n        if (numPlayerTeams === undefined)\n            return p;\n        switch (numPlayerTeams) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Duos:\n                p -= p % 2;\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Trios:\n                p -= p % 3;\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Quads:\n                p -= p % 4;\n                break;\n            default:\n                p -= p % numPlayerTeams;\n                break;\n        }\n        return p;\n    }\n    workerIndex(gameID) {\n        return (0,_Util__WEBPACK_IMPORTED_MODULE_3__.simpleHash)(gameID) % this.numWorkers();\n    }\n    workerPath(gameID) {\n        return `w${this.workerIndex(gameID)}`;\n    }\n    workerPort(gameID) {\n        return this.workerPortByIndex(this.workerIndex(gameID));\n    }\n    workerPortByIndex(index) {\n        return 3001 + index;\n    }\n}\nclass DefaultConfig {\n    constructor(_serverConfig, _gameConfig, _userSettings, _isReplay) {\n        this._serverConfig = _serverConfig;\n        this._gameConfig = _gameConfig;\n        this._userSettings = _userSettings;\n        this._isReplay = _isReplay;\n        this.pastelTheme = new _PastelTheme__WEBPACK_IMPORTED_MODULE_5__.PastelTheme();\n        this.pastelThemeDark = new _PastelThemeDark__WEBPACK_IMPORTED_MODULE_6__.PastelThemeDark();\n    }\n    stripePublishableKey() {\n        return  null ?? \"\";\n    }\n    isReplay() {\n        return this._isReplay;\n    }\n    samHittingChance() {\n        return 0.8;\n    }\n    samWarheadHittingChance() {\n        return 0.5;\n    }\n    traitorDefenseDebuff() {\n        return 0.5;\n    }\n    traitorSpeedDebuff() {\n        return 0.8;\n    }\n    traitorDuration() {\n        return 30 * 10; // 30 seconds\n    }\n    spawnImmunityDuration() {\n        return 5 * 10;\n    }\n    gameConfig() {\n        return this._gameConfig;\n    }\n    serverConfig() {\n        return this._serverConfig;\n    }\n    userSettings() {\n        if (this._userSettings === null) {\n            throw new Error(\"userSettings is null\");\n        }\n        return this._userSettings;\n    }\n    difficultyModifier(difficulty) {\n        switch (difficulty) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Easy:\n                return 1;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Medium:\n                return 3;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Hard:\n                return 9;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Impossible:\n                return 18;\n        }\n    }\n    cityTroopIncrease() {\n        return 250000;\n    }\n    falloutDefenseModifier(falloutRatio) {\n        // falloutRatio is between 0 and 1\n        // So defense modifier is between [5, 2.5]\n        return 5 - falloutRatio * 2;\n    }\n    SAMCooldown() {\n        return 75;\n    }\n    SiloCooldown() {\n        return 75;\n    }\n    defensePostRange() {\n        return 30;\n    }\n    defensePostDefenseBonus() {\n        return 5;\n    }\n    defensePostSpeedBonus() {\n        return 3;\n    }\n    playerTeams() {\n        return this._gameConfig.playerTeams ?? 0;\n    }\n    spawnNPCs() {\n        return !this._gameConfig.disableNPCs;\n    }\n    isUnitDisabled(unitType) {\n        return this._gameConfig.disabledUnits?.includes(unitType) ?? false;\n    }\n    bots() {\n        return this._gameConfig.bots;\n    }\n    instantBuild() {\n        return this._gameConfig.instantBuild;\n    }\n    infiniteGold() {\n        return this._gameConfig.infiniteGold;\n    }\n    donateGold() {\n        return this._gameConfig.donateGold;\n    }\n    infiniteTroops() {\n        return this._gameConfig.infiniteTroops;\n    }\n    donateTroops() {\n        return this._gameConfig.donateTroops;\n    }\n    trainSpawnRate(numPlayerFactories) {\n        // hyperbolic decay, midpoint at 10 factories\n        // expected number of trains = numPlayerFactories  / trainSpawnRate(numPlayerFactories)\n        return (numPlayerFactories + 10) * 20;\n    }\n    trainGold(rel) {\n        switch (rel) {\n            case \"ally\":\n                return 50000n;\n            case \"team\":\n            case \"other\":\n                return 25000n;\n            case \"self\":\n                return 10000n;\n        }\n    }\n    trainStationMinRange() {\n        return 15;\n    }\n    trainStationMaxRange() {\n        return 100;\n    }\n    railroadMaxSize() {\n        return 120;\n    }\n    tradeShipGold(dist, numPorts) {\n        const baseGold = Math.floor(100000 + 100 * dist);\n        const numPortBonus = numPorts - 1;\n        // Hyperbolic decay, midpoint at 5 ports, 3x bonus max.\n        const bonus = 1 + 2 * (numPortBonus / (numPortBonus + 5));\n        return BigInt(Math.floor(baseGold * bonus));\n    }\n    // Probability of trade ship spawn = 1 / tradeShipSpawnRate\n    tradeShipSpawnRate(numTradeShips, numPlayerPorts, numPlayerTradeShips) {\n        // Geometric mean of base spawn rate and port multiplier\n        const combined = Math.sqrt(this.tradeShipBaseSpawn(numTradeShips, numPlayerTradeShips) *\n            this.tradeShipPortMultiplier(numPlayerPorts));\n        return Math.floor(25 / combined);\n    }\n    tradeShipBaseSpawn(numTradeShips, numPlayerTradeShips) {\n        if (numPlayerTradeShips < 3) {\n            // If other players have many ports, then they can starve out smaller players.\n            // So this prevents smaller players from being completely starved out.\n            return 1;\n        }\n        const decayRate = Math.LN2 / 10;\n        return 1 - (0,_Util__WEBPACK_IMPORTED_MODULE_3__.sigmoid)(numTradeShips, decayRate, 55);\n    }\n    tradeShipPortMultiplier(numPlayerPorts) {\n        // Hyperbolic decay function with midpoint at 10 ports\n        // Expected trade ship spawn rate is proportional to numPlayerPorts * multiplier\n        // Gradual decay prevents scenario where more ports => fewer ships\n        const decayRate = 1 / 10;\n        return 1 / (1 + decayRate * numPlayerPorts);\n    }\n    unitInfo(type) {\n        switch (type) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.TransportShip:\n                return {\n                    cost: () => 0n,\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Warship:\n                return {\n                    cost: this.costWrapper((numUnits) => Math.min(1000000, (numUnits + 1) * 250000), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Warship),\n                    territoryBound: false,\n                    maxHealth: 1000,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Shell:\n                return {\n                    cost: () => 0n,\n                    territoryBound: false,\n                    damage: 250,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.SAMMissile:\n                return {\n                    cost: () => 0n,\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Port:\n                return {\n                    cost: this.costWrapper((numUnits) => Math.min(1000000, Math.pow(2, numUnits) * 125000), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Port, _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Factory),\n                    territoryBound: true,\n                    constructionDuration: this.instantBuild() ? 0 : 2 * 10,\n                    upgradable: true,\n                    canBuildTrainStation: true,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.AtomBomb:\n                return {\n                    cost: this.costWrapper(() => 750000, _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.AtomBomb),\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.HydrogenBomb:\n                return {\n                    cost: this.costWrapper(() => 5000000, _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.HydrogenBomb),\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MIRV:\n                return {\n                    cost: this.costWrapper(() => 35000000, _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MIRV),\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MIRVWarhead:\n                return {\n                    cost: () => 0n,\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.TradeShip:\n                return {\n                    cost: () => 0n,\n                    territoryBound: false,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MissileSilo:\n                return {\n                    cost: this.costWrapper(() => 1000000, _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MissileSilo),\n                    territoryBound: true,\n                    constructionDuration: this.instantBuild() ? 0 : 10 * 10,\n                    upgradable: true,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.DefensePost:\n                return {\n                    cost: this.costWrapper((numUnits) => Math.min(250000, (numUnits + 1) * 50000), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.DefensePost),\n                    territoryBound: true,\n                    constructionDuration: this.instantBuild() ? 0 : 5 * 10,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.SAMLauncher:\n                return {\n                    cost: this.costWrapper((numUnits) => Math.min(3000000, (numUnits + 1) * 1500000), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.SAMLauncher),\n                    territoryBound: true,\n                    constructionDuration: this.instantBuild() ? 0 : 30 * 10,\n                    upgradable: true,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.City:\n                return {\n                    cost: this.costWrapper((numUnits) => Math.min(1000000, Math.pow(2, numUnits) * 125000), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.City),\n                    territoryBound: true,\n                    constructionDuration: this.instantBuild() ? 0 : 2 * 10,\n                    upgradable: true,\n                    canBuildTrainStation: true,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Factory:\n                return {\n                    cost: this.costWrapper((numUnits) => Math.min(1000000, Math.pow(2, numUnits) * 125000), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Factory, _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Port),\n                    territoryBound: true,\n                    constructionDuration: this.instantBuild() ? 0 : 2 * 10,\n                    canBuildTrainStation: true,\n                    experimental: true,\n                    upgradable: true,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Construction:\n                return {\n                    cost: () => 0n,\n                    territoryBound: true,\n                };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.Train:\n                return {\n                    cost: () => 0n,\n                    territoryBound: false,\n                    experimental: true,\n                };\n            default:\n                (0,_Util__WEBPACK_IMPORTED_MODULE_3__.assertNever)(type);\n        }\n    }\n    costWrapper(costFn, ...types) {\n        return (p) => {\n            if (p.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Human && this.infiniteGold()) {\n                return 0n;\n            }\n            const numUnits = types.reduce((acc, type) => acc + Math.min(p.unitsOwned(type), p.unitsConstructed(type)), 0);\n            return BigInt(costFn(numUnits));\n        };\n    }\n    defaultDonationAmount(sender) {\n        return Math.floor(sender.troops() / 3);\n    }\n    donateCooldown() {\n        return 10 * 10;\n    }\n    deleteUnitCooldown() {\n        return 5 * 10;\n    }\n    emojiMessageDuration() {\n        return 5 * 10;\n    }\n    emojiMessageCooldown() {\n        return 5 * 10;\n    }\n    targetDuration() {\n        return 10 * 10;\n    }\n    targetCooldown() {\n        return 15 * 10;\n    }\n    allianceRequestDuration() {\n        return 20 * 10;\n    }\n    allianceRequestCooldown() {\n        return 30 * 10;\n    }\n    allianceDuration() {\n        return 300 * 10; // 5 minutes.\n    }\n    temporaryEmbargoDuration() {\n        return 300 * 10; // 5 minutes.\n    }\n    percentageTilesOwnedToWin() {\n        if (this._gameConfig.gameMode === _game_Game__WEBPACK_IMPORTED_MODULE_2__.GameMode.Team) {\n            return 95;\n        }\n        return 80;\n    }\n    boatMaxNumber() {\n        return 3;\n    }\n    numSpawnPhaseTurns() {\n        return this._gameConfig.gameType === _game_Game__WEBPACK_IMPORTED_MODULE_2__.GameType.Singleplayer ? 100 : 300;\n    }\n    numBots() {\n        return this.bots();\n    }\n    theme() {\n        return this.userSettings()?.darkMode()\n            ? this.pastelThemeDark\n            : this.pastelTheme;\n    }\n    attackLogic(gm, attackTroops, attacker, defender, tileToConquer) {\n        let mag = 0;\n        let speed = 0;\n        const type = gm.terrainType(tileToConquer);\n        switch (type) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Plains:\n                mag = 80;\n                speed = 16.5;\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Highland:\n                mag = 100;\n                speed = 20;\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Mountain:\n                mag = 120;\n                speed = 25;\n                break;\n            default:\n                throw new Error(`terrain type ${type} not supported`);\n        }\n        if (defender.isPlayer()) {\n            for (const dp of gm.nearbyUnits(tileToConquer, gm.config().defensePostRange(), _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.DefensePost)) {\n                if (dp.unit.owner() === defender) {\n                    mag *= this.defensePostDefenseBonus();\n                    speed *= this.defensePostSpeedBonus();\n                    break;\n                }\n            }\n        }\n        if (gm.hasFallout(tileToConquer)) {\n            const falloutRatio = gm.numTilesWithFallout() / gm.numLandTiles();\n            mag *= this.falloutDefenseModifier(falloutRatio);\n            speed *= this.falloutDefenseModifier(falloutRatio);\n        }\n        if (attacker.isPlayer() && defender.isPlayer()) {\n            if (defender.isDisconnected() && attacker.isOnSameTeam(defender)) {\n                // No troop loss if defender is disconnected.\n                mag = 0;\n            }\n            if (attacker.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Human &&\n                defender.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n                mag *= 0.8;\n            }\n            if (attacker.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.FakeHuman &&\n                defender.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n                mag *= 0.8;\n            }\n        }\n        if (defender.isPlayer()) {\n            const defenseSig = 1 -\n                (0,_Util__WEBPACK_IMPORTED_MODULE_3__.sigmoid)(defender.numTilesOwned(), DEFENSE_DEBUFF_DECAY_RATE, DEFENSE_DEBUFF_MIDPOINT);\n            const largeDefenderSpeedDebuff = 0.7 + 0.3 * defenseSig;\n            const largeDefenderAttackDebuff = 0.7 + 0.3 * defenseSig;\n            let largeAttackBonus = 1;\n            if (attacker.numTilesOwned() > 100000) {\n                largeAttackBonus = Math.sqrt(100000 / attacker.numTilesOwned()) ** 0.7;\n            }\n            let largeAttackerSpeedBonus = 1;\n            if (attacker.numTilesOwned() > 100000) {\n                largeAttackerSpeedBonus = (100000 / attacker.numTilesOwned()) ** 0.6;\n            }\n            return {\n                attackerTroopLoss: (0,_Util__WEBPACK_IMPORTED_MODULE_3__.within)(defender.troops() / attackTroops, 0.6, 2) *\n                    mag *\n                    0.8 *\n                    largeDefenderAttackDebuff *\n                    largeAttackBonus *\n                    (defender.isTraitor() ? this.traitorDefenseDebuff() : 1),\n                defenderTroopLoss: defender.troops() / defender.numTilesOwned(),\n                tilesPerTickUsed: (0,_Util__WEBPACK_IMPORTED_MODULE_3__.within)(defender.troops() / (5 * attackTroops), 0.2, 1.5) *\n                    speed *\n                    largeDefenderSpeedDebuff *\n                    largeAttackerSpeedBonus *\n                    (defender.isTraitor() ? this.traitorSpeedDebuff() : 1),\n            };\n        }\n        else {\n            return {\n                attackerTroopLoss: attacker.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot ? mag / 10 : mag / 5,\n                defenderTroopLoss: 0,\n                tilesPerTickUsed: (0,_Util__WEBPACK_IMPORTED_MODULE_3__.within)((2000 * Math.max(10, speed)) / attackTroops, 5, 100),\n            };\n        }\n    }\n    attackTilesPerTick(attackTroops, attacker, defender, numAdjacentTilesWithEnemy) {\n        if (defender.isPlayer()) {\n            return ((0,_Util__WEBPACK_IMPORTED_MODULE_3__.within)(((5 * attackTroops) / defender.troops()) * 2, 0.01, 0.5) *\n                numAdjacentTilesWithEnemy *\n                3);\n        }\n        else {\n            return numAdjacentTilesWithEnemy * 2;\n        }\n    }\n    boatAttackAmount(attacker, defender) {\n        return Math.floor(attacker.troops() / 5);\n    }\n    warshipShellLifetime() {\n        return 20; // in ticks (one tick is 100ms)\n    }\n    radiusPortSpawn() {\n        return 20;\n    }\n    proximityBonusPortsNb(totalPorts) {\n        return (0,_Util__WEBPACK_IMPORTED_MODULE_3__.within)(totalPorts / 3, 4, totalPorts);\n    }\n    attackAmount(attacker, defender) {\n        if (attacker.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n            return attacker.troops() / 20;\n        }\n        else {\n            return attacker.troops() / 5;\n        }\n    }\n    startManpower(playerInfo) {\n        if (playerInfo.playerType === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n            return 10000;\n        }\n        if (playerInfo.playerType === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.FakeHuman) {\n            switch (this._gameConfig.difficulty) {\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Easy:\n                    return 2500 * (playerInfo?.nation?.strength ?? 1);\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Medium:\n                    return 5000 * (playerInfo?.nation?.strength ?? 1);\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Hard:\n                    return 20000 * (playerInfo?.nation?.strength ?? 1);\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Impossible:\n                    return 50000 * (playerInfo?.nation?.strength ?? 1);\n            }\n        }\n        return this.infiniteTroops() ? 1000000 : 25000;\n    }\n    maxTroops(player) {\n        const maxTroops = player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Human && this.infiniteTroops()\n            ? 1000000000\n            : 2 * (Math.pow(player.numTilesOwned(), 0.6) * 1000 + 50000) +\n                player\n                    .units(_game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.City)\n                    .map((city) => city.level())\n                    .reduce((a, b) => a + b, 0) *\n                    this.cityTroopIncrease();\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n            return maxTroops / 3;\n        }\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Human) {\n            return maxTroops;\n        }\n        switch (this._gameConfig.difficulty) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Easy:\n                return maxTroops * 0.5;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Medium:\n                return maxTroops * 1;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Hard:\n                return maxTroops * 1.5;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Impossible:\n                return maxTroops * 2;\n        }\n    }\n    troopIncreaseRate(player) {\n        const max = this.maxTroops(player);\n        let toAdd = 10 + Math.pow(player.troops(), 0.73) / 4;\n        const ratio = 1 - player.troops() / max;\n        toAdd *= ratio;\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n            toAdd *= 0.6;\n        }\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.FakeHuman) {\n            switch (this._gameConfig.difficulty) {\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Easy:\n                    toAdd *= 0.9;\n                    break;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Medium:\n                    toAdd *= 1;\n                    break;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Hard:\n                    toAdd *= 1.1;\n                    break;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_2__.Difficulty.Impossible:\n                    toAdd *= 1.2;\n                    break;\n            }\n        }\n        return Math.min(player.troops() + toAdd, max) - player.troops();\n    }\n    goldAdditionRate(player) {\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n            return 50n;\n        }\n        return 100n;\n    }\n    nukeMagnitudes(unitType) {\n        switch (unitType) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MIRVWarhead:\n                return { inner: 12, outer: 18 };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.AtomBomb:\n                return { inner: 12, outer: 30 };\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.HydrogenBomb:\n                return { inner: 80, outer: 100 };\n        }\n        throw new Error(`Unknown nuke type: ${unitType}`);\n    }\n    nukeAllianceBreakThreshold() {\n        return 100;\n    }\n    defaultNukeSpeed() {\n        return 6;\n    }\n    defaultNukeTargetableRange() {\n        return 150;\n    }\n    defaultSamRange() {\n        return 70;\n    }\n    defaultSamMissileSpeed() {\n        return 12;\n    }\n    // Humans can be soldiers, soldiers attacking, soldiers in boat etc.\n    nukeDeathFactor(nukeType, humans, tilesOwned, maxTroops) {\n        if (nukeType !== _game_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.MIRVWarhead) {\n            return (5 * humans) / Math.max(1, tilesOwned);\n        }\n        const targetTroops = 0.03 * maxTroops;\n        const excessTroops = Math.max(0, humans - targetTroops);\n        const scalingFactor = 500;\n        const steepness = 2;\n        const normalizedExcess = excessTroops / maxTroops;\n        return scalingFactor * (1 - Math.exp(-steepness * normalizedExcess));\n    }\n    structureMinDist() {\n        return 15;\n    }\n    shellLifetime() {\n        return 50;\n    }\n    warshipPatrolRange() {\n        return 100;\n    }\n    warshipTargettingRange() {\n        return 130;\n    }\n    warshipShellAttackRate() {\n        return 20;\n    }\n    defensePostShellAttackRate() {\n        return 100;\n    }\n    safeFromPiratesCooldownMax() {\n        return 20;\n    }\n    defensePostTargettingRange() {\n        return 75;\n    }\n    allianceExtensionPromptOffset() {\n        return 300; // 30 seconds before expiration\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/DefaultConfig.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/DevConfig.ts":
/*!*********************************************!*\
  !*** ./src/core/configuration/DevConfig.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DevConfig: () => (/* binding */ DevConfig),\n/* harmony export */   DevServerConfig: () => (/* binding */ DevServerConfig)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/core/configuration/Config.ts\");\n/* harmony import */ var _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultConfig */ \"./src/core/configuration/DefaultConfig.ts\");\n\n\nclass DevServerConfig extends _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__.DefaultServerConfig {\n    adminToken() {\n        return \"WARNING_DEV_ADMIN_KEY_DO_NOT_USE_IN_PRODUCTION\";\n    }\n    apiKey() {\n        return \"WARNING_DEV_API_KEY_DO_NOT_USE_IN_PRODUCTION\";\n    }\n    env() {\n        return _Config__WEBPACK_IMPORTED_MODULE_0__.GameEnv.Dev;\n    }\n    gameCreationRate() {\n        return 5 * 1000;\n    }\n    samWarheadHittingChance() {\n        return 1;\n    }\n    samHittingChance() {\n        return 1;\n    }\n    numWorkers() {\n        return 2;\n    }\n    jwtAudience() {\n        return \"localhost\";\n    }\n    gitCommit() {\n        return \"DEV\";\n    }\n    domain() {\n        return \"localhost\";\n    }\n    subdomain() {\n        return \"\";\n    }\n}\nclass DevConfig extends _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__.DefaultConfig {\n    constructor(sc, gc, us, isReplay) {\n        super(sc, gc, us, isReplay);\n    }\n    unitInfo(type) {\n        const info = super.unitInfo(type);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const oldCost = info.cost;\n        // info.cost = (p: Player) => oldCost(p) / 1000000000;\n        return info;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/DevConfig.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/PastelTheme.ts":
/*!***********************************************!*\
  !*** ./src/core/configuration/PastelTheme.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PastelTheme: () => (/* binding */ PastelTheme)\n/* harmony export */ });\n/* harmony import */ var colord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colord */ \"./node_modules/colord/index.mjs\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _ColorAllocator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ColorAllocator */ \"./src/core/configuration/ColorAllocator.ts\");\n/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Colors */ \"./src/core/configuration/Colors.ts\");\n\n\n\n\n\nclass PastelTheme {\n    constructor() {\n        this.borderColorCache = new Map();\n        this.rand = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__.PseudoRandom(123);\n        this.humanColorAllocator = new _ColorAllocator__WEBPACK_IMPORTED_MODULE_3__.ColorAllocator(_Colors__WEBPACK_IMPORTED_MODULE_4__.humanColors, _Colors__WEBPACK_IMPORTED_MODULE_4__.fallbackColors);\n        this.botColorAllocator = new _ColorAllocator__WEBPACK_IMPORTED_MODULE_3__.ColorAllocator(_Colors__WEBPACK_IMPORTED_MODULE_4__.botColors, _Colors__WEBPACK_IMPORTED_MODULE_4__.botColors);\n        this.teamColorAllocator = new _ColorAllocator__WEBPACK_IMPORTED_MODULE_3__.ColorAllocator(_Colors__WEBPACK_IMPORTED_MODULE_4__.humanColors, _Colors__WEBPACK_IMPORTED_MODULE_4__.fallbackColors);\n        this.nationColorAllocator = new _ColorAllocator__WEBPACK_IMPORTED_MODULE_3__.ColorAllocator(_Colors__WEBPACK_IMPORTED_MODULE_4__.nationColors, _Colors__WEBPACK_IMPORTED_MODULE_4__.nationColors);\n        this.background = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 60, g: 60, b: 60 });\n        this.shore = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 204, g: 203, b: 158 });\n        this.falloutColors = [\n            (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 120, g: 255, b: 71 }), // Original color\n            (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 130, g: 255, b: 85 }), // Slightly lighter\n            (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 110, g: 245, b: 65 }), // Slightly darker\n            (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 125, g: 255, b: 75 }), // Warmer tint\n            (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 115, g: 250, b: 68 }), // Cooler tint\n        ];\n        this.water = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 70, g: 132, b: 180 });\n        this.shorelineWater = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 100, g: 143, b: 255 });\n        this._selfColor = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 0, g: 255, b: 0 });\n        this._allyColor = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 255, b: 0 });\n        this._neutralColor = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 128, g: 128, b: 128 });\n        this._enemyColor = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 0, b: 0 });\n        this._spawnHighlightColor = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 255, g: 213, b: 79 });\n    }\n    teamColor(team) {\n        return this.teamColorAllocator.assignTeamColor(team);\n    }\n    territoryColor(player) {\n        const team = player.team();\n        if (team !== null) {\n            return this.teamColorAllocator.assignTeamPlayerColor(team, player.id());\n        }\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Human) {\n            return this.humanColorAllocator.assignColor(player.id());\n        }\n        if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Bot) {\n            return this.botColorAllocator.assignColor(player.id());\n        }\n        return this.nationColorAllocator.assignColor(player.id());\n    }\n    // Don't call directly, use PlayerView\n    borderColor(territoryColor) {\n        return territoryColor.darken(0.125);\n    }\n    defendedBorderColors(territoryColor) {\n        return {\n            light: territoryColor.darken(0.2),\n            dark: territoryColor.darken(0.4),\n        };\n    }\n    focusedBorderColor() {\n        return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 230, g: 230, b: 230 });\n    }\n    textColor(player) {\n        return player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.Human ? \"#000000\" : \"#4D4D4D\";\n    }\n    terrainColor(gm, tile) {\n        const mag = gm.magnitude(tile);\n        if (gm.isShore(tile)) {\n            return this.shore;\n        }\n        switch (gm.terrainType(tile)) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Ocean:\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Lake: {\n                const w = this.water.rgba;\n                if (gm.isShoreline(tile) && gm.isWater(tile)) {\n                    return this.shorelineWater;\n                }\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: Math.max(w.r - 10 + (11 - Math.min(mag, 10)), 0),\n                    g: Math.max(w.g - 10 + (11 - Math.min(mag, 10)), 0),\n                    b: Math.max(w.b - 10 + (11 - Math.min(mag, 10)), 0),\n                });\n            }\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Plains:\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: 190,\n                    g: 220 - 2 * mag,\n                    b: 138,\n                });\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Highland:\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: 200 + 2 * mag,\n                    g: 183 + 2 * mag,\n                    b: 138 + 2 * mag,\n                });\n            case _game_Game__WEBPACK_IMPORTED_MODULE_2__.TerrainType.Mountain:\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: 230 + mag / 2,\n                    g: 230 + mag / 2,\n                    b: 230 + mag / 2,\n                });\n        }\n    }\n    backgroundColor() {\n        return this.background;\n    }\n    falloutColor() {\n        return this.rand.randElement(this.falloutColors);\n    }\n    font() {\n        return \"Overpass, sans-serif\";\n    }\n    selfColor() {\n        return this._selfColor;\n    }\n    allyColor() {\n        return this._allyColor;\n    }\n    neutralColor() {\n        return this._neutralColor;\n    }\n    enemyColor() {\n        return this._enemyColor;\n    }\n    spawnHighlightColor() {\n        return this._spawnHighlightColor;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/PastelTheme.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/PastelThemeDark.ts":
/*!***************************************************!*\
  !*** ./src/core/configuration/PastelThemeDark.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PastelThemeDark: () => (/* binding */ PastelThemeDark)\n/* harmony export */ });\n/* harmony import */ var colord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! colord */ \"./node_modules/colord/index.mjs\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _PastelTheme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PastelTheme */ \"./src/core/configuration/PastelTheme.ts\");\n\n\n\nclass PastelThemeDark extends _PastelTheme__WEBPACK_IMPORTED_MODULE_2__.PastelTheme {\n    constructor() {\n        super(...arguments);\n        this.darkShore = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 134, g: 133, b: 88 });\n        this.darkWater = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 14, g: 11, b: 30 });\n        this.darkShorelineWater = (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({ r: 50, g: 50, b: 50 });\n    }\n    terrainColor(gm, tile) {\n        const mag = gm.magnitude(tile);\n        if (gm.isShore(tile)) {\n            return this.darkShore;\n        }\n        switch (gm.terrainType(tile)) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Ocean:\n            case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Lake: {\n                const w = this.darkWater.rgba;\n                if (gm.isShoreline(tile) && gm.isWater(tile)) {\n                    return this.darkShorelineWater;\n                }\n                if (gm.magnitude(tile) < 10) {\n                    return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                        r: Math.max(w.r + 9 - mag, 0),\n                        g: Math.max(w.g + 9 - mag, 0),\n                        b: Math.max(w.b + 9 - mag, 0),\n                    });\n                }\n                return this.darkWater;\n            }\n            case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Plains:\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: 140,\n                    g: 170 - 2 * mag,\n                    b: 88,\n                });\n            case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Highland:\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: 150 + 2 * mag,\n                    g: 133 + 2 * mag,\n                    b: 88 + 2 * mag,\n                });\n            case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Mountain:\n                return (0,colord__WEBPACK_IMPORTED_MODULE_0__.colord)({\n                    r: 180 + mag / 2,\n                    g: 180 + mag / 2,\n                    b: 180 + mag / 2,\n                });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/PastelThemeDark.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/PreprodConfig.ts":
/*!*************************************************!*\
  !*** ./src/core/configuration/PreprodConfig.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   preprodConfig: () => (/* binding */ preprodConfig)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/core/configuration/Config.ts\");\n/* harmony import */ var _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultConfig */ \"./src/core/configuration/DefaultConfig.ts\");\n\n\nconst preprodConfig = new (class extends _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__.DefaultServerConfig {\n    env() {\n        return _Config__WEBPACK_IMPORTED_MODULE_0__.GameEnv.Preprod;\n    }\n    numWorkers() {\n        return 2;\n    }\n    jwtAudience() {\n        return \"openfront.dev\";\n    }\n    allowedFlares() {\n        return undefined;\n        // TODO: Uncomment this after testing.\n        // Allow access without login for now to test\n        // the new login flow.\n        // return [\n        //   // \"access:openfront.dev\"\n        // ];\n    }\n})();\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/PreprodConfig.ts?\n}");

/***/ }),

/***/ "./src/core/configuration/ProdConfig.ts":
/*!**********************************************!*\
  !*** ./src/core/configuration/ProdConfig.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prodConfig: () => (/* binding */ prodConfig)\n/* harmony export */ });\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config */ \"./src/core/configuration/Config.ts\");\n/* harmony import */ var _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultConfig */ \"./src/core/configuration/DefaultConfig.ts\");\n\n\nconst prodConfig = new (class extends _DefaultConfig__WEBPACK_IMPORTED_MODULE_1__.DefaultServerConfig {\n    numWorkers() {\n        return 20;\n    }\n    env() {\n        return _Config__WEBPACK_IMPORTED_MODULE_0__.GameEnv.Prod;\n    }\n    jwtAudience() {\n        return \"openfront.io\";\n    }\n})();\n\n\n//# sourceURL=webpack://openfront-client/./src/core/configuration/ProdConfig.ts?\n}");

/***/ }),

/***/ "./src/core/execution/AttackExecution.ts":
/*!***********************************************!*\
  !*** ./src/core/execution/AttackExecution.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttackExecution: () => (/* binding */ AttackExecution)\n/* harmony export */ });\n/* harmony import */ var _client_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../client/Utils */ \"./src/client/Utils.ts\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _utils_FlatBinaryHeap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/FlatBinaryHeap */ \"./src/core/execution/utils/FlatBinaryHeap.ts\");\n\n\n\n // adjust path if needed\nconst malusForRetreat = 25;\nclass AttackExecution {\n    constructor(startTroops = null, _owner, _targetID, sourceTile = null, removeTroops = true) {\n        this.startTroops = startTroops;\n        this._owner = _owner;\n        this._targetID = _targetID;\n        this.sourceTile = sourceTile;\n        this.removeTroops = removeTroops;\n        this.active = true;\n        this.toConquer = new _utils_FlatBinaryHeap__WEBPACK_IMPORTED_MODULE_3__.FlatBinaryHeap();\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(123);\n        this.attack = null;\n    }\n    targetID() {\n        return this._targetID;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    init(mg, ticks) {\n        if (!this.active) {\n            return;\n        }\n        this.mg = mg;\n        if (this._targetID !== null && !mg.hasPlayer(this._targetID)) {\n            console.warn(`target ${this._targetID} not found`);\n            this.active = false;\n            return;\n        }\n        this.target =\n            this._targetID === this.mg.terraNullius().id()\n                ? mg.terraNullius()\n                : mg.player(this._targetID);\n        if (this._owner === this.target) {\n            console.error(`Player ${this._owner} cannot attack itself`);\n            this.active = false;\n            return;\n        }\n        // ALLIANCE CHECK â€” block attacks on friendly (ally or same team)\n        if (this.target.isPlayer()) {\n            const targetPlayer = this.target;\n            if (this._owner.isFriendly(targetPlayer)) {\n                console.warn(`${this._owner.displayName()} cannot attack ${targetPlayer.displayName()} because they are friendly (allied or same team)`);\n                this.active = false;\n                return;\n            }\n        }\n        if (this.target && this.target.isPlayer()) {\n            const targetPlayer = this.target;\n            if (targetPlayer.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_1__.PlayerType.Bot &&\n                this._owner.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_1__.PlayerType.Bot) {\n                // Don't let bots embargo since they can't trade anyway.\n                targetPlayer.addEmbargo(this._owner, true);\n                this.rejectIncomingAllianceRequests(targetPlayer);\n            }\n        }\n        if (this.target.isPlayer()) {\n            if (this.mg.config().numSpawnPhaseTurns() +\n                this.mg.config().spawnImmunityDuration() >\n                this.mg.ticks()) {\n                console.warn(\"cannot attack player during immunity phase\");\n                this.active = false;\n                return;\n            }\n        }\n        this.startTroops ?? (this.startTroops = this.mg\n            .config()\n            .attackAmount(this._owner, this.target));\n        if (this.removeTroops) {\n            this.startTroops = Math.min(this._owner.troops(), this.startTroops);\n            this._owner.removeTroops(this.startTroops);\n        }\n        this.attack = this._owner.createAttack(this.target, this.startTroops, this.sourceTile, new Set());\n        if (this.sourceTile !== null) {\n            this.addNeighbors(this.sourceTile);\n        }\n        else {\n            this.refreshToConquer();\n        }\n        // Record stats\n        this.mg.stats().attack(this._owner, this.target, this.startTroops);\n        for (const incoming of this._owner.incomingAttacks()) {\n            if (incoming.attacker() === this.target) {\n                // Target has opposing attack, cancel them out\n                if (incoming.troops() > this.attack.troops()) {\n                    incoming.setTroops(incoming.troops() - this.attack.troops());\n                    this.attack.delete();\n                    this.active = false;\n                    return;\n                }\n                else {\n                    this.attack.setTroops(this.attack.troops() - incoming.troops());\n                    incoming.delete();\n                }\n            }\n        }\n        for (const outgoing of this._owner.outgoingAttacks()) {\n            if (outgoing !== this.attack &&\n                outgoing.target() === this.attack.target() &&\n                // Boat attacks (sourceTile is not null) are not combined with other attacks\n                this.attack.sourceTile() === null) {\n                this.attack.setTroops(this.attack.troops() + outgoing.troops());\n                outgoing.delete();\n            }\n        }\n        if (this.target.isPlayer()) {\n            this.target.updateRelation(this._owner, -80);\n        }\n    }\n    refreshToConquer() {\n        if (this.attack === null) {\n            throw new Error(\"Attack not initialized\");\n        }\n        this.toConquer.clear();\n        this.attack.clearBorder();\n        for (const tile of this._owner.borderTiles()) {\n            this.addNeighbors(tile);\n        }\n    }\n    retreat(malusPercent = 0) {\n        if (this.attack === null) {\n            throw new Error(\"Attack not initialized\");\n        }\n        const deaths = this.attack.troops() * (malusPercent / 100);\n        if (deaths) {\n            this.mg.displayMessage(`Attack cancelled, ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderTroops)(deaths)} soldiers killed during retreat.`, _game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.ATTACK_CANCELLED, this._owner.id());\n        }\n        const survivors = this.attack.troops() - deaths;\n        this._owner.addTroops(survivors);\n        this.attack.delete();\n        this.active = false;\n        // Not all retreats are canceled attacks\n        if (this.attack.retreated()) {\n            // Record stats\n            this.mg.stats().attackCancel(this._owner, this.target, survivors);\n        }\n    }\n    tick(ticks) {\n        if (this.attack === null) {\n            throw new Error(\"Attack not initialized\");\n        }\n        let troopCount = this.attack.troops(); // cache troop count\n        const targetIsPlayer = this.target.isPlayer(); // cache target type\n        const targetPlayer = targetIsPlayer ? this.target : null; // cache target player\n        if (this.attack.retreated()) {\n            if (targetIsPlayer) {\n                this.retreat(malusForRetreat);\n            }\n            else {\n                this.retreat();\n            }\n            this.active = false;\n            return;\n        }\n        if (this.attack.retreating()) {\n            return;\n        }\n        if (!this.attack.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (targetPlayer && this._owner.isFriendly(targetPlayer)) {\n            // In this case a new alliance was created AFTER the attack started.\n            this.retreat();\n            return;\n        }\n        let numTilesPerTick = this.mg\n            .config()\n            .attackTilesPerTick(troopCount, this._owner, this.target, this.attack.borderSize() + this.random.nextInt(0, 5));\n        while (numTilesPerTick > 0) {\n            if (troopCount < 1) {\n                this.attack.delete();\n                this.active = false;\n                return;\n            }\n            if (this.toConquer.size() === 0) {\n                this.refreshToConquer();\n                this.retreat();\n                return;\n            }\n            const [tileToConquer] = this.toConquer.dequeue();\n            this.attack.removeBorderTile(tileToConquer);\n            let onBorder = false;\n            for (const n of this.mg.neighbors(tileToConquer)) {\n                if (this.mg.owner(n) === this._owner) {\n                    onBorder = true;\n                    break;\n                }\n            }\n            if (this.mg.owner(tileToConquer) !== this.target || !onBorder) {\n                continue;\n            }\n            this.addNeighbors(tileToConquer);\n            const { attackerTroopLoss, defenderTroopLoss, tilesPerTickUsed } = this.mg\n                .config()\n                .attackLogic(this.mg, troopCount, this._owner, this.target, tileToConquer);\n            numTilesPerTick -= tilesPerTickUsed;\n            troopCount -= attackerTroopLoss;\n            this.attack.setTroops(troopCount);\n            if (targetPlayer) {\n                targetPlayer.removeTroops(defenderTroopLoss);\n            }\n            this._owner.conquer(tileToConquer);\n            this.handleDeadDefender();\n        }\n    }\n    rejectIncomingAllianceRequests(target) {\n        const request = this._owner\n            .incomingAllianceRequests()\n            .find((ar) => ar.requestor() === target);\n        if (request !== undefined) {\n            request.reject();\n        }\n    }\n    addNeighbors(tile) {\n        if (this.attack === null) {\n            throw new Error(\"Attack not initialized\");\n        }\n        const tickNow = this.mg.ticks(); // cache tick\n        for (const neighbor of this.mg.neighbors(tile)) {\n            if (this.mg.isWater(neighbor) ||\n                this.mg.owner(neighbor) !== this.target) {\n                continue;\n            }\n            this.attack.addBorderTile(neighbor);\n            let numOwnedByMe = 0;\n            for (const n of this.mg.neighbors(neighbor)) {\n                if (this.mg.owner(n) === this._owner) {\n                    numOwnedByMe++;\n                }\n            }\n            let mag = 0;\n            switch (this.mg.terrainType(neighbor)) {\n                case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Plains:\n                    mag = 1;\n                    break;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Highland:\n                    mag = 1.5;\n                    break;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_1__.TerrainType.Mountain:\n                    mag = 2;\n                    break;\n            }\n            const priority = (this.random.nextInt(0, 7) + 10) * (1 - numOwnedByMe * 0.5 + mag / 2) +\n                tickNow;\n            this.toConquer.enqueue(neighbor, priority);\n        }\n    }\n    handleDeadDefender() {\n        if (!(this.target.isPlayer() && this.target.numTilesOwned() < 100))\n            return;\n        this.mg.conquerPlayer(this._owner, this.target);\n        for (let i = 0; i < 10; i++) {\n            for (const tile of this.target.tiles()) {\n                const borders = this.mg\n                    .neighbors(tile)\n                    .some((t) => this.mg.owner(t) === this._owner);\n                if (borders) {\n                    this._owner.conquer(tile);\n                }\n                else {\n                    for (const neighbor of this.mg.neighbors(tile)) {\n                        const no = this.mg.owner(neighbor);\n                        if (no.isPlayer() && no !== this.target) {\n                            this.mg.player(no.id()).conquer(tile);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    owner() {\n        return this._owner;\n    }\n    isActive() {\n        return this.active;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/AttackExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/BoatRetreatExecution.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/BoatRetreatExecution.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoatRetreatExecution: () => (/* binding */ BoatRetreatExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n\nclass BoatRetreatExecution {\n    constructor(player, unitID) {\n        this.player = player;\n        this.unitID = unitID;\n        this.active = true;\n    }\n    init(mg, ticks) { }\n    tick(ticks) {\n        const unit = this.player\n            .units()\n            .find((unit) => unit.id() === this.unitID && unit.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip);\n        if (!unit) {\n            console.warn(`Didn't find outgoing boat with id ${this.unitID}`);\n            this.active = false;\n            return;\n        }\n        unit.orderBoatRetreat();\n        this.active = false;\n    }\n    owner() {\n        return this.player;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/BoatRetreatExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/BotExecution.ts":
/*!********************************************!*\
  !*** ./src/core/execution/BotExecution.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BotExecution: () => (/* binding */ BotExecution)\n/* harmony export */ });\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _utils_BotBehavior__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/BotBehavior */ \"./src/core/execution/utils/BotBehavior.ts\");\n\n\n\nclass BotExecution {\n    constructor(bot) {\n        this.bot = bot;\n        this.active = true;\n        this.neighborsTerraNullius = true;\n        this.behavior = null;\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(bot.id()));\n        this.attackRate = this.random.nextInt(40, 80);\n        this.attackTick = this.random.nextInt(0, this.attackRate);\n        this.triggerRatio = this.random.nextInt(50, 60) / 100;\n        this.reserveRatio = this.random.nextInt(30, 40) / 100;\n        this.expandRatio = this.random.nextInt(10, 20) / 100;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    init(mg) {\n        this.mg = mg;\n    }\n    tick(ticks) {\n        if (ticks % this.attackRate !== this.attackTick)\n            return;\n        if (!this.bot.isAlive()) {\n            this.active = false;\n            return;\n        }\n        if (this.behavior === null) {\n            this.behavior = new _utils_BotBehavior__WEBPACK_IMPORTED_MODULE_2__.BotBehavior(this.random, this.mg, this.bot, this.triggerRatio, this.reserveRatio, this.expandRatio);\n            // Send an attack on the first tick\n            this.behavior.sendAttack(this.mg.terraNullius());\n            return;\n        }\n        this.behavior.handleAllianceRequests();\n        this.behavior.handleAllianceExtensionRequests();\n        this.maybeAttack();\n    }\n    maybeAttack() {\n        if (this.behavior === null) {\n            throw new Error(\"not initialized\");\n        }\n        const toAttack = this.behavior.getNeighborTraitorToAttack();\n        if (toAttack !== null) {\n            const odds = this.bot.isFriendly(toAttack) ? 6 : 3;\n            if (this.random.chance(odds)) {\n                // Check and break alliance before attacking if needed\n                const alliance = this.bot.allianceWith(toAttack);\n                if (alliance !== null) {\n                    this.bot.breakAlliance(alliance);\n                }\n                this.behavior.sendAttack(toAttack);\n                return;\n            }\n        }\n        if (this.neighborsTerraNullius) {\n            if (this.bot.sharesBorderWith(this.mg.terraNullius())) {\n                this.behavior.sendAttack(this.mg.terraNullius());\n                return;\n            }\n            this.neighborsTerraNullius = false;\n        }\n        this.behavior.forgetOldEnemies();\n        const enemy = this.behavior.selectRandomEnemy();\n        if (!enemy)\n            return;\n        if (!this.bot.sharesBorderWith(enemy))\n            return;\n        this.behavior.sendAttack(enemy);\n    }\n    isActive() {\n        return this.active;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/BotExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/BotSpawner.ts":
/*!******************************************!*\
  !*** ./src/core/execution/BotSpawner.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BotSpawner: () => (/* binding */ BotSpawner)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _SpawnExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SpawnExecution */ \"./src/core/execution/SpawnExecution.ts\");\n/* harmony import */ var _utils_BotNames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/BotNames */ \"./src/core/execution/utils/BotNames.ts\");\n\n\n\n\n\nclass BotSpawner {\n    constructor(gs, gameID) {\n        this.gs = gs;\n        this.bots = [];\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_2__.simpleHash)(gameID));\n    }\n    spawnBots(numBots) {\n        let tries = 0;\n        while (this.bots.length < numBots) {\n            if (tries > 10000) {\n                console.log(\"too many retries while spawning bots, giving up\");\n                return this.bots;\n            }\n            const botName = this.randomBotName();\n            const spawn = this.spawnBot(botName);\n            if (spawn !== null) {\n                this.bots.push(spawn);\n            }\n            else {\n                tries++;\n            }\n        }\n        return this.bots;\n    }\n    spawnBot(botName) {\n        const tile = this.randTile();\n        if (!this.gs.isLand(tile)) {\n            return null;\n        }\n        for (const spawn of this.bots) {\n            if (this.gs.manhattanDist(spawn.tile, tile) < 30) {\n                return null;\n            }\n        }\n        return new _SpawnExecution__WEBPACK_IMPORTED_MODULE_3__.SpawnExecution(new _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerInfo(botName, _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Bot, null, this.random.nextID()), tile);\n    }\n    randomBotName() {\n        const prefixIndex = this.random.nextInt(0, _utils_BotNames__WEBPACK_IMPORTED_MODULE_4__.BOT_NAME_PREFIXES.length);\n        const suffixIndex = this.random.nextInt(0, _utils_BotNames__WEBPACK_IMPORTED_MODULE_4__.BOT_NAME_SUFFIXES.length);\n        return `${_utils_BotNames__WEBPACK_IMPORTED_MODULE_4__.BOT_NAME_PREFIXES[prefixIndex]} ${_utils_BotNames__WEBPACK_IMPORTED_MODULE_4__.BOT_NAME_SUFFIXES[suffixIndex]}`;\n    }\n    randTile() {\n        return this.gs.ref(this.random.nextInt(0, this.gs.width()), this.random.nextInt(0, this.gs.height()));\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/BotSpawner.ts?\n}");

/***/ }),

/***/ "./src/core/execution/CityExecution.ts":
/*!*********************************************!*\
  !*** ./src/core/execution/CityExecution.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CityExecution: () => (/* binding */ CityExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _TrainStationExecution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TrainStationExecution */ \"./src/core/execution/TrainStationExecution.ts\");\n\n\nclass CityExecution {\n    constructor(player, tile) {\n        this.player = player;\n        this.tile = tile;\n        this.city = null;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n    }\n    tick(ticks) {\n        if (this.city === null) {\n            const spawnTile = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City, this.tile);\n            if (spawnTile === false) {\n                console.warn(\"cannot build city\");\n                this.active = false;\n                return;\n            }\n            this.city = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City, spawnTile, {});\n            this.createStation();\n        }\n        if (!this.city.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (this.player !== this.city.owner()) {\n            this.player = this.city.owner();\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    createStation() {\n        if (this.city !== null) {\n            const nearbyFactory = this.mg.hasUnitNearby(this.city.tile(), this.mg.config().trainStationMaxRange(), _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory);\n            if (nearbyFactory) {\n                this.mg.addExecution(new _TrainStationExecution__WEBPACK_IMPORTED_MODULE_1__.TrainStationExecution(this.city));\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/CityExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/ConstructionExecution.ts":
/*!*****************************************************!*\
  !*** ./src/core/execution/ConstructionExecution.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConstructionExecution: () => (/* binding */ ConstructionExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _CityExecution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CityExecution */ \"./src/core/execution/CityExecution.ts\");\n/* harmony import */ var _DefensePostExecution__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefensePostExecution */ \"./src/core/execution/DefensePostExecution.ts\");\n/* harmony import */ var _FactoryExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FactoryExecution */ \"./src/core/execution/FactoryExecution.ts\");\n/* harmony import */ var _MIRVExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MIRVExecution */ \"./src/core/execution/MIRVExecution.ts\");\n/* harmony import */ var _MissileSiloExecution__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./MissileSiloExecution */ \"./src/core/execution/MissileSiloExecution.ts\");\n/* harmony import */ var _NukeExecution__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NukeExecution */ \"./src/core/execution/NukeExecution.ts\");\n/* harmony import */ var _PortExecution__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PortExecution */ \"./src/core/execution/PortExecution.ts\");\n/* harmony import */ var _SAMLauncherExecution__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SAMLauncherExecution */ \"./src/core/execution/SAMLauncherExecution.ts\");\n/* harmony import */ var _WarshipExecution__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./WarshipExecution */ \"./src/core/execution/WarshipExecution.ts\");\n\n\n\n\n\n\n\n\n\n\nclass ConstructionExecution {\n    constructor(player, constructionType, tile) {\n        this.player = player;\n        this.constructionType = constructionType;\n        this.tile = tile;\n        this.construction = null;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        if (this.mg.config().isUnitDisabled(this.constructionType)) {\n            console.warn(`cannot build construction ${this.constructionType} because it is disabled`);\n            this.active = false;\n            return;\n        }\n        if (!this.mg.isValidRef(this.tile)) {\n            console.warn(`cannot build construction invalid tile ${this.tile}`);\n            this.active = false;\n            return;\n        }\n    }\n    tick(ticks) {\n        if (this.construction === null) {\n            const info = this.mg.unitInfo(this.constructionType);\n            if (info.constructionDuration === undefined) {\n                this.completeConstruction();\n                this.active = false;\n                return;\n            }\n            const spawnTile = this.player.canBuild(this.constructionType, this.tile);\n            if (spawnTile === false) {\n                console.warn(`cannot build ${this.constructionType}`);\n                this.active = false;\n                return;\n            }\n            this.construction = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Construction, spawnTile, {});\n            this.cost = this.mg.unitInfo(this.constructionType).cost(this.player);\n            this.player.removeGold(this.cost);\n            this.construction.setConstructionType(this.constructionType);\n            this.ticksUntilComplete = info.constructionDuration;\n            return;\n        }\n        if (!this.construction.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (this.player !== this.construction.owner()) {\n            this.player = this.construction.owner();\n        }\n        if (this.ticksUntilComplete === 0) {\n            this.player = this.construction.owner();\n            this.construction.delete(false);\n            // refund the cost so player has the gold to build the unit\n            this.player.addGold(this.cost);\n            this.completeConstruction();\n            this.active = false;\n            return;\n        }\n        this.ticksUntilComplete--;\n    }\n    completeConstruction() {\n        const player = this.player;\n        switch (this.constructionType) {\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb:\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb:\n                this.mg.addExecution(new _NukeExecution__WEBPACK_IMPORTED_MODULE_6__.NukeExecution(this.constructionType, player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV:\n                this.mg.addExecution(new _MIRVExecution__WEBPACK_IMPORTED_MODULE_4__.MirvExecution(player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship:\n                this.mg.addExecution(new _WarshipExecution__WEBPACK_IMPORTED_MODULE_9__.WarshipExecution({ owner: player, patrolTile: this.tile }));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port:\n                this.mg.addExecution(new _PortExecution__WEBPACK_IMPORTED_MODULE_7__.PortExecution(player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo:\n                this.mg.addExecution(new _MissileSiloExecution__WEBPACK_IMPORTED_MODULE_5__.MissileSiloExecution(player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost:\n                this.mg.addExecution(new _DefensePostExecution__WEBPACK_IMPORTED_MODULE_2__.DefensePostExecution(player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher:\n                this.mg.addExecution(new _SAMLauncherExecution__WEBPACK_IMPORTED_MODULE_8__.SAMLauncherExecution(player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City:\n                this.mg.addExecution(new _CityExecution__WEBPACK_IMPORTED_MODULE_1__.CityExecution(player, this.tile));\n                break;\n            case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory:\n                this.mg.addExecution(new _FactoryExecution__WEBPACK_IMPORTED_MODULE_3__.FactoryExecution(player, this.tile));\n                break;\n            default:\n                console.warn(`unit type ${this.constructionType} cannot be constructed`);\n                break;\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/ConstructionExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/DefensePostExecution.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/DefensePostExecution.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefensePostExecution: () => (/* binding */ DefensePostExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _ShellExecution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShellExecution */ \"./src/core/execution/ShellExecution.ts\");\n\n\nclass DefensePostExecution {\n    constructor(player, tile) {\n        this.player = player;\n        this.tile = tile;\n        this.post = null;\n        this.active = true;\n        this.target = null;\n        this.lastShellAttack = 0;\n        this.alreadySentShell = new Set();\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n    }\n    shoot() {\n        if (this.post === null)\n            return;\n        if (this.target === null)\n            return;\n        const shellAttackRate = this.mg.config().defensePostShellAttackRate();\n        if (this.mg.ticks() - this.lastShellAttack > shellAttackRate) {\n            this.lastShellAttack = this.mg.ticks();\n            this.mg.addExecution(new _ShellExecution__WEBPACK_IMPORTED_MODULE_1__.ShellExecution(this.post.tile(), this.post.owner(), this.post, this.target));\n            if (!this.target.hasHealth()) {\n                // Don't send multiple shells to target that can be oneshotted\n                this.alreadySentShell.add(this.target);\n                this.target = null;\n                return;\n            }\n        }\n    }\n    tick(ticks) {\n        if (this.post === null) {\n            const spawnTile = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost, this.tile);\n            if (spawnTile === false) {\n                console.warn(\"cannot build Defense Post\");\n                this.active = false;\n                return;\n            }\n            this.post = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost, spawnTile, {});\n        }\n        if (!this.post.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (this.player !== this.post.owner()) {\n            this.player = this.post.owner();\n        }\n        if (this.target !== null && !this.target.isActive()) {\n            this.target = null;\n        }\n        // TODO: Reconsider how/if defense posts target ships.\n        // const ships = this.mg\n        //   .nearbyUnits(\n        //     this.post.tile(),\n        //     this.mg.config().defensePostTargettingRange(),\n        //     [UnitType.TransportShip, UnitType.Warship],\n        //   )\n        //   .filter(\n        //     ({ unit }) =>\n        //       this.post !== null &&\n        //       unit.owner() !== this.post.owner() &&\n        //       !unit.owner().isFriendly(this.post.owner()) &&\n        //       !this.alreadySentShell.has(unit),\n        //   );\n        //\n        // this.target =\n        //   ships.sort((a, b) => {\n        //     const { unit: unitA, distSquared: distA } = a;\n        //     const { unit: unitB, distSquared: distB } = b;\n        //\n        //     // Prioritize TransportShip\n        //     if (\n        //       unitA.type() === UnitType.TransportShip &&\n        //       unitB.type() !== UnitType.TransportShip\n        //     )\n        //       return -1;\n        //     if (\n        //       unitA.type() !== UnitType.TransportShip &&\n        //       unitB.type() === UnitType.TransportShip\n        //     )\n        //       return 1;\n        //\n        //     // If both are the same type, sort by distance (lower `distSquared` means closer)\n        //     return distA - distB;\n        //   })[0]?.unit ?? null;\n        //\n        // if (this.target === null || !this.target.isActive()) {\n        //   this.target = null;\n        //   return;\n        // } else {\n        //   this.shoot();\n        //   return;\n        // }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/DefensePostExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/DeleteUnitExecution.ts":
/*!***************************************************!*\
  !*** ./src/core/execution/DeleteUnitExecution.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeleteUnitExecution: () => (/* binding */ DeleteUnitExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n\nclass DeleteUnitExecution {\n    constructor(player, unitId) {\n        this.player = player;\n        this.unitId = unitId;\n        this.active = true;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    init(mg, ticks) {\n        if (!this.active) {\n            return;\n        }\n        this.mg = mg;\n        const unit = this.player.units().find((u) => u.id() === this.unitId);\n        if (!unit) {\n            console.warn(`SECURITY: unit ${this.unitId} not found or not owned by player ${this.player.displayName()}`);\n            this.active = false;\n            return;\n        }\n        if (!unit.isActive()) {\n            console.warn(`SECURITY: unit ${this.unitId} is not active`);\n            this.active = false;\n            return;\n        }\n        const tileOwner = mg.owner(unit.tile());\n        if (!tileOwner.isPlayer() || tileOwner.id() !== this.player.id()) {\n            console.warn(`SECURITY: unit ${this.unitId} is not on player's territory`);\n            this.active = false;\n            return;\n        }\n        if (!mg.isLand(unit.tile())) {\n            console.warn(`SECURITY: unit ${this.unitId} is not on land`);\n            this.active = false;\n            return;\n        }\n        if (mg.inSpawnPhase()) {\n            console.warn(`SECURITY: cannot delete units during spawn phase`);\n            this.active = false;\n            return;\n        }\n        if (!this.player.canDeleteUnit()) {\n            console.warn(`SECURITY: delete unit cooldown not expired`);\n            this.active = false;\n            return;\n        }\n        unit.delete(false);\n        this.player.recordDeleteUnit();\n        this.mg.displayMessage(`events_display.unit_voluntarily_deleted`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.UNIT_DESTROYED, this.player.id());\n        this.active = false;\n    }\n    tick(ticks) { }\n    isActive() {\n        return this.active;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/DeleteUnitExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/DonateGoldExecution.ts":
/*!***************************************************!*\
  !*** ./src/core/execution/DonateGoldExecution.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DonateGoldExecution: () => (/* binding */ DonateGoldExecution)\n/* harmony export */ });\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n\nclass DonateGoldExecution {\n    constructor(sender, recipientID, goldNum) {\n        this.sender = sender;\n        this.recipientID = recipientID;\n        this.active = true;\n        this.gold = (0,_Util__WEBPACK_IMPORTED_MODULE_0__.toInt)(goldNum ?? 0);\n    }\n    init(mg, ticks) {\n        if (!mg.hasPlayer(this.recipientID)) {\n            console.warn(`DonateExecution recipient ${this.recipientID} not found`);\n            this.active = false;\n            return;\n        }\n        this.recipient = mg.player(this.recipientID);\n        this.gold ?? (this.gold = this.sender.gold() / 3n);\n    }\n    tick(ticks) {\n        if (this.gold === null)\n            throw new Error(\"not initialized\");\n        if (this.sender.canDonateGold(this.recipient) &&\n            this.sender.donateGold(this.recipient, this.gold)) {\n            this.recipient.updateRelation(this.sender, 50);\n        }\n        else {\n            console.warn(`cannot send gold from ${this.sender.name()} to ${this.recipient.name()}`);\n        }\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/DonateGoldExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/DonateTroopExecution.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/DonateTroopExecution.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DonateTroopsExecution: () => (/* binding */ DonateTroopsExecution)\n/* harmony export */ });\nclass DonateTroopsExecution {\n    constructor(sender, recipientID, troops) {\n        this.sender = sender;\n        this.recipientID = recipientID;\n        this.troops = troops;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        if (!mg.hasPlayer(this.recipientID)) {\n            console.warn(`DonateExecution recipient ${this.recipientID} not found`);\n            this.active = false;\n            return;\n        }\n        this.recipient = mg.player(this.recipientID);\n        this.troops ?? (this.troops = mg.config().defaultDonationAmount(this.sender));\n        const maxDonation = mg.config().maxTroops(this.recipient) - this.recipient.troops();\n        this.troops = Math.min(this.troops, maxDonation);\n    }\n    tick(ticks) {\n        if (this.troops === null)\n            throw new Error(\"not initialized\");\n        if (this.sender.canDonateTroops(this.recipient) &&\n            this.sender.donateTroops(this.recipient, this.troops)) {\n            this.recipient.updateRelation(this.sender, 50);\n        }\n        else {\n            console.warn(`cannot send troops from ${this.sender} to ${this.recipient}`);\n        }\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/DonateTroopExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/EmbargoExecution.ts":
/*!************************************************!*\
  !*** ./src/core/execution/EmbargoExecution.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmbargoExecution: () => (/* binding */ EmbargoExecution)\n/* harmony export */ });\nclass EmbargoExecution {\n    constructor(player, targetID, action) {\n        this.player = player;\n        this.targetID = targetID;\n        this.action = action;\n        this.active = true;\n    }\n    init(mg, _) {\n        if (!mg.hasPlayer(this.targetID)) {\n            console.warn(`EmbargoExecution recipient ${this.targetID} not found`);\n            this.active = false;\n            return;\n        }\n        this.target = mg.player(this.targetID);\n    }\n    tick(_) {\n        if (this.action === \"start\")\n            this.player.addEmbargo(this.target, false);\n        else\n            this.player.stopEmbargo(this.target);\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/EmbargoExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/EmojiExecution.ts":
/*!**********************************************!*\
  !*** ./src/core/execution/EmojiExecution.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmojiExecution: () => (/* binding */ EmojiExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n\n\nclass EmojiExecution {\n    constructor(requestor, recipientID, emoji) {\n        this.requestor = requestor;\n        this.recipientID = recipientID;\n        this.emoji = emoji;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        if (this.recipientID !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.AllPlayers && !mg.hasPlayer(this.recipientID)) {\n            console.warn(`EmojiExecution: recipient ${this.recipientID} not found`);\n            this.active = false;\n            return;\n        }\n        this.recipient =\n            this.recipientID === _game_Game__WEBPACK_IMPORTED_MODULE_0__.AllPlayers\n                ? _game_Game__WEBPACK_IMPORTED_MODULE_0__.AllPlayers\n                : mg.player(this.recipientID);\n    }\n    tick(ticks) {\n        const emojiString = _Util__WEBPACK_IMPORTED_MODULE_1__.flattenedEmojiTable[this.emoji];\n        if (emojiString === undefined) {\n            console.warn(`cannot send emoji ${this.emoji} from ${this.requestor} to ${this.recipient}`);\n        }\n        else if (this.requestor.canSendEmoji(this.recipient)) {\n            this.requestor.sendEmoji(this.recipient, emojiString);\n            if (emojiString === \"ðŸ–•\" &&\n                this.recipient !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.AllPlayers &&\n                this.recipient.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.FakeHuman) {\n                this.recipient.updateRelation(this.requestor, -100);\n            }\n        }\n        else {\n            console.warn(`cannot send emoji from ${this.requestor} to ${this.recipient}`);\n        }\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/EmojiExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/ExecutionManager.ts":
/*!************************************************!*\
  !*** ./src/core/execution/ExecutionManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Executor: () => (/* binding */ Executor)\n/* harmony export */ });\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _alliance_AllianceExtensionExecution__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./alliance/AllianceExtensionExecution */ \"./src/core/execution/alliance/AllianceExtensionExecution.ts\");\n/* harmony import */ var _alliance_AllianceRequestExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alliance/AllianceRequestExecution */ \"./src/core/execution/alliance/AllianceRequestExecution.ts\");\n/* harmony import */ var _alliance_AllianceRequestReplyExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./alliance/AllianceRequestReplyExecution */ \"./src/core/execution/alliance/AllianceRequestReplyExecution.ts\");\n/* harmony import */ var _alliance_BreakAllianceExecution__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./alliance/BreakAllianceExecution */ \"./src/core/execution/alliance/BreakAllianceExecution.ts\");\n/* harmony import */ var _AttackExecution__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AttackExecution */ \"./src/core/execution/AttackExecution.ts\");\n/* harmony import */ var _BoatRetreatExecution__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./BoatRetreatExecution */ \"./src/core/execution/BoatRetreatExecution.ts\");\n/* harmony import */ var _BotSpawner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BotSpawner */ \"./src/core/execution/BotSpawner.ts\");\n/* harmony import */ var _ConstructionExecution__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ConstructionExecution */ \"./src/core/execution/ConstructionExecution.ts\");\n/* harmony import */ var _DeleteUnitExecution__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DeleteUnitExecution */ \"./src/core/execution/DeleteUnitExecution.ts\");\n/* harmony import */ var _DonateGoldExecution__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./DonateGoldExecution */ \"./src/core/execution/DonateGoldExecution.ts\");\n/* harmony import */ var _DonateTroopExecution__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DonateTroopExecution */ \"./src/core/execution/DonateTroopExecution.ts\");\n/* harmony import */ var _EmbargoExecution__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./EmbargoExecution */ \"./src/core/execution/EmbargoExecution.ts\");\n/* harmony import */ var _EmojiExecution__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./EmojiExecution */ \"./src/core/execution/EmojiExecution.ts\");\n/* harmony import */ var _FakeHumanExecution__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./FakeHumanExecution */ \"./src/core/execution/FakeHumanExecution.ts\");\n/* harmony import */ var _MarkDisconnectedExecution__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./MarkDisconnectedExecution */ \"./src/core/execution/MarkDisconnectedExecution.ts\");\n/* harmony import */ var _MoveWarshipExecution__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./MoveWarshipExecution */ \"./src/core/execution/MoveWarshipExecution.ts\");\n/* harmony import */ var _NoOpExecution__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./NoOpExecution */ \"./src/core/execution/NoOpExecution.ts\");\n/* harmony import */ var _QuickChatExecution__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./QuickChatExecution */ \"./src/core/execution/QuickChatExecution.ts\");\n/* harmony import */ var _RetreatExecution__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./RetreatExecution */ \"./src/core/execution/RetreatExecution.ts\");\n/* harmony import */ var _SpawnExecution__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./SpawnExecution */ \"./src/core/execution/SpawnExecution.ts\");\n/* harmony import */ var _TargetPlayerExecution__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./TargetPlayerExecution */ \"./src/core/execution/TargetPlayerExecution.ts\");\n/* harmony import */ var _TransportShipExecution__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./TransportShipExecution */ \"./src/core/execution/TransportShipExecution.ts\");\n/* harmony import */ var _UpgradeStructureExecution__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./UpgradeStructureExecution */ \"./src/core/execution/UpgradeStructureExecution.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Executor {\n    constructor(mg, gameID, clientID) {\n        this.mg = mg;\n        this.gameID = gameID;\n        this.clientID = clientID;\n        // Add one to avoid id collisions with bots.\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(gameID) + 1);\n    }\n    createExecs(turn) {\n        return turn.intents.map((i) => this.createExec(i));\n    }\n    createExec(intent) {\n        const player = this.mg.playerByClientID(intent.clientID);\n        if (!player) {\n            console.warn(`player with clientID ${intent.clientID} not found`);\n            return new _NoOpExecution__WEBPACK_IMPORTED_MODULE_18__.NoOpExecution();\n        }\n        // create execution\n        switch (intent.type) {\n            case \"attack\": {\n                return new _AttackExecution__WEBPACK_IMPORTED_MODULE_6__.AttackExecution(intent.troops, player, intent.targetID, null);\n            }\n            case \"cancel_attack\":\n                return new _RetreatExecution__WEBPACK_IMPORTED_MODULE_20__.RetreatExecution(player, intent.attackID);\n            case \"cancel_boat\":\n                return new _BoatRetreatExecution__WEBPACK_IMPORTED_MODULE_7__.BoatRetreatExecution(player, intent.unitID);\n            case \"move_warship\":\n                return new _MoveWarshipExecution__WEBPACK_IMPORTED_MODULE_17__.MoveWarshipExecution(player, intent.unitId, intent.tile);\n            case \"spawn\":\n                return new _SpawnExecution__WEBPACK_IMPORTED_MODULE_21__.SpawnExecution(player.info(), intent.tile);\n            case \"boat\":\n                return new _TransportShipExecution__WEBPACK_IMPORTED_MODULE_23__.TransportShipExecution(player, intent.targetID, intent.dst, intent.troops, intent.src);\n            case \"allianceRequest\":\n                return new _alliance_AllianceRequestExecution__WEBPACK_IMPORTED_MODULE_3__.AllianceRequestExecution(player, intent.recipient);\n            case \"allianceRequestReply\":\n                return new _alliance_AllianceRequestReplyExecution__WEBPACK_IMPORTED_MODULE_4__.AllianceRequestReplyExecution(intent.requestor, player, intent.accept);\n            case \"breakAlliance\":\n                return new _alliance_BreakAllianceExecution__WEBPACK_IMPORTED_MODULE_5__.BreakAllianceExecution(player, intent.recipient);\n            case \"targetPlayer\":\n                return new _TargetPlayerExecution__WEBPACK_IMPORTED_MODULE_22__.TargetPlayerExecution(player, intent.target);\n            case \"emoji\":\n                return new _EmojiExecution__WEBPACK_IMPORTED_MODULE_14__.EmojiExecution(player, intent.recipient, intent.emoji);\n            case \"donate_troops\":\n                return new _DonateTroopExecution__WEBPACK_IMPORTED_MODULE_12__.DonateTroopsExecution(player, intent.recipient, intent.troops);\n            case \"donate_gold\":\n                return new _DonateGoldExecution__WEBPACK_IMPORTED_MODULE_11__.DonateGoldExecution(player, intent.recipient, intent.gold);\n            case \"embargo\":\n                return new _EmbargoExecution__WEBPACK_IMPORTED_MODULE_13__.EmbargoExecution(player, intent.targetID, intent.action);\n            case \"build_unit\":\n                return new _ConstructionExecution__WEBPACK_IMPORTED_MODULE_9__.ConstructionExecution(player, intent.unit, intent.tile);\n            case \"allianceExtension\": {\n                return new _alliance_AllianceExtensionExecution__WEBPACK_IMPORTED_MODULE_2__.AllianceExtensionExecution(player, intent.recipient);\n            }\n            case \"upgrade_structure\":\n                return new _UpgradeStructureExecution__WEBPACK_IMPORTED_MODULE_24__.UpgradeStructureExecution(player, intent.unitId);\n            case \"delete_unit\":\n                return new _DeleteUnitExecution__WEBPACK_IMPORTED_MODULE_10__.DeleteUnitExecution(player, intent.unitId);\n            case \"quick_chat\":\n                return new _QuickChatExecution__WEBPACK_IMPORTED_MODULE_19__.QuickChatExecution(player, intent.recipient, intent.quickChatKey, intent.target);\n            case \"mark_disconnected\":\n                return new _MarkDisconnectedExecution__WEBPACK_IMPORTED_MODULE_16__.MarkDisconnectedExecution(player, intent.isDisconnected);\n            default:\n                throw new Error(`intent type ${intent} not found`);\n        }\n    }\n    spawnBots(numBots) {\n        return new _BotSpawner__WEBPACK_IMPORTED_MODULE_8__.BotSpawner(this.mg, this.gameID).spawnBots(numBots);\n    }\n    fakeHumanExecutions() {\n        const execs = [];\n        for (const nation of this.mg.nations()) {\n            execs.push(new _FakeHumanExecution__WEBPACK_IMPORTED_MODULE_15__.FakeHumanExecution(this.gameID, nation));\n        }\n        return execs;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/ExecutionManager.ts?\n}");

/***/ }),

/***/ "./src/core/execution/FactoryExecution.ts":
/*!************************************************!*\
  !*** ./src/core/execution/FactoryExecution.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FactoryExecution: () => (/* binding */ FactoryExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _TrainStationExecution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TrainStationExecution */ \"./src/core/execution/TrainStationExecution.ts\");\n\n\nclass FactoryExecution {\n    constructor(player, tile) {\n        this.player = player;\n        this.tile = tile;\n        this.factory = null;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        this.game = mg;\n    }\n    tick(ticks) {\n        if (!this.factory) {\n            const spawnTile = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory, this.tile);\n            if (spawnTile === false) {\n                console.warn(\"cannot build factory\");\n                this.active = false;\n                return;\n            }\n            this.factory = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory, spawnTile, {});\n            this.createStation();\n        }\n        if (!this.factory.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (this.player !== this.factory.owner()) {\n            this.player = this.factory.owner();\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    createStation() {\n        if (this.factory !== null) {\n            const structures = this.game.nearbyUnits(this.factory.tile(), this.game.config().trainStationMaxRange(), [_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory]);\n            this.game.addExecution(new _TrainStationExecution__WEBPACK_IMPORTED_MODULE_1__.TrainStationExecution(this.factory, true));\n            for (const { unit } of structures) {\n                if (!unit.hasTrainStation()) {\n                    this.game.addExecution(new _TrainStationExecution__WEBPACK_IMPORTED_MODULE_1__.TrainStationExecution(unit));\n                }\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/FactoryExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/FakeHumanExecution.ts":
/*!**************************************************!*\
  !*** ./src/core/execution/FakeHumanExecution.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FakeHumanExecution: () => (/* binding */ FakeHumanExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _game_GameMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/GameMap */ \"./src/core/game/GameMap.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _ConstructionExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConstructionExecution */ \"./src/core/execution/ConstructionExecution.ts\");\n/* harmony import */ var _EmojiExecution__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EmojiExecution */ \"./src/core/execution/EmojiExecution.ts\");\n/* harmony import */ var _nation_structureSpawnTileValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nation/structureSpawnTileValue */ \"./src/core/execution/nation/structureSpawnTileValue.ts\");\n/* harmony import */ var _NukeExecution__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./NukeExecution */ \"./src/core/execution/NukeExecution.ts\");\n/* harmony import */ var _SpawnExecution__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SpawnExecution */ \"./src/core/execution/SpawnExecution.ts\");\n/* harmony import */ var _TransportShipExecution__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TransportShipExecution */ \"./src/core/execution/TransportShipExecution.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Util */ \"./src/core/execution/Util.ts\");\n/* harmony import */ var _utils_BotBehavior__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/BotBehavior */ \"./src/core/execution/utils/BotBehavior.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nclass FakeHumanExecution {\n    constructor(gameID, nation) {\n        this.nation = nation;\n        this.active = true;\n        this.behavior = null;\n        this.player = null;\n        this.lastEmojiSent = new Map();\n        this.lastNukeSent = [];\n        this.embargoMalusApplied = new Set();\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_3__.simpleHash)(nation.playerInfo.id) + (0,_Util__WEBPACK_IMPORTED_MODULE_3__.simpleHash)(gameID));\n        this.attackRate = this.random.nextInt(40, 80);\n        this.attackTick = this.random.nextInt(0, this.attackRate);\n        this.triggerRatio = this.random.nextInt(50, 60) / 100;\n        this.reserveRatio = this.random.nextInt(30, 40) / 100;\n        this.expandRatio = this.random.nextInt(10, 20) / 100;\n    }\n    init(mg) {\n        this.mg = mg;\n        if (this.random.chance(10)) {\n            // this.isTraitor = true\n        }\n    }\n    updateRelationsFromEmbargos() {\n        const player = this.player;\n        if (player === null)\n            return;\n        const others = this.mg.players().filter((p) => p.id() !== player.id());\n        others.forEach((other) => {\n            const embargoMalus = -20;\n            if (other.hasEmbargoAgainst(player) &&\n                !this.embargoMalusApplied.has(other.id())) {\n                player.updateRelation(other, embargoMalus);\n                this.embargoMalusApplied.add(other.id());\n            }\n            else if (!other.hasEmbargoAgainst(player) &&\n                this.embargoMalusApplied.has(other.id())) {\n                player.updateRelation(other, -embargoMalus);\n                this.embargoMalusApplied.delete(other.id());\n            }\n        });\n    }\n    handleEmbargoesToHostileNations() {\n        const player = this.player;\n        if (player === null)\n            return;\n        const others = this.mg.players().filter((p) => p.id() !== player.id());\n        others.forEach((other) => {\n            /* When player is hostile starts embargo. Do not stop until neutral again */\n            if (player.relation(other) <= _game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Hostile &&\n                !player.hasEmbargoAgainst(other) &&\n                !player.isOnSameTeam(other)) {\n                player.addEmbargo(other, false);\n            }\n            else if (player.relation(other) >= _game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Neutral &&\n                player.hasEmbargoAgainst(other)) {\n                player.stopEmbargo(other);\n            }\n        });\n    }\n    tick(ticks) {\n        if (ticks % this.attackRate !== this.attackTick)\n            return;\n        if (this.mg.inSpawnPhase()) {\n            const rl = this.randomSpawnLand();\n            if (rl === null) {\n                console.warn(`cannot spawn ${this.nation.playerInfo.name}`);\n                return;\n            }\n            this.mg.addExecution(new _SpawnExecution__WEBPACK_IMPORTED_MODULE_8__.SpawnExecution(this.nation.playerInfo, rl));\n            return;\n        }\n        if (this.player === null) {\n            this.player =\n                this.mg.players().find((p) => p.id() === this.nation.playerInfo.id) ??\n                    null;\n            if (this.player === null) {\n                return;\n            }\n        }\n        if (!this.player.isAlive()) {\n            this.active = false;\n            return;\n        }\n        if (this.behavior === null) {\n            // Player is unavailable during init()\n            this.behavior = new _utils_BotBehavior__WEBPACK_IMPORTED_MODULE_11__.BotBehavior(this.random, this.mg, this.player, this.triggerRatio, this.reserveRatio, this.expandRatio);\n            // Send an attack on the first tick\n            this.behavior.forceSendAttack(this.mg.terraNullius());\n            return;\n        }\n        this.updateRelationsFromEmbargos();\n        this.behavior.handleAllianceRequests();\n        this.behavior.handleAllianceExtensionRequests();\n        this.handleUnits();\n        this.handleEmbargoesToHostileNations();\n        this.maybeAttack();\n    }\n    /**\n     * TODO: Implement strategic betrayal logic\n     * Currently this just breaks alliances without strategic consideration.\n     * Future implementation should consider:\n     * - Relative strength (troop count, territory size) compared to target\n     * - Risk vs reward of betrayal\n     * - Potential impact on relations with other players\n     * - Timing (don't betray when already fighting other enemies)\n     * - Strategic value of target's territory\n     * - If target is distracted\n     */\n    maybeConsiderBetrayal(target) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const alliance = this.player.allianceWith(target);\n        if (!alliance)\n            return false;\n        this.player.breakAlliance(alliance);\n        return true;\n    }\n    maybeAttack() {\n        if (this.player === null || this.behavior === null) {\n            throw new Error(\"not initialized\");\n        }\n        const enemyborder = Array.from(this.player.borderTiles())\n            .flatMap((t) => this.mg.neighbors(t))\n            .filter((t) => this.mg.isLand(t) && this.mg.ownerID(t) !== this.player?.smallID());\n        if (enemyborder.length === 0) {\n            if (this.random.chance(10)) {\n                this.sendBoatRandomly();\n            }\n            return;\n        }\n        if (this.random.chance(20)) {\n            this.sendBoatRandomly();\n            return;\n        }\n        const borderPlayers = enemyborder.map((t) => this.mg.playerBySmallID(this.mg.ownerID(t)));\n        if (borderPlayers.some((o) => !o.isPlayer())) {\n            this.behavior.sendAttack(this.mg.terraNullius());\n            return;\n        }\n        const enemies = borderPlayers\n            .filter((o) => o.isPlayer())\n            .sort((a, b) => a.troops() - b.troops());\n        // 5% chance to send a random alliance request\n        if (this.random.chance(20)) {\n            const toAlly = this.random.randElement(enemies);\n            if (this.player.canSendAllianceRequest(toAlly)) {\n                this.player.createAllianceRequest(toAlly);\n            }\n        }\n        this.behavior.forgetOldEnemies();\n        this.behavior.assistAllies();\n        const enemy = this.behavior.selectEnemy(enemies);\n        if (!enemy)\n            return;\n        this.maybeSendEmoji(enemy);\n        this.maybeSendNuke(enemy);\n        if (this.player.sharesBorderWith(enemy)) {\n            this.behavior.sendAttack(enemy);\n        }\n        else {\n            this.maybeSendBoatAttack(enemy);\n        }\n    }\n    maybeSendEmoji(enemy) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        if (enemy.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Human)\n            return;\n        const lastSent = this.lastEmojiSent.get(enemy) ?? -300;\n        if (this.mg.ticks() - lastSent <= 300)\n            return;\n        this.lastEmojiSent.set(enemy, this.mg.ticks());\n        this.mg.addExecution(new _EmojiExecution__WEBPACK_IMPORTED_MODULE_5__.EmojiExecution(this.player, enemy.id(), this.random.randElement(_utils_BotBehavior__WEBPACK_IMPORTED_MODULE_11__.EMOJI_HECKLE)));\n    }\n    maybeSendNuke(other) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const silos = this.player.units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo);\n        if (silos.length === 0 ||\n            this.player.gold() < this.cost(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb) ||\n            other.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Bot ||\n            this.player.isOnSameTeam(other)) {\n            return;\n        }\n        const nukeType = this.player.gold() > this.cost(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb)\n            ? _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb\n            : _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb;\n        const range = nukeType === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb ? 60 : 15;\n        const structures = other.units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher);\n        const structureTiles = structures.map((u) => u.tile());\n        const randomTiles = this.randTerritoryTileArray(10);\n        const allTiles = randomTiles.concat(structureTiles);\n        let bestTile = null;\n        let bestValue = 0;\n        this.removeOldNukeEvents();\n        outer: for (const tile of new Set(allTiles)) {\n            if (tile === null)\n                continue;\n            const boundingBox = (0,_Util__WEBPACK_IMPORTED_MODULE_3__.boundingBoxTiles)(this.mg, tile, range)\n                // Add radius / 2 in case there is a piece of unwanted territory inside the outer radius that we miss.\n                .concat((0,_Util__WEBPACK_IMPORTED_MODULE_3__.boundingBoxTiles)(this.mg, tile, Math.floor(range / 2)));\n            for (const t of boundingBox) {\n                // Make sure we nuke away from the border\n                if (this.mg.owner(t) !== other) {\n                    continue outer;\n                }\n            }\n            if (!this.player.canBuild(nukeType, tile))\n                continue;\n            const value = this.nukeTileScore(tile, silos, structures);\n            if (value > bestValue) {\n                bestTile = tile;\n                bestValue = value;\n            }\n        }\n        if (bestTile !== null) {\n            this.sendNuke(bestTile, nukeType);\n        }\n    }\n    removeOldNukeEvents() {\n        const maxAge = 500;\n        const tick = this.mg.ticks();\n        while (this.lastNukeSent.length > 0 &&\n            this.lastNukeSent[0][0] + maxAge < tick) {\n            this.lastNukeSent.shift();\n        }\n    }\n    sendNuke(tile, nukeType) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const tick = this.mg.ticks();\n        this.lastNukeSent.push([tick, tile]);\n        this.mg.addExecution(new _NukeExecution__WEBPACK_IMPORTED_MODULE_7__.NukeExecution(nukeType, this.player, tile));\n    }\n    nukeTileScore(tile, silos, targets) {\n        // Potential damage in a 25-tile radius\n        const dist = (0,_game_GameMap__WEBPACK_IMPORTED_MODULE_1__.euclDistFN)(tile, 25, false);\n        let tileValue = targets\n            .filter((unit) => dist(this.mg, unit.tile()))\n            .map((unit) => {\n            switch (unit.type()) {\n                case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City:\n                    return 25000;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost:\n                    return 5000;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo:\n                    return 50000;\n                case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port:\n                    return 10000;\n                default:\n                    return 0;\n            }\n        })\n            .reduce((prev, cur) => prev + cur, 0);\n        // Avoid areas defended by SAM launchers\n        const dist50 = (0,_game_GameMap__WEBPACK_IMPORTED_MODULE_1__.euclDistFN)(tile, 50, false);\n        tileValue -=\n            50000 *\n                targets.filter((unit) => unit.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher && dist50(this.mg, unit.tile())).length;\n        // Prefer tiles that are closer to a silo\n        const siloTiles = silos.map((u) => u.tile());\n        const result = (0,_Util__WEBPACK_IMPORTED_MODULE_10__.closestTwoTiles)(this.mg, siloTiles, [tile]);\n        if (result === null)\n            throw new Error(\"Missing result\");\n        const { x: closestSilo } = result;\n        const distanceSquared = this.mg.euclideanDistSquared(tile, closestSilo);\n        const distanceToClosestSilo = Math.sqrt(distanceSquared);\n        tileValue -= distanceToClosestSilo * 30;\n        // Don't target near recent targets\n        tileValue -= this.lastNukeSent\n            .filter(([_tick, tile]) => dist(this.mg, tile))\n            .map((_) => 1000000)\n            .reduce((prev, cur) => prev + cur, 0);\n        return tileValue;\n    }\n    maybeSendBoatAttack(other) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        if (this.player.isFriendly(other))\n            return;\n        const closest = (0,_Util__WEBPACK_IMPORTED_MODULE_10__.closestTwoTiles)(this.mg, Array.from(this.player.borderTiles()).filter((t) => this.mg.isOceanShore(t)), Array.from(other.borderTiles()).filter((t) => this.mg.isOceanShore(t)));\n        if (closest === null) {\n            return;\n        }\n        this.mg.addExecution(new _TransportShipExecution__WEBPACK_IMPORTED_MODULE_9__.TransportShipExecution(this.player, other.id(), closest.y, this.player.troops() / 5, null));\n    }\n    handleUnits() {\n        return (this.maybeSpawnStructure(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City, (num) => num) ||\n            this.maybeSpawnStructure(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port, (num) => num) ||\n            this.maybeSpawnWarship() ||\n            this.maybeSpawnStructure(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory, (num) => num) ||\n            this.maybeSpawnStructure(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost, (num) => (num + 2) ** 2) ||\n            this.maybeSpawnStructure(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher, (num) => num ** 2) ||\n            this.maybeSpawnStructure(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo, (num) => num ** 2));\n    }\n    maybeSpawnStructure(type, multiplier) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const owned = this.player.unitsOwned(type);\n        const perceivedCostMultiplier = multiplier(owned + 1);\n        const realCost = this.cost(type);\n        const perceivedCost = realCost * BigInt(perceivedCostMultiplier);\n        if (this.player.gold() < perceivedCost) {\n            return false;\n        }\n        const tile = this.structureSpawnTile(type);\n        if (tile === null) {\n            return false;\n        }\n        const canBuild = this.player.canBuild(type, tile);\n        if (canBuild === false) {\n            return false;\n        }\n        this.mg.addExecution(new _ConstructionExecution__WEBPACK_IMPORTED_MODULE_4__.ConstructionExecution(this.player, type, tile));\n        return true;\n    }\n    structureSpawnTile(type) {\n        if (this.mg === undefined)\n            throw new Error(\"Not initialized\");\n        if (this.player === null)\n            throw new Error(\"Not initialized\");\n        const tiles = type === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port\n            ? this.randCoastalTileArray(25)\n            : this.randTerritoryTileArray(25);\n        if (tiles.length === 0)\n            return null;\n        const valueFunction = (0,_nation_structureSpawnTileValue__WEBPACK_IMPORTED_MODULE_6__.structureSpawnTileValue)(this.mg, this.player, type);\n        let bestTile = null;\n        let bestValue = 0;\n        for (const t of tiles) {\n            const v = valueFunction(t);\n            if (v <= bestValue && bestTile !== null)\n                continue;\n            if (!this.player.canBuild(type, t))\n                continue;\n            // Found a better tile\n            bestTile = t;\n            bestValue = v;\n        }\n        return bestTile;\n    }\n    randCoastalTileArray(numTiles) {\n        const tiles = Array.from(this.player.borderTiles()).filter((t) => this.mg.isOceanShore(t));\n        return Array.from(this.arraySampler(tiles, numTiles));\n    }\n    *arraySampler(a, sampleSize) {\n        if (a.length <= sampleSize) {\n            // Return all elements\n            yield* a;\n        }\n        else {\n            // Sample `sampleSize` elements\n            const remaining = new Set(a);\n            while (sampleSize--) {\n                const t = this.random.randFromSet(remaining);\n                remaining.delete(t);\n                yield t;\n            }\n        }\n    }\n    maybeSpawnWarship() {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        if (!this.random.chance(50)) {\n            return false;\n        }\n        const ports = this.player.units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port);\n        const ships = this.player.units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship);\n        if (ports.length > 0 &&\n            ships.length === 0 &&\n            this.player.gold() > this.cost(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship)) {\n            const port = this.random.randElement(ports);\n            const targetTile = this.warshipSpawnTile(port.tile());\n            if (targetTile === null) {\n                return false;\n            }\n            const canBuild = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship, targetTile);\n            if (canBuild === false) {\n                console.warn(\"cannot spawn destroyer\");\n                return false;\n            }\n            this.mg.addExecution(new _ConstructionExecution__WEBPACK_IMPORTED_MODULE_4__.ConstructionExecution(this.player, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship, targetTile));\n            return true;\n        }\n        return false;\n    }\n    randTerritoryTileArray(numTiles) {\n        const boundingBox = (0,_Util__WEBPACK_IMPORTED_MODULE_3__.calculateBoundingBox)(this.mg, this.player.borderTiles());\n        const tiles = [];\n        for (let i = 0; i < numTiles; i++) {\n            const tile = this.randTerritoryTile(this.player, boundingBox);\n            if (tile !== null) {\n                tiles.push(tile);\n            }\n        }\n        return tiles;\n    }\n    randTerritoryTile(p, boundingBox = null) {\n        boundingBox ?? (boundingBox = (0,_Util__WEBPACK_IMPORTED_MODULE_3__.calculateBoundingBox)(this.mg, p.borderTiles()));\n        for (let i = 0; i < 100; i++) {\n            const randX = this.random.nextInt(boundingBox.min.x, boundingBox.max.x);\n            const randY = this.random.nextInt(boundingBox.min.y, boundingBox.max.y);\n            if (!this.mg.isOnMap(new _game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(randX, randY))) {\n                // Sanity check should never happen\n                continue;\n            }\n            const randTile = this.mg.ref(randX, randY);\n            if (this.mg.owner(randTile) === p) {\n                return randTile;\n            }\n        }\n        return null;\n    }\n    warshipSpawnTile(portTile) {\n        const radius = 250;\n        for (let attempts = 0; attempts < 50; attempts++) {\n            const randX = this.random.nextInt(this.mg.x(portTile) - radius, this.mg.x(portTile) + radius);\n            const randY = this.random.nextInt(this.mg.y(portTile) - radius, this.mg.y(portTile) + radius);\n            if (!this.mg.isValidCoord(randX, randY)) {\n                continue;\n            }\n            const tile = this.mg.ref(randX, randY);\n            // Sanity check\n            if (!this.mg.isOcean(tile)) {\n                continue;\n            }\n            return tile;\n        }\n        return null;\n    }\n    cost(type) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        return this.mg.unitInfo(type).cost(this.player);\n    }\n    sendBoatRandomly() {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const oceanShore = Array.from(this.player.borderTiles()).filter((t) => this.mg.isOceanShore(t));\n        if (oceanShore.length === 0) {\n            return;\n        }\n        const src = this.random.randElement(oceanShore);\n        const dst = this.randomBoatTarget(src, 150);\n        if (dst === null) {\n            return;\n        }\n        this.mg.addExecution(new _TransportShipExecution__WEBPACK_IMPORTED_MODULE_9__.TransportShipExecution(this.player, this.mg.owner(dst).id(), dst, this.player.troops() / 5, null));\n        return;\n    }\n    randomSpawnLand() {\n        const delta = 25;\n        let tries = 0;\n        while (tries < 50) {\n            tries++;\n            const cell = this.nation.spawnCell;\n            const x = this.random.nextInt(cell.x - delta, cell.x + delta);\n            const y = this.random.nextInt(cell.y - delta, cell.y + delta);\n            if (!this.mg.isValidCoord(x, y)) {\n                continue;\n            }\n            const tile = this.mg.ref(x, y);\n            if (this.mg.isLand(tile) && !this.mg.hasOwner(tile)) {\n                if (this.mg.terrainType(tile) === _game_Game__WEBPACK_IMPORTED_MODULE_0__.TerrainType.Mountain &&\n                    this.random.chance(2)) {\n                    continue;\n                }\n                return tile;\n            }\n        }\n        return null;\n    }\n    randomBoatTarget(tile, dist) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const x = this.mg.x(tile);\n        const y = this.mg.y(tile);\n        for (let i = 0; i < 500; i++) {\n            const randX = this.random.nextInt(x - dist, x + dist);\n            const randY = this.random.nextInt(y - dist, y + dist);\n            if (!this.mg.isValidCoord(randX, randY)) {\n                continue;\n            }\n            const randTile = this.mg.ref(randX, randY);\n            if (!this.mg.isLand(randTile)) {\n                continue;\n            }\n            const owner = this.mg.owner(randTile);\n            if (!owner.isPlayer()) {\n                return randTile;\n            }\n            if (!owner.isFriendly(this.player)) {\n                return randTile;\n            }\n        }\n        return null;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/FakeHumanExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/MIRVExecution.ts":
/*!*********************************************!*\
  !*** ./src/core/execution/MIRVExecution.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MirvExecution: () => (/* binding */ MirvExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _NukeExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NukeExecution */ \"./src/core/execution/NukeExecution.ts\");\n\n\n\n\n\nclass MirvExecution {\n    constructor(player, dst) {\n        this.player = player;\n        this.dst = dst;\n        this.active = true;\n        this.nuke = null;\n        this.mirvRange = 1500;\n        this.warheadCount = 350;\n        this.speed = -1;\n    }\n    init(mg, ticks) {\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(mg.ticks() + (0,_Util__WEBPACK_IMPORTED_MODULE_3__.simpleHash)(this.player.id()));\n        this.mg = mg;\n        this.pathFinder = new _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__.ParabolaPathFinder(mg);\n        this.targetPlayer = this.mg.owner(this.dst);\n        this.speed = this.mg.config().defaultNukeSpeed();\n        // Record stats\n        this.mg.stats().bombLaunch(this.player, this.targetPlayer, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV);\n        // Betrayal on launch\n        if (this.targetPlayer.isPlayer()) {\n            const alliance = this.player.allianceWith(this.targetPlayer);\n            if (alliance !== null) {\n                this.player.breakAlliance(alliance);\n            }\n            if (this.targetPlayer !== this.player) {\n                this.targetPlayer.updateRelation(this.player, -100);\n            }\n        }\n    }\n    tick(ticks) {\n        if (this.nuke === null) {\n            const spawn = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV, this.dst);\n            if (spawn === false) {\n                console.warn(`cannot build MIRV`);\n                this.active = false;\n                return;\n            }\n            this.nuke = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV, spawn, {});\n            const x = Math.floor((this.mg.x(this.dst) + this.mg.x(this.mg.x(this.nuke.tile()))) / 2);\n            const y = Math.max(0, this.mg.y(this.dst) - 500) + 50;\n            this.separateDst = this.mg.ref(x, y);\n            this.pathFinder.computeControlPoints(spawn, this.separateDst);\n            this.mg.displayIncomingUnit(this.nuke.id(), \n            // TODO TranslateText\n            `âš ï¸âš ï¸âš ï¸ ${this.player.name()} - MIRV INBOUND âš ï¸âš ï¸âš ï¸`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.MIRV_INBOUND, this.targetPlayer.id());\n        }\n        const result = this.pathFinder.nextTile(this.speed);\n        if (result === true) {\n            this.separate();\n            this.active = false;\n            // Record stats\n            this.mg.stats().bombLand(this.player, this.targetPlayer, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV);\n            return;\n        }\n        else {\n            this.nuke.move(result);\n        }\n    }\n    separate() {\n        if (this.nuke === null)\n            throw new Error(\"uninitialized\");\n        const dsts = [this.dst];\n        let attempts = 1000;\n        while (attempts > 0 && dsts.length < this.warheadCount) {\n            attempts--;\n            const potential = this.randomLand(this.dst, dsts);\n            if (potential === null) {\n                continue;\n            }\n            dsts.push(potential);\n        }\n        console.log(`dsts: ${dsts.length}`);\n        dsts.sort((a, b) => this.mg.manhattanDist(b, this.dst) - this.mg.manhattanDist(a, this.dst));\n        console.log(`got ${dsts.length} dsts!!`);\n        for (const [i, dst] of dsts.entries()) {\n            this.mg.addExecution(new _NukeExecution__WEBPACK_IMPORTED_MODULE_4__.NukeExecution(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead, this.player, dst, this.nuke.tile(), 15 + Math.floor((i / this.warheadCount) * 5), \n            //   this.random.nextInt(5, 9),\n            this.random.nextInt(0, 15)));\n        }\n        this.nuke.delete(false);\n    }\n    randomLand(ref, taken) {\n        let tries = 0;\n        const mirvRange2 = this.mirvRange * this.mirvRange;\n        while (tries < 100) {\n            tries++;\n            const x = this.random.nextInt(this.mg.x(ref) - this.mirvRange, this.mg.x(ref) + this.mirvRange);\n            const y = this.random.nextInt(this.mg.y(ref) - this.mirvRange, this.mg.y(ref) + this.mirvRange);\n            if (!this.mg.isValidCoord(x, y)) {\n                continue;\n            }\n            const tile = this.mg.ref(x, y);\n            if (!this.mg.isLand(tile)) {\n                continue;\n            }\n            if (this.mg.euclideanDistSquared(tile, ref) > mirvRange2) {\n                continue;\n            }\n            if (this.mg.owner(tile) !== this.targetPlayer) {\n                continue;\n            }\n            if (this.proximityCheck(tile, taken)) {\n                continue;\n            }\n            return tile;\n        }\n        console.log(\"couldn't find place, giving up\");\n        return null;\n    }\n    proximityCheck(tile, taken) {\n        for (const t of taken) {\n            if (this.mg.manhattanDist(tile, t) < 55) {\n                return true;\n            }\n        }\n        return false;\n    }\n    owner() {\n        return this.player;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/MIRVExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/MarkDisconnectedExecution.ts":
/*!*********************************************************!*\
  !*** ./src/core/execution/MarkDisconnectedExecution.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarkDisconnectedExecution: () => (/* binding */ MarkDisconnectedExecution)\n/* harmony export */ });\nclass MarkDisconnectedExecution {\n    constructor(player, isDisconnected) {\n        this.player = player;\n        this.isDisconnected = isDisconnected;\n    }\n    init(mg, ticks) {\n        this.player.markDisconnected(this.isDisconnected);\n    }\n    tick(ticks) {\n        return;\n    }\n    isActive() {\n        return false;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/MarkDisconnectedExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/MissileSiloExecution.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/MissileSiloExecution.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MissileSiloExecution: () => (/* binding */ MissileSiloExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n\nclass MissileSiloExecution {\n    constructor(player, tile) {\n        this.player = player;\n        this.tile = tile;\n        this.active = true;\n        this.silo = null;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n    }\n    tick(ticks) {\n        if (this.silo === null) {\n            const spawn = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo, this.tile);\n            if (spawn === false) {\n                console.warn(`player ${this.player} cannot build missile silo at ${this.tile}`);\n                this.active = false;\n                return;\n            }\n            this.silo = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo, spawn, {});\n            if (this.player !== this.silo.owner()) {\n                this.player = this.silo.owner();\n            }\n        }\n        // frontTime is the time the earliest missile fired.\n        const frontTime = this.silo.missileTimerQueue()[0];\n        if (frontTime === undefined) {\n            return;\n        }\n        const cooldown = this.mg.config().SiloCooldown() - (this.mg.ticks() - frontTime);\n        if (cooldown <= 0) {\n            this.silo.reloadMissile();\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/MissileSiloExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/MoveWarshipExecution.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/MoveWarshipExecution.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MoveWarshipExecution: () => (/* binding */ MoveWarshipExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n\nclass MoveWarshipExecution {\n    constructor(owner, unitId, position) {\n        this.owner = owner;\n        this.unitId = unitId;\n        this.position = position;\n    }\n    init(mg, ticks) {\n        if (!mg.isValidRef(this.position)) {\n            console.warn(`MoveWarshipExecution: position ${this.position} not valid`);\n            return;\n        }\n        const warship = this.owner\n            .units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship)\n            .find((u) => u.id() === this.unitId);\n        if (!warship) {\n            console.warn(\"MoveWarshipExecution: warship not found\");\n            return;\n        }\n        if (!warship.isActive()) {\n            console.warn(\"MoveWarshipExecution: warship is not active\");\n            return;\n        }\n        warship.setPatrolTile(this.position);\n        warship.setTargetTile(undefined);\n    }\n    tick(ticks) { }\n    isActive() {\n        return false;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/MoveWarshipExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/NoOpExecution.ts":
/*!*********************************************!*\
  !*** ./src/core/execution/NoOpExecution.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoOpExecution: () => (/* binding */ NoOpExecution)\n/* harmony export */ });\nclass NoOpExecution {\n    isActive() {\n        return false;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    init(mg, ticks) { }\n    tick(ticks) { }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/NoOpExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/NukeExecution.ts":
/*!*********************************************!*\
  !*** ./src/core/execution/NukeExecution.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NukeExecution: () => (/* binding */ NukeExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n\n\n\nconst SPRITE_RADIUS = 16;\nclass NukeExecution {\n    constructor(nukeType, player, dst, src, speed = -1, waitTicks = 0) {\n        this.nukeType = nukeType;\n        this.player = player;\n        this.dst = dst;\n        this.src = src;\n        this.speed = speed;\n        this.waitTicks = waitTicks;\n        this.active = true;\n        this.nuke = null;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        if (this.speed === -1) {\n            this.speed = this.mg.config().defaultNukeSpeed();\n        }\n        this.pathFinder = new _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__.ParabolaPathFinder(mg);\n    }\n    target() {\n        return this.mg.owner(this.dst);\n    }\n    tilesToDestroy() {\n        if (this.tilesToDestroyCache !== undefined) {\n            return this.tilesToDestroyCache;\n        }\n        if (this.nuke === null) {\n            throw new Error(\"Not initialized\");\n        }\n        const magnitude = this.mg.config().nukeMagnitudes(this.nuke.type());\n        const rand = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(this.mg.ticks());\n        const inner2 = magnitude.inner * magnitude.inner;\n        const outer2 = magnitude.outer * magnitude.outer;\n        this.tilesToDestroyCache = this.mg.bfs(this.dst, (_, n) => {\n            const d2 = this.mg?.euclideanDistSquared(this.dst, n) ?? 0;\n            return d2 <= outer2 && (d2 <= inner2 || rand.chance(2));\n        });\n        return this.tilesToDestroyCache;\n    }\n    maybeBreakAlliances(toDestroy) {\n        if (this.nuke === null) {\n            throw new Error(\"Not initialized\");\n        }\n        const attacked = new Map();\n        for (const tile of toDestroy) {\n            const owner = this.mg.owner(tile);\n            if (owner.isPlayer()) {\n                const prev = attacked.get(owner) ?? 0;\n                attacked.set(owner, prev + 1);\n            }\n        }\n        const threshold = this.mg.config().nukeAllianceBreakThreshold();\n        for (const [attackedPlayer, tilesDestroyed] of attacked) {\n            if (tilesDestroyed > threshold &&\n                this.nuke.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead) {\n                // Resolves exploit of alliance breaking in which a pending alliance request\n                // was accepeted in the middle of an missle attack.\n                const allianceRequest = attackedPlayer\n                    .incomingAllianceRequests()\n                    .find((ar) => ar.requestor() === this.player);\n                if (allianceRequest) {\n                    allianceRequest?.reject();\n                }\n                // Mirv warheads shouldn't break alliances\n                const alliance = this.player.allianceWith(attackedPlayer);\n                if (alliance !== null) {\n                    this.player.breakAlliance(alliance);\n                }\n                if (attackedPlayer !== this.player) {\n                    attackedPlayer.updateRelation(this.player, -100);\n                }\n            }\n        }\n    }\n    tick(ticks) {\n        if (this.nuke === null) {\n            const spawn = this.src ?? this.player.canBuild(this.nukeType, this.dst);\n            if (spawn === false) {\n                console.warn(`cannot build Nuke`);\n                this.active = false;\n                return;\n            }\n            this.src = spawn;\n            this.pathFinder.computeControlPoints(spawn, this.dst, this.speed, this.nukeType !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead);\n            this.nuke = this.player.buildUnit(this.nukeType, spawn, {\n                targetTile: this.dst,\n                trajectory: this.getTrajectory(this.dst),\n            });\n            this.maybeBreakAlliances(this.tilesToDestroy());\n            if (this.mg.hasOwner(this.dst)) {\n                const target = this.mg.owner(this.dst);\n                if (!target.isPlayer()) {\n                    // Ignore terra nullius\n                }\n                else if (this.nukeType === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb) {\n                    this.mg.displayIncomingUnit(this.nuke.id(), \n                    // TODO TranslateText\n                    `${this.player.name()} - atom bomb inbound`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.NUKE_INBOUND, target.id());\n                }\n                else if (this.nukeType === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb) {\n                    this.mg.displayIncomingUnit(this.nuke.id(), \n                    // TODO TranslateText\n                    `${this.player.name()} - hydrogen bomb inbound`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.HYDROGEN_BOMB_INBOUND, target.id());\n                }\n                // Record stats\n                this.mg.stats().bombLaunch(this.player, target, this.nukeType);\n            }\n            // after sending a nuke set the missilesilo on cooldown\n            const silo = this.player\n                .units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo)\n                .find((silo) => silo.tile() === spawn);\n            if (silo) {\n                silo.launch();\n            }\n            return;\n        }\n        // make the nuke unactive if it was intercepted\n        if (!this.nuke.isActive()) {\n            console.log(`Nuke destroyed before reaching target`);\n            this.active = false;\n            return;\n        }\n        if (this.waitTicks > 0) {\n            this.waitTicks--;\n            return;\n        }\n        // Move to next tile\n        const nextTile = this.pathFinder.nextTile(this.speed);\n        if (nextTile === true) {\n            this.detonate();\n            return;\n        }\n        else {\n            this.updateNukeTargetable();\n            this.nuke.move(nextTile);\n            // Update index so SAM can interpolate future position\n            this.nuke.setTrajectoryIndex(this.pathFinder.currentIndex());\n        }\n    }\n    getNuke() {\n        return this.nuke;\n    }\n    getTrajectory(target) {\n        const trajectoryTiles = [];\n        const targetRangeSquared = this.mg.config().defaultNukeTargetableRange() ** 2;\n        const allTiles = this.pathFinder.allTiles();\n        for (const tile of allTiles) {\n            trajectoryTiles.push({\n                tile,\n                targetable: this.isTargetable(target, tile, targetRangeSquared),\n            });\n        }\n        return trajectoryTiles;\n    }\n    isTargetable(targetTile, nukeTile, targetRangeSquared) {\n        return (this.mg.euclideanDistSquared(nukeTile, targetTile) < targetRangeSquared ||\n            (this.src !== undefined &&\n                this.src !== null &&\n                this.mg.euclideanDistSquared(this.src, nukeTile) < targetRangeSquared));\n    }\n    updateNukeTargetable() {\n        if (this.nuke === null || this.nuke.targetTile() === undefined) {\n            return;\n        }\n        const targetRangeSquared = this.mg.config().defaultNukeTargetableRange() ** 2;\n        const targetTile = this.nuke.targetTile();\n        this.nuke.setTargetable(this.isTargetable(targetTile, this.nuke.tile(), targetRangeSquared));\n    }\n    detonate() {\n        if (this.nuke === null) {\n            throw new Error(\"Not initialized\");\n        }\n        const magnitude = this.mg.config().nukeMagnitudes(this.nuke.type());\n        const toDestroy = this.tilesToDestroy();\n        this.maybeBreakAlliances(toDestroy);\n        const maxTroops = this.target().isPlayer()\n            ? this.mg.config().maxTroops(this.target())\n            : 1;\n        for (const tile of toDestroy) {\n            const owner = this.mg.owner(tile);\n            if (owner.isPlayer()) {\n                owner.relinquish(tile);\n                owner.removeTroops(this.mg\n                    .config()\n                    .nukeDeathFactor(this.nukeType, owner.troops(), owner.numTilesOwned(), maxTroops));\n                owner.outgoingAttacks().forEach((attack) => {\n                    const deaths = this.mg\n                        ?.config()\n                        .nukeDeathFactor(this.nukeType, attack.troops(), owner.numTilesOwned(), maxTroops) ?? 0;\n                    attack.setTroops(attack.troops() - deaths);\n                });\n                owner.units(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip).forEach((attack) => {\n                    const deaths = this.mg\n                        ?.config()\n                        .nukeDeathFactor(this.nukeType, attack.troops(), owner.numTilesOwned(), maxTroops) ?? 0;\n                    attack.setTroops(attack.troops() - deaths);\n                });\n            }\n            if (this.mg.isLand(tile)) {\n                this.mg.setFallout(tile, true);\n            }\n        }\n        const outer2 = magnitude.outer * magnitude.outer;\n        for (const unit of this.mg.units()) {\n            if (unit.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb &&\n                unit.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb &&\n                unit.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead &&\n                unit.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV) {\n                if (this.mg.euclideanDistSquared(this.dst, unit.tile()) < outer2) {\n                    unit.delete(true, this.player);\n                }\n            }\n        }\n        this.redrawBuildings(magnitude.outer + SPRITE_RADIUS);\n        this.active = false;\n        this.nuke.setReachedTarget();\n        this.nuke.delete(false);\n        // Record stats\n        this.mg\n            .stats()\n            .bombLand(this.player, this.target(), this.nuke.type());\n    }\n    redrawBuildings(range) {\n        const rangeSquared = range * range;\n        for (const unit of this.mg.units()) {\n            if ((0,_game_Game__WEBPACK_IMPORTED_MODULE_0__.isStructureType)(unit.type())) {\n                if (this.mg.euclideanDistSquared(this.dst, unit.tile()) < rangeSquared) {\n                    unit.touch();\n                }\n            }\n        }\n    }\n    owner() {\n        return this.player;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/NukeExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/PlayerExecution.ts":
/*!***********************************************!*\
  !*** ./src/core/execution/PlayerExecution.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayerExecution: () => (/* binding */ PlayerExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n\n\nclass PlayerExecution {\n    constructor(player) {\n        this.player = player;\n        this.ticksPerClusterCalc = 20;\n        this.lastCalc = 0;\n        this.active = true;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        this.config = mg.config();\n        this.lastCalc =\n            ticks + ((0,_Util__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(this.player.name()) % this.ticksPerClusterCalc);\n    }\n    tick(ticks) {\n        this.player.decayRelations();\n        for (const u of this.player.units()) {\n            if (!u.info().territoryBound) {\n                continue;\n            }\n            const owner = this.mg.owner(u.tile());\n            if (!owner?.isPlayer()) {\n                u.delete();\n                continue;\n            }\n            if (owner === this.player) {\n                continue;\n            }\n            const captor = this.mg.player(owner.id());\n            if (u.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost) {\n                u.decreaseLevel(captor);\n                if (u.isActive()) {\n                    captor.captureUnit(u);\n                }\n            }\n            else {\n                captor.captureUnit(u);\n            }\n        }\n        if (!this.player.isAlive()) {\n            // Player has no tiles, delete any remaining units and gold\n            const gold = this.player.gold();\n            this.player.removeGold(gold);\n            this.player.units().forEach((u) => {\n                if (u.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb &&\n                    u.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb &&\n                    u.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead &&\n                    u.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRV) {\n                    u.delete();\n                }\n            });\n            this.active = false;\n            this.mg.stats().playerKilled(this.player, ticks);\n            return;\n        }\n        const troopInc = this.config.troopIncreaseRate(this.player);\n        this.player.addTroops(troopInc);\n        const goldFromWorkers = this.config.goldAdditionRate(this.player);\n        this.player.addGold(goldFromWorkers);\n        // Record stats\n        this.mg.stats().goldWork(this.player, goldFromWorkers);\n        const alliances = Array.from(this.player.alliances());\n        for (const alliance of alliances) {\n            if (alliance.expiresAt() <= this.mg.ticks()) {\n                alliance.expire();\n            }\n        }\n        const embargoes = this.player.getEmbargoes();\n        for (const embargo of embargoes) {\n            if (embargo.isTemporary &&\n                this.mg.ticks() - embargo.createdAt >\n                    this.mg.config().temporaryEmbargoDuration()) {\n                this.player.stopEmbargo(embargo.target);\n            }\n        }\n        if (ticks - this.lastCalc > this.ticksPerClusterCalc) {\n            if (this.player.lastTileChange() > this.lastCalc) {\n                this.lastCalc = ticks;\n                const start = performance.now();\n                this.removeClusters();\n                const end = performance.now();\n                if (end - start > 1000) {\n                    console.log(`player ${this.player.name()}, took ${end - start}ms`);\n                }\n            }\n        }\n    }\n    removeClusters() {\n        const clusters = this.calculateClusters();\n        clusters.sort((a, b) => b.size - a.size);\n        const main = clusters.shift();\n        if (main === undefined)\n            throw new Error(\"No clusters\");\n        this.player.largestClusterBoundingBox = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.calculateBoundingBox)(this.mg, main);\n        const surroundedBy = this.surroundedBySamePlayer(main);\n        if (surroundedBy && !this.player.isFriendly(surroundedBy)) {\n            this.removeCluster(main);\n        }\n        for (const cluster of clusters) {\n            if (this.isSurrounded(cluster)) {\n                this.removeCluster(cluster);\n            }\n        }\n    }\n    surroundedBySamePlayer(cluster) {\n        const enemies = new Set();\n        for (const tile of cluster) {\n            const isOceanShore = this.mg.isOceanShore(tile);\n            if (this.mg.isOceanShore(tile) && !isOceanShore) {\n                continue;\n            }\n            if (isOceanShore ||\n                this.mg.isOnEdgeOfMap(tile) ||\n                this.mg.neighbors(tile).some((n) => !this.mg?.hasOwner(n))) {\n                return false;\n            }\n            this.mg\n                .neighbors(tile)\n                .filter((n) => this.mg?.ownerID(n) !== this.player?.smallID())\n                .forEach((p) => this.mg && enemies.add(this.mg.ownerID(p)));\n            if (enemies.size !== 1) {\n                return false;\n            }\n        }\n        if (enemies.size !== 1) {\n            return false;\n        }\n        const enemy = this.mg.playerBySmallID(Array.from(enemies)[0]);\n        const enemyBox = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.calculateBoundingBox)(this.mg, enemy.borderTiles());\n        const clusterBox = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.calculateBoundingBox)(this.mg, cluster);\n        if ((0,_Util__WEBPACK_IMPORTED_MODULE_1__.inscribed)(enemyBox, clusterBox)) {\n            return enemy;\n        }\n        return false;\n    }\n    isSurrounded(cluster) {\n        const enemyTiles = new Set();\n        for (const tr of cluster) {\n            if (this.mg.isShore(tr) || this.mg.isOnEdgeOfMap(tr)) {\n                return false;\n            }\n            this.mg\n                .neighbors(tr)\n                .filter((n) => this.mg?.owner(n).isPlayer() &&\n                this.mg?.ownerID(n) !== this.player?.smallID())\n                .forEach((n) => enemyTiles.add(n));\n        }\n        if (enemyTiles.size === 0) {\n            return false;\n        }\n        const enemyBox = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.calculateBoundingBox)(this.mg, enemyTiles);\n        const clusterBox = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.calculateBoundingBox)(this.mg, cluster);\n        return (0,_Util__WEBPACK_IMPORTED_MODULE_1__.inscribed)(enemyBox, clusterBox);\n    }\n    removeCluster(cluster) {\n        if (Array.from(cluster).some((t) => this.mg?.ownerID(t) !== this.player?.smallID())) {\n            // Other removeCluster operations could change tile owners,\n            // so double check.\n            return;\n        }\n        const capturing = this.getCapturingPlayer(cluster);\n        if (capturing === null) {\n            return;\n        }\n        const firstTile = cluster.values().next().value;\n        if (!firstTile) {\n            return;\n        }\n        const filter = (_, t) => this.mg?.ownerID(t) === this.player?.smallID();\n        const tiles = this.mg.bfs(firstTile, filter);\n        if (this.player.numTilesOwned() === tiles.size) {\n            this.mg.conquerPlayer(capturing, this.player);\n        }\n        for (const tile of tiles) {\n            capturing.conquer(tile);\n        }\n    }\n    getCapturingPlayer(cluster) {\n        const neighbors = new Map();\n        for (const t of cluster) {\n            for (const neighbor of this.mg.neighbors(t)) {\n                const owner = this.mg.owner(neighbor);\n                if (owner.isPlayer() &&\n                    owner !== this.player &&\n                    !owner.isFriendly(this.player)) {\n                    neighbors.set(owner, (neighbors.get(owner) ?? 0) + 1);\n                }\n            }\n        }\n        // If there are no enemies, return null\n        if (neighbors.size === 0) {\n            return null;\n        }\n        // Get the largest attack from the neighbors\n        let largestNeighborAttack = null;\n        let largestTroopCount = 0;\n        for (const [neighbor] of neighbors) {\n            for (const attack of neighbor.outgoingAttacks()) {\n                if (attack.target() === this.player) {\n                    if (attack.troops() > largestTroopCount) {\n                        largestTroopCount = attack.troops();\n                        largestNeighborAttack = neighbor;\n                    }\n                }\n            }\n        }\n        if (largestNeighborAttack !== null) {\n            return largestNeighborAttack;\n        }\n        // There are no ongoing attacks, so find the enemy with the largest border.\n        return (0,_Util__WEBPACK_IMPORTED_MODULE_1__.getMode)(neighbors);\n    }\n    calculateClusters() {\n        const seen = new Set();\n        const border = this.player.borderTiles();\n        const clusters = [];\n        for (const tile of border) {\n            if (seen.has(tile)) {\n                continue;\n            }\n            const cluster = new Set();\n            const queue = [tile];\n            seen.add(tile);\n            while (queue.length > 0) {\n                const curr = queue.shift();\n                if (curr === undefined)\n                    throw new Error(\"curr is undefined\");\n                cluster.add(curr);\n                const neighbors = this.mg.neighborsWithDiag(curr);\n                for (const neighbor of neighbors) {\n                    if (border.has(neighbor) && !seen.has(neighbor)) {\n                        queue.push(neighbor);\n                        seen.add(neighbor);\n                    }\n                }\n            }\n            clusters.push(cluster);\n        }\n        return clusters;\n    }\n    owner() {\n        if (this.player === null) {\n            throw new Error(\"Not initialized\");\n        }\n        return this.player;\n    }\n    isActive() {\n        return this.active;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/PlayerExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/PortExecution.ts":
/*!*********************************************!*\
  !*** ./src/core/execution/PortExecution.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortExecution: () => (/* binding */ PortExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _TradeShipExecution__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TradeShipExecution */ \"./src/core/execution/TradeShipExecution.ts\");\n/* harmony import */ var _TrainStationExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TrainStationExecution */ \"./src/core/execution/TrainStationExecution.ts\");\n\n\n\n\nclass PortExecution {\n    constructor(player, tile) {\n        this.player = player;\n        this.tile = tile;\n        this.active = true;\n        this.port = null;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__.PseudoRandom(mg.ticks());\n        this.checkOffset = mg.ticks() % 10;\n    }\n    tick(ticks) {\n        if (this.mg === null || this.random === null || this.checkOffset === null) {\n            throw new Error(\"Not initialized\");\n        }\n        if (this.port === null) {\n            const tile = this.tile;\n            const spawn = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port, tile);\n            if (spawn === false) {\n                console.warn(`player ${this.player.id()} cannot build port at ${this.tile}`);\n                this.active = false;\n                return;\n            }\n            this.port = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port, spawn, {});\n            this.createStation();\n        }\n        if (!this.port.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (this.player.id() !== this.port.owner().id()) {\n            this.player = this.port.owner();\n        }\n        // Only check every 10 ticks for performance.\n        if ((this.mg.ticks() + this.checkOffset) % 10 !== 0) {\n            return;\n        }\n        if (!this.shouldSpawnTradeShip()) {\n            return;\n        }\n        const ports = this.player.tradingPorts(this.port);\n        if (ports.length === 0) {\n            return;\n        }\n        const port = this.random.randElement(ports);\n        this.mg.addExecution(new _TradeShipExecution__WEBPACK_IMPORTED_MODULE_2__.TradeShipExecution(this.player, this.port, port));\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    shouldSpawnTradeShip() {\n        const numTradeShips = this.mg.unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TradeShip);\n        const numPlayerPorts = this.player.unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port);\n        const numPlayerTradeShips = this.player.unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TradeShip);\n        const spawnRate = this.mg\n            .config()\n            .tradeShipSpawnRate(numTradeShips, numPlayerPorts, numPlayerTradeShips);\n        for (let i = 0; i < this.port.level(); i++) {\n            if (this.random.chance(spawnRate)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    createStation() {\n        if (this.port !== null) {\n            const nearbyFactory = this.mg.hasUnitNearby(this.port.tile(), this.mg.config().trainStationMaxRange(), _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory);\n            if (nearbyFactory) {\n                this.mg.addExecution(new _TrainStationExecution__WEBPACK_IMPORTED_MODULE_3__.TrainStationExecution(this.port));\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/PortExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/QuickChatExecution.ts":
/*!**************************************************!*\
  !*** ./src/core/execution/QuickChatExecution.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QuickChatExecution: () => (/* binding */ QuickChatExecution)\n/* harmony export */ });\nclass QuickChatExecution {\n    constructor(sender, recipientID, quickChatKey, target) {\n        this.sender = sender;\n        this.recipientID = recipientID;\n        this.quickChatKey = quickChatKey;\n        this.target = target;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        if (!mg.hasPlayer(this.recipientID)) {\n            console.warn(`QuickChatExecution: recipient ${this.recipientID} not found`);\n            this.active = false;\n            return;\n        }\n        this.recipient = mg.player(this.recipientID);\n    }\n    tick(ticks) {\n        const message = this.getMessageFromKey(this.quickChatKey);\n        this.mg.displayChat(message[1], message[0], this.target, this.recipient.id(), true, this.sender.id());\n        this.mg.displayChat(message[1], message[0], this.target, this.sender.id(), false, this.recipient.id());\n        console.log(`[QuickChat] ${this.sender.name} â†’ ${this.recipient.displayName}: ${message}`);\n        this.active = false;\n    }\n    owner() {\n        return this.sender;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    getMessageFromKey(fullKey) {\n        const translated = fullKey.split(\".\");\n        return translated;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/QuickChatExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/RailroadExecution.ts":
/*!*************************************************!*\
  !*** ./src/core/execution/RailroadExecution.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RailroadExecution: () => (/* binding */ RailroadExecution)\n/* harmony export */ });\n/* harmony import */ var _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n\nclass RailroadExecution {\n    constructor(railRoad) {\n        this.railRoad = railRoad;\n        this.active = true;\n        this.headIndex = 0;\n        this.tailIndex = 0;\n        this.increment = 3;\n        this.railTiles = [];\n        this.tailIndex = railRoad.tiles.length;\n    }\n    isActive() {\n        return this.active;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        const tiles = this.railRoad.tiles;\n        // Inverse direction computation for the first tile\n        this.railTiles.push({\n            tile: tiles[0],\n            railType: tiles.length > 0\n                ? this.computeExtremityDirection(tiles[0], tiles[1])\n                : _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL,\n        });\n        for (let i = 1; i < tiles.length - 1; i++) {\n            const direction = this.computeDirection(tiles[i - 1], tiles[i], tiles[i + 1]);\n            this.railTiles.push({ tile: tiles[i], railType: direction });\n        }\n        this.railTiles.push({\n            tile: tiles[tiles.length - 1],\n            railType: tiles.length > 0\n                ? this.computeExtremityDirection(tiles[tiles.length - 1], tiles[tiles.length - 2])\n                : _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL,\n        });\n    }\n    computeExtremityDirection(tile, next) {\n        const x = this.mg.x(tile);\n        const y = this.mg.y(tile);\n        const nextX = this.mg.x(next);\n        const nextY = this.mg.y(next);\n        const dx = nextX - x;\n        const dy = nextY - y;\n        if (dx === 0 && dy === 0)\n            return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL; // No movement\n        if (dx === 0) {\n            return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL;\n        }\n        else if (dy === 0) {\n            return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.HORIZONTAL;\n        }\n        return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL;\n    }\n    computeDirection(prev, current, next) {\n        if (this.mg === null) {\n            throw new Error(\"Not initialized\");\n        }\n        const x1 = this.mg.x(prev);\n        const y1 = this.mg.y(prev);\n        const x2 = this.mg.x(current);\n        const y2 = this.mg.y(current);\n        const x3 = this.mg.x(next);\n        const y3 = this.mg.y(next);\n        const dx1 = x2 - x1;\n        const dy1 = y2 - y1;\n        const dx2 = x3 - x2;\n        const dy2 = y3 - y2;\n        // Straight line\n        if (dx1 === dx2 && dy1 === dy2) {\n            if (dx1 !== 0)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.HORIZONTAL;\n            if (dy1 !== 0)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL;\n        }\n        // Turn (corner) cases\n        if ((dx1 === 0 && dx2 !== 0) || (dx1 !== 0 && dx2 === 0)) {\n            // Now figure out which type of corner\n            if (dx1 === 0 && dx2 === 1 && dy1 === -1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.BOTTOM_RIGHT;\n            if (dx1 === 0 && dx2 === -1 && dy1 === -1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.BOTTOM_LEFT;\n            if (dx1 === 0 && dx2 === 1 && dy1 === 1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.TOP_RIGHT;\n            if (dx1 === 0 && dx2 === -1 && dy1 === 1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.TOP_LEFT;\n            if (dx1 === 1 && dx2 === 0 && dy2 === -1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.TOP_LEFT;\n            if (dx1 === -1 && dx2 === 0 && dy2 === -1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.TOP_RIGHT;\n            if (dx1 === 1 && dx2 === 0 && dy2 === 1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.BOTTOM_LEFT;\n            if (dx1 === -1 && dx2 === 0 && dy2 === 1)\n                return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.BOTTOM_RIGHT;\n        }\n        console.warn(`Invalid rail segment: ${dx1}:${dy1}, ${dx2}:${dy2}`);\n        return _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL;\n    }\n    tick(ticks) {\n        if (this.mg === null) {\n            throw new Error(\"Not initialized\");\n        }\n        if (!this.activeSourceOrDestination()) {\n            this.active = false;\n            return;\n        }\n        if (this.headIndex > this.tailIndex) {\n            // Construction complete\n            this.constructionComplete();\n            return;\n        }\n        let updatedRailTiles;\n        // Check if remaining tiles can be done all at once\n        if (this.tailIndex - this.headIndex <= 2 * this.increment) {\n            updatedRailTiles = this.railTiles.slice(this.headIndex, this.tailIndex);\n            this.constructionComplete();\n        }\n        else {\n            updatedRailTiles = this.railTiles.slice(this.headIndex, this.headIndex + this.increment);\n            updatedRailTiles = updatedRailTiles.concat(this.railTiles.slice(this.tailIndex - this.increment, this.tailIndex));\n            this.headIndex += this.increment;\n            this.tailIndex -= this.increment;\n        }\n        if (updatedRailTiles) {\n            this.mg.addUpdate({\n                type: _game_GameUpdates__WEBPACK_IMPORTED_MODULE_0__.GameUpdateType.RailroadEvent,\n                isActive: true,\n                railTiles: updatedRailTiles,\n            });\n        }\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    activeSourceOrDestination() {\n        return this.railRoad.from.isActive() && this.railRoad.to.isActive();\n    }\n    constructionComplete() {\n        this.redrawBuildings();\n        this.active = false;\n    }\n    redrawBuildings() {\n        if (this.railRoad.from.unit.isActive())\n            this.railRoad.from.unit.touch();\n        if (this.railRoad.to.unit.isActive())\n            this.railRoad.to.unit.touch();\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/RailroadExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/RetreatExecution.ts":
/*!************************************************!*\
  !*** ./src/core/execution/RetreatExecution.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RetreatExecution: () => (/* binding */ RetreatExecution)\n/* harmony export */ });\nconst cancelDelay = 20;\nclass RetreatExecution {\n    constructor(player, attackID) {\n        this.player = player;\n        this.attackID = attackID;\n        this.active = true;\n        this.retreatOrdered = false;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        this.startTick = mg.ticks();\n    }\n    tick(ticks) {\n        if (!this.retreatOrdered) {\n            this.player.orderRetreat(this.attackID);\n            this.retreatOrdered = true;\n        }\n        if (this.mg.ticks() >= this.startTick + cancelDelay) {\n            this.player.executeRetreat(this.attackID);\n            this.active = false;\n        }\n    }\n    owner() {\n        return this.player;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/RetreatExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/SAMLauncherExecution.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/SAMLauncherExecution.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SAMLauncherExecution: () => (/* binding */ SAMLauncherExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _SAMMissileExecution__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SAMMissileExecution */ \"./src/core/execution/SAMMissileExecution.ts\");\n\n\n\n/**\n * Smart SAM targeting system preshoting nukes so its range is strictly enforced\n */\nclass SAMTargetingSystem {\n    constructor(mg, sam) {\n        this.mg = mg;\n        this.sam = sam;\n        // Interception tiles are computed a single time, but it may not be reachable yet.\n        // Store the result so it can be intercepted at the proper time, rather than recomputing each ticks\n        // Null interception tile means there are no interception tiles in range. Store it to\n        this.precomputedNukes = new Map();\n        this.missileSpeed = this.mg.config().defaultSamMissileSpeed();\n    }\n    updateUnreachableNukes(nearbyUnits) {\n        const nearbyUnitSet = new Set(nearbyUnits.map((u) => u.unit.id()));\n        for (const nukeId of this.precomputedNukes.keys()) {\n            if (!nearbyUnitSet.has(nukeId)) {\n                this.precomputedNukes.delete(nukeId);\n            }\n        }\n    }\n    isInRange(tile) {\n        const samTile = this.sam.tile();\n        const range = this.mg.config().defaultSamRange();\n        const rangeSquared = range * range;\n        return this.mg.euclideanDistSquared(samTile, tile) <= rangeSquared;\n    }\n    tickToReach(currentTile, tile) {\n        return Math.ceil(this.mg.manhattanDist(currentTile, tile) / this.missileSpeed);\n    }\n    computeInterceptionTile(unit) {\n        const trajectory = unit.trajectory();\n        const samTile = this.sam.tile();\n        const currentIndex = unit.trajectoryIndex();\n        const explosionTick = trajectory.length - currentIndex;\n        for (let i = currentIndex; i < trajectory.length; i++) {\n            const trajectoryTile = trajectory[i];\n            if (trajectoryTile.targetable && this.isInRange(trajectoryTile.tile)) {\n                const nukeTickToReach = i - currentIndex;\n                const samTickToReach = this.tickToReach(samTile, trajectoryTile.tile);\n                const tickBeforeShooting = nukeTickToReach - samTickToReach;\n                if (samTickToReach < explosionTick && tickBeforeShooting >= 0) {\n                    return { tick: tickBeforeShooting, tile: trajectoryTile.tile };\n                }\n            }\n        }\n        return undefined;\n    }\n    getSingleTarget(ticks) {\n        // Look beyond the SAM range so it can preshot nukes\n        const detectionRange = this.mg.config().defaultSamRange() * 2;\n        const nukes = this.mg.nearbyUnits(this.sam.tile(), detectionRange, [_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb], ({ unit }) => {\n            return ((0,_game_Game__WEBPACK_IMPORTED_MODULE_0__.isUnit)(unit) &&\n                unit.owner() !== this.sam.owner() &&\n                !this.sam.owner().isFriendly(unit.owner()));\n        });\n        // Clear unreachable nukes that went out of range\n        this.updateUnreachableNukes(nukes);\n        const targets = [];\n        for (const nuke of nukes) {\n            const nukeId = nuke.unit.id();\n            const cached = this.precomputedNukes.get(nukeId);\n            if (cached !== undefined) {\n                if (cached === null) {\n                    // Known unreachable, skip.\n                    continue;\n                }\n                if (cached.tick === ticks) {\n                    // Time to shoot!\n                    targets.push({ tile: cached.tile, unit: nuke.unit });\n                    this.precomputedNukes.delete(nukeId);\n                    continue;\n                }\n                if (cached.tick > ticks) {\n                    // Not due yet, skip for now.\n                    continue;\n                }\n                // Missed the planned tick (e.g was on cooldown), recompute a new interception tile if possible\n                this.precomputedNukes.delete(nukeId);\n            }\n            const interceptionTile = this.computeInterceptionTile(nuke.unit);\n            if (interceptionTile !== undefined) {\n                if (interceptionTile.tick <= 1) {\n                    // Shoot instantly\n                    targets.push({ unit: nuke.unit, tile: interceptionTile.tile });\n                }\n                else {\n                    // Nuke will be reachable but not yet. Store the result.\n                    this.precomputedNukes.set(nukeId, {\n                        tick: interceptionTile.tick + ticks,\n                        tile: interceptionTile.tile,\n                    });\n                }\n            }\n            else {\n                // Store unreachable nukes in order to prevent useless interception computation\n                this.precomputedNukes.set(nukeId, null);\n            }\n        }\n        return (targets.sort((a, b) => {\n            // Prioritize Hydrogen Bombs\n            if (a.unit.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb &&\n                b.unit.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb)\n                return -1;\n            if (a.unit.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb &&\n                b.unit.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb)\n                return 1;\n            return 0;\n        })[0] ?? null);\n    }\n}\nclass SAMLauncherExecution {\n    constructor(player, tile, sam = null) {\n        this.player = player;\n        this.tile = tile;\n        this.sam = sam;\n        this.active = true;\n        // As MIRV go very fast we have to detect them very early but we only\n        // shoot the one targeting very close (MIRVWarheadProtectionRadius)\n        this.MIRVWarheadSearchRadius = 400;\n        this.MIRVWarheadProtectionRadius = 50;\n        if (sam !== null) {\n            this.tile = sam.tile();\n        }\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n    }\n    isHit(type, random) {\n        if (type === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb) {\n            return true;\n        }\n        if (type === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead) {\n            return random < this.mg.config().samWarheadHittingChance();\n        }\n        return random < this.mg.config().samHittingChance();\n    }\n    tick(ticks) {\n        if (this.mg === null || this.player === null) {\n            throw new Error(\"Not initialized\");\n        }\n        if (this.sam === null) {\n            if (this.tile === null) {\n                throw new Error(\"tile is null\");\n            }\n            const spawnTile = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher, this.tile);\n            if (spawnTile === false) {\n                console.warn(\"cannot build SAM Launcher\");\n                this.active = false;\n                return;\n            }\n            this.sam = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher, spawnTile, {});\n        }\n        this.targetingSystem ?? (this.targetingSystem = new SAMTargetingSystem(this.mg, this.sam));\n        if (this.sam.isInCooldown()) {\n            const frontTime = this.sam.missileTimerQueue()[0];\n            if (frontTime === undefined) {\n                return;\n            }\n            const cooldown = this.mg.config().SAMCooldown() - (this.mg.ticks() - frontTime);\n            if (cooldown <= 0) {\n                this.sam.reloadMissile();\n            }\n            return;\n        }\n        if (!this.sam.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (this.player !== this.sam.owner()) {\n            this.player = this.sam.owner();\n        }\n        this.pseudoRandom ?? (this.pseudoRandom = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__.PseudoRandom(this.sam.id()));\n        const mirvWarheadTargets = this.mg.nearbyUnits(this.sam.tile(), this.MIRVWarheadSearchRadius, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead, ({ unit }) => {\n            if (!(0,_game_Game__WEBPACK_IMPORTED_MODULE_0__.isUnit)(unit))\n                return false;\n            if (unit.owner() === this.player)\n                return false;\n            if (this.player.isFriendly(unit.owner()))\n                return false;\n            const dst = unit.targetTile();\n            return (this.sam !== null &&\n                dst !== undefined &&\n                this.mg.manhattanDist(dst, this.sam.tile()) <\n                    this.MIRVWarheadProtectionRadius);\n        });\n        let target = null;\n        if (mirvWarheadTargets.length === 0) {\n            target = this.targetingSystem.getSingleTarget(ticks);\n            if (target !== null) {\n                console.log(\"Target acquired\");\n            }\n        }\n        const isSingleTarget = target && !target.unit.targetedBySAM();\n        if (isSingleTarget || mirvWarheadTargets.length > 0) {\n            this.sam.launch();\n            const type = mirvWarheadTargets.length > 0\n                ? _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead\n                : target?.unit.type();\n            if (type === undefined)\n                throw new Error(\"Unknown unit type\");\n            const random = this.pseudoRandom.next();\n            const hit = this.isHit(type, random);\n            if (!hit) {\n                this.mg.displayMessage(`Missile failed to intercept ${type}`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.SAM_MISS, this.sam.owner().id());\n            }\n            else if (mirvWarheadTargets.length > 0) {\n                const samOwner = this.sam.owner();\n                // Message\n                this.mg.displayMessage(`${mirvWarheadTargets.length} MIRV warheads intercepted`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.SAM_HIT, samOwner.id());\n                mirvWarheadTargets.forEach(({ unit: u }) => {\n                    // Delete warheads\n                    u.delete();\n                });\n                // Record stats\n                this.mg\n                    .stats()\n                    .bombIntercept(samOwner, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MIRVWarhead, mirvWarheadTargets.length);\n            }\n            else if (target !== null) {\n                target.unit.setTargetedBySAM(true);\n                this.mg.addExecution(new _SAMMissileExecution__WEBPACK_IMPORTED_MODULE_2__.SAMMissileExecution(this.sam.tile(), this.sam.owner(), this.sam, target.unit, target.tile));\n            }\n            else {\n                throw new Error(\"target is null\");\n            }\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/SAMLauncherExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/SAMMissileExecution.ts":
/*!***************************************************!*\
  !*** ./src/core/execution/SAMMissileExecution.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SAMMissileExecution: () => (/* binding */ SAMMissileExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n\n\n\nclass SAMMissileExecution {\n    constructor(spawn, _owner, ownerUnit, target, targetTile) {\n        this.spawn = spawn;\n        this._owner = _owner;\n        this.ownerUnit = ownerUnit;\n        this.target = target;\n        this.targetTile = targetTile;\n        this.active = true;\n        this.speed = 0;\n    }\n    init(mg, ticks) {\n        this.pathFinder = new _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__.AirPathFinder(mg, new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(mg.ticks()));\n        this.mg = mg;\n        this.speed = this.mg.config().defaultSamMissileSpeed();\n    }\n    tick(ticks) {\n        this.SAMMissile ?? (this.SAMMissile = this._owner.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMMissile, this.spawn, {}));\n        if (!this.SAMMissile.isActive()) {\n            this.active = false;\n            return;\n        }\n        // Mirv warheads are too fast, and mirv shouldn't be stopped ever\n        const nukesWhitelist = [_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.HydrogenBomb];\n        if (!this.target.isActive() ||\n            !this.ownerUnit.isActive() ||\n            this.target.owner() === this.SAMMissile.owner() ||\n            !nukesWhitelist.includes(this.target.type())) {\n            this.SAMMissile.delete(false);\n            this.active = false;\n            return;\n        }\n        for (let i = 0; i < this.speed; i++) {\n            const result = this.pathFinder.nextTile(this.SAMMissile.tile(), this.targetTile);\n            if (result === true) {\n                this.mg.displayMessage(`Missile intercepted ${this.target.type()}`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.SAM_HIT, this._owner.id());\n                this.active = false;\n                this.target.delete(true, this._owner);\n                this.SAMMissile.delete(false);\n                // Record stats\n                this.mg\n                    .stats()\n                    .bombIntercept(this._owner, this.target.type(), 1);\n                return;\n            }\n            else {\n                this.SAMMissile.move(result);\n            }\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/SAMMissileExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/ShellExecution.ts":
/*!**********************************************!*\
  !*** ./src/core/execution/ShellExecution.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShellExecution: () => (/* binding */ ShellExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n\n\n\nclass ShellExecution {\n    constructor(spawn, _owner, ownerUnit, target) {\n        this.spawn = spawn;\n        this._owner = _owner;\n        this.ownerUnit = ownerUnit;\n        this.target = target;\n        this.active = true;\n        this.destroyAtTick = -1;\n    }\n    init(mg, ticks) {\n        this.pathFinder = new _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_1__.AirPathFinder(mg, new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(mg.ticks()));\n        this.mg = mg;\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(mg.ticks());\n    }\n    tick(ticks) {\n        this.shell ?? (this.shell = this._owner.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Shell, this.spawn, {}));\n        if (!this.shell.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (!this.target.isActive() ||\n            this.target.owner() === this.shell.owner() ||\n            (this.destroyAtTick !== -1 && this.mg.ticks() >= this.destroyAtTick)) {\n            this.shell.delete(false);\n            this.active = false;\n            return;\n        }\n        if (this.destroyAtTick === -1 && !this.ownerUnit.isActive()) {\n            this.destroyAtTick = this.mg.ticks() + this.mg.config().shellLifetime();\n        }\n        for (let i = 0; i < 3; i++) {\n            const result = this.pathFinder.nextTile(this.shell.tile(), this.target.tile());\n            if (result === true) {\n                this.active = false;\n                this.target.modifyHealth(-this.effectOnTarget(), this._owner);\n                this.shell.setReachedTarget();\n                this.shell.delete(false);\n                return;\n            }\n            else {\n                this.shell.move(result);\n            }\n        }\n    }\n    effectOnTarget() {\n        const { damage } = this.mg.config().unitInfo(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Shell);\n        const baseDamage = damage ?? 250;\n        const roll = this.random.nextInt(1, 6);\n        const damageMultiplier = (roll - 1) * 25 + 200;\n        return Math.round((baseDamage / 250) * damageMultiplier);\n    }\n    getEffectOnTargetForTesting() {\n        return this.effectOnTarget();\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/ShellExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/SpawnExecution.ts":
/*!**********************************************!*\
  !*** ./src/core/execution/SpawnExecution.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpawnExecution: () => (/* binding */ SpawnExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _BotExecution__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BotExecution */ \"./src/core/execution/BotExecution.ts\");\n/* harmony import */ var _PlayerExecution__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PlayerExecution */ \"./src/core/execution/PlayerExecution.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util */ \"./src/core/execution/Util.ts\");\n\n\n\n\nclass SpawnExecution {\n    constructor(playerInfo, tile) {\n        this.playerInfo = playerInfo;\n        this.tile = tile;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n    }\n    tick(ticks) {\n        this.active = false;\n        if (!this.mg.isValidRef(this.tile)) {\n            console.warn(`SpawnExecution: tile ${this.tile} not valid`);\n            return;\n        }\n        if (!this.mg.inSpawnPhase()) {\n            this.active = false;\n            return;\n        }\n        let player = null;\n        if (this.mg.hasPlayer(this.playerInfo.id)) {\n            player = this.mg.player(this.playerInfo.id);\n        }\n        else {\n            player = this.mg.addPlayer(this.playerInfo);\n        }\n        player.tiles().forEach((t) => player.relinquish(t));\n        (0,_Util__WEBPACK_IMPORTED_MODULE_3__.getSpawnTiles)(this.mg, this.tile).forEach((t) => {\n            player.conquer(t);\n        });\n        if (!player.hasSpawned()) {\n            this.mg.addExecution(new _PlayerExecution__WEBPACK_IMPORTED_MODULE_2__.PlayerExecution(player));\n            if (player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Bot) {\n                this.mg.addExecution(new _BotExecution__WEBPACK_IMPORTED_MODULE_1__.BotExecution(player));\n            }\n        }\n        player.setHasSpawned(true);\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/SpawnExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/TargetPlayerExecution.ts":
/*!*****************************************************!*\
  !*** ./src/core/execution/TargetPlayerExecution.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TargetPlayerExecution: () => (/* binding */ TargetPlayerExecution)\n/* harmony export */ });\nclass TargetPlayerExecution {\n    constructor(requestor, targetID) {\n        this.requestor = requestor;\n        this.targetID = targetID;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        if (!mg.hasPlayer(this.targetID)) {\n            console.warn(`TargetPlayerExecution: target ${this.targetID} not found`);\n            this.active = false;\n            return;\n        }\n        this.target = mg.player(this.targetID);\n    }\n    tick(ticks) {\n        if (this.requestor.canTarget(this.target)) {\n            this.requestor.target(this.target);\n            this.target.updateRelation(this.requestor, -40);\n        }\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/TargetPlayerExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/TradeShipExecution.ts":
/*!**************************************************!*\
  !*** ./src/core/execution/TradeShipExecution.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TradeShipExecution: () => (/* binding */ TradeShipExecution)\n/* harmony export */ });\n/* harmony import */ var _client_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../client/Utils */ \"./src/client/Utils.ts\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pathfinding/AStar */ \"./src/core/pathfinding/AStar.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n\n\n\n\n\nclass TradeShipExecution {\n    constructor(origOwner, srcPort, _dstPort) {\n        this.origOwner = origOwner;\n        this.srcPort = srcPort;\n        this._dstPort = _dstPort;\n        this.active = true;\n        this.wasCaptured = false;\n        this.tilesTraveled = 0;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        this.pathFinder = _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_3__.PathFinder.Mini(mg, 2500);\n    }\n    tick(ticks) {\n        if (this.tradeShip === undefined) {\n            const spawn = this.origOwner.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.TradeShip, this.srcPort.tile());\n            if (spawn === false) {\n                console.warn(`cannot build trade ship`);\n                this.active = false;\n                return;\n            }\n            this.tradeShip = this.origOwner.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.TradeShip, spawn, {\n                targetUnit: this._dstPort,\n                lastSetSafeFromPirates: ticks,\n            });\n            this.mg.stats().boatSendTrade(this.origOwner, this._dstPort.owner());\n        }\n        if (!this.tradeShip.isActive()) {\n            this.active = false;\n            return;\n        }\n        const tradeShipOwner = this.tradeShip.owner();\n        const dstPortOwner = this._dstPort.owner();\n        if (this.wasCaptured !== true && this.origOwner !== tradeShipOwner) {\n            // Store as variable in case ship is recaptured by previous owner\n            this.wasCaptured = true;\n        }\n        // If a player captures another player's port while trading we should delete\n        // the ship.\n        if (dstPortOwner.id() === this.srcPort.owner().id()) {\n            this.tradeShip.delete(false);\n            this.active = false;\n            return;\n        }\n        if (!this.wasCaptured &&\n            (!this._dstPort.isActive() || !tradeShipOwner.canTrade(dstPortOwner))) {\n            this.tradeShip.delete(false);\n            this.active = false;\n            return;\n        }\n        if (this.wasCaptured &&\n            (tradeShipOwner !== dstPortOwner || !this._dstPort.isActive())) {\n            const ports = this.tradeShip\n                .owner()\n                .units(_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port)\n                .sort((0,_Util__WEBPACK_IMPORTED_MODULE_4__.distSortUnit)(this.mg, this.tradeShip));\n            if (ports.length === 0) {\n                this.tradeShip.delete(false);\n                this.active = false;\n                return;\n            }\n            else {\n                this._dstPort = ports[0];\n                this.tradeShip.setTargetUnit(this._dstPort);\n            }\n        }\n        const curTile = this.tradeShip.tile();\n        if (curTile === this.dstPort()) {\n            this.complete();\n            return;\n        }\n        const result = this.pathFinder.nextTile(curTile, this._dstPort.tile());\n        switch (result.type) {\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.Pending:\n                // Fire unit event to rerender.\n                this.tradeShip.move(curTile);\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.NextTile:\n                // Update safeFromPirates status\n                if (this.mg.isWater(result.node) && this.mg.isShoreline(result.node)) {\n                    this.tradeShip.setSafeFromPirates();\n                }\n                this.tradeShip.move(result.node);\n                this.tilesTraveled++;\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.Completed:\n                this.complete();\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.PathNotFound:\n                console.warn(\"captured trade ship cannot find route\");\n                if (this.tradeShip.isActive()) {\n                    this.tradeShip.delete(false);\n                }\n                this.active = false;\n                break;\n        }\n    }\n    complete() {\n        this.active = false;\n        this.tradeShip.delete(false);\n        const gold = this.mg\n            .config()\n            .tradeShipGold(this.tilesTraveled, this.tradeShip.owner().unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port));\n        if (this.wasCaptured) {\n            this.tradeShip.owner().addGold(gold, this._dstPort.tile());\n            this.mg.displayMessage(`Received ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderNumber)(gold)} gold from ship captured from ${this.origOwner.displayName()}`, _game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.CAPTURED_ENEMY_UNIT, this.tradeShip.owner().id(), gold);\n        }\n        else {\n            this.srcPort.owner().addGold(gold);\n            this._dstPort.owner().addGold(gold, this._dstPort.tile());\n            this.mg.displayMessage(`Received ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderNumber)(gold)} gold from trade with ${this.srcPort.owner().displayName()}`, _game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.RECEIVED_GOLD_FROM_TRADE, this._dstPort.owner().id(), gold);\n            this.mg.displayMessage(`Received ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderNumber)(gold)} gold from trade with ${this._dstPort.owner().displayName()}`, _game_Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.RECEIVED_GOLD_FROM_TRADE, this.srcPort.owner().id(), gold);\n        }\n        return;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    dstPort() {\n        return this._dstPort.tile();\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/TradeShipExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/TrainExecution.ts":
/*!**********************************************!*\
  !*** ./src/core/execution/TrainExecution.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrainExecution: () => (/* binding */ TrainExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _game_Railroad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/Railroad */ \"./src/core/game/Railroad.ts\");\n\n\nclass TrainExecution {\n    constructor(railNetwork, player, source, destination, numCars) {\n        this.railNetwork = railNetwork;\n        this.player = player;\n        this.source = source;\n        this.destination = destination;\n        this.numCars = numCars;\n        this.active = true;\n        this.mg = null;\n        this.train = null;\n        this.cars = [];\n        this.hasCargo = false;\n        this.currentTile = 0;\n        this.spacing = 2;\n        this.usedTiles = []; // used for cars behind\n        this.stations = [];\n        this.currentRailroad = null;\n        this.speed = 2;\n    }\n    owner() {\n        return this.player;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        const stations = this.railNetwork.findStationsPath(this.source, this.destination);\n        if (!stations || stations.length <= 1) {\n            this.active = false;\n            return;\n        }\n        this.stations = stations;\n        const railroad = (0,_game_Railroad__WEBPACK_IMPORTED_MODULE_1__.getOrientedRailroad)(this.stations[0], this.stations[1]);\n        if (railroad) {\n            this.currentRailroad = railroad;\n        }\n        else {\n            this.active = false;\n            return;\n        }\n        const spawn = this.player.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Train, this.stations[0].tile());\n        if (spawn === false) {\n            console.warn(`cannot build train`);\n            this.active = false;\n            return;\n        }\n        this.train = this.createTrainUnits(spawn);\n    }\n    tick(ticks) {\n        if (this.train === null) {\n            throw new Error(\"Not initialized\");\n        }\n        if (!this.train.isActive() || !this.activeSourceOrDestination()) {\n            this.deleteTrain();\n            return;\n        }\n        const tile = this.getNextTile();\n        if (tile) {\n            this.updateCarsPositions(tile);\n        }\n        else {\n            this.targetReached();\n            this.deleteTrain();\n        }\n    }\n    loadCargo() {\n        if (this.hasCargo || this.train === null) {\n            return;\n        }\n        this.hasCargo = true;\n        // Starts at 1: don't load tail engine\n        for (let i = 1; i < this.cars.length; i++) {\n            this.cars[i].setLoaded(true);\n        }\n    }\n    targetReached() {\n        if (this.train === null) {\n            return;\n        }\n        this.train.setReachedTarget();\n        this.cars.forEach((car) => {\n            car.setReachedTarget();\n        });\n    }\n    createTrainUnits(tile) {\n        const train = this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Train, tile, {\n            targetUnit: this.destination.unit,\n            trainType: _game_Game__WEBPACK_IMPORTED_MODULE_0__.TrainType.Engine,\n        });\n        // Tail is also an engine, just for cosmetics\n        this.cars.push(this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Train, tile, {\n            targetUnit: this.destination.unit,\n            trainType: _game_Game__WEBPACK_IMPORTED_MODULE_0__.TrainType.Engine,\n        }));\n        for (let i = 0; i < this.numCars; i++) {\n            this.cars.push(this.player.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Train, tile, {\n                trainType: _game_Game__WEBPACK_IMPORTED_MODULE_0__.TrainType.Carriage,\n                loaded: this.hasCargo,\n            }));\n        }\n        return train;\n    }\n    deleteTrain() {\n        this.active = false;\n        if (this.train?.isActive()) {\n            this.train.delete(false);\n        }\n        for (const car of this.cars) {\n            if (car.isActive()) {\n                car.delete(false);\n            }\n        }\n    }\n    activeSourceOrDestination() {\n        return (this.stations.length > 1 &&\n            this.stations[1].isActive() &&\n            this.stations[0].isActive());\n    }\n    /**\n     * Save the tiles the train go through so the cars can reuse them\n     * Don't simply save the tiles the engine uses, otherwise the spacing will be dictated by the train speed\n     */\n    saveTraversedTiles(from, speed) {\n        if (!this.currentRailroad) {\n            return;\n        }\n        let tileToSave = from;\n        for (let i = 0; i < speed && tileToSave < this.currentRailroad.getTiles().length; i++) {\n            this.saveTile(this.currentRailroad.getTiles()[tileToSave]);\n            tileToSave = tileToSave + 1;\n        }\n    }\n    saveTile(tile) {\n        this.usedTiles.push(tile);\n        if (this.usedTiles.length > this.cars.length * this.spacing + 3) {\n            this.usedTiles.shift();\n        }\n    }\n    updateCarsPositions(newTile) {\n        if (this.cars.length > 0) {\n            for (let i = this.cars.length - 1; i >= 0; --i) {\n                const carTileIndex = (i + 1) * this.spacing + 2;\n                if (this.usedTiles.length > carTileIndex) {\n                    this.cars[i].move(this.usedTiles[carTileIndex]);\n                }\n            }\n        }\n        if (this.train !== null) {\n            this.train.move(newTile);\n        }\n    }\n    nextStation() {\n        if (this.stations.length > 2) {\n            this.stations.shift();\n            const railRoad = (0,_game_Railroad__WEBPACK_IMPORTED_MODULE_1__.getOrientedRailroad)(this.stations[0], this.stations[1]);\n            if (railRoad) {\n                this.currentRailroad = railRoad;\n                return true;\n            }\n        }\n        return false;\n    }\n    canTradeWithDestination() {\n        return (this.stations.length > 1 && this.stations[1].tradeAvailable(this.player));\n    }\n    getNextTile() {\n        if (this.currentRailroad === null || !this.canTradeWithDestination()) {\n            return null;\n        }\n        this.saveTraversedTiles(this.currentTile, this.speed);\n        this.currentTile = this.currentTile + this.speed;\n        const leftOver = this.currentTile - this.currentRailroad.getTiles().length;\n        if (leftOver >= 0) {\n            // Station reached, pick the next station\n            this.stationReached();\n            if (!this.nextStation()) {\n                return null; // Destination reached (or no valid connection)\n            }\n            this.currentTile = leftOver;\n            this.saveTraversedTiles(0, leftOver);\n        }\n        return this.currentRailroad.getTiles()[this.currentTile];\n    }\n    stationReached() {\n        if (this.mg === null || this.player === null) {\n            throw new Error(\"Not initialized\");\n        }\n        this.stations[1].onTrainStop(this);\n        return;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/TrainExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/TrainStationExecution.ts":
/*!*****************************************************!*\
  !*** ./src/core/execution/TrainStationExecution.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TrainStationExecution: () => (/* binding */ TrainStationExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _game_TrainStation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/TrainStation */ \"./src/core/game/TrainStation.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _TrainExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TrainExecution */ \"./src/core/execution/TrainExecution.ts\");\n\n\n\n\nclass TrainStationExecution {\n    constructor(unit, spawnTrains) {\n        this.unit = unit;\n        this.spawnTrains = spawnTrains;\n        this.active = true;\n        this.station = null;\n        this.numCars = 5;\n        this.lastSpawnTick = 0;\n        this.ticksCooldown = 10; // Minimum cooldown between two trains\n        this.unit.setTrainStation(true);\n    }\n    isActive() {\n        return this.active;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        if (this.spawnTrains) {\n            this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_2__.PseudoRandom(mg.ticks());\n        }\n    }\n    tick(ticks) {\n        if (this.mg === undefined) {\n            throw new Error(\"Not initialized\");\n        }\n        if (!this.isActive() || this.unit === undefined) {\n            return;\n        }\n        if (this.station === null) {\n            // Can't create new executions on init, so it has to be done in the tick\n            this.station = new _game_TrainStation__WEBPACK_IMPORTED_MODULE_1__.TrainStation(this.mg, this.unit);\n            this.mg.railNetwork().connectStation(this.station);\n        }\n        if (!this.station.isActive()) {\n            this.active = false;\n            return;\n        }\n        this.spawnTrain(this.station, ticks);\n    }\n    shouldSpawnTrain() {\n        const spawnRate = this.mg\n            .config()\n            .trainSpawnRate(this.unit.owner().unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory));\n        for (let i = 0; i < this.unit.level(); i++) {\n            if (this.random.chance(spawnRate)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    spawnTrain(station, currentTick) {\n        if (this.mg === undefined)\n            throw new Error(\"Not initialized\");\n        if (!this.spawnTrains)\n            return;\n        if (this.random === undefined)\n            throw new Error(\"Not initialized\");\n        if (currentTick < this.lastSpawnTick + this.ticksCooldown)\n            return;\n        const cluster = station.getCluster();\n        if (cluster === null) {\n            return;\n        }\n        const availableForTrade = cluster.availableForTrade(this.unit.owner());\n        if (availableForTrade.size === 0) {\n            return;\n        }\n        if (!this.shouldSpawnTrain()) {\n            return;\n        }\n        // Pick a destination randomly.\n        // Could be improved to pick a lucrative trip\n        const destination = this.random.randFromSet(availableForTrade);\n        if (destination !== station) {\n            this.mg.addExecution(new _TrainExecution__WEBPACK_IMPORTED_MODULE_3__.TrainExecution(this.mg.railNetwork(), this.unit.owner(), station, destination, this.numCars));\n            this.lastSpawnTick = currentTick;\n        }\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/TrainStationExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/TransportShipExecution.ts":
/*!******************************************************!*\
  !*** ./src/core/execution/TransportShipExecution.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransportShipExecution: () => (/* binding */ TransportShipExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _game_TransportShipUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/TransportShipUtils */ \"./src/core/game/TransportShipUtils.ts\");\n/* harmony import */ var _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pathfinding/AStar */ \"./src/core/pathfinding/AStar.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _AttackExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AttackExecution */ \"./src/core/execution/AttackExecution.ts\");\n\n\n\n\n\nclass TransportShipExecution {\n    constructor(attacker, targetID, ref, startTroops, src) {\n        this.attacker = attacker;\n        this.targetID = targetID;\n        this.ref = ref;\n        this.startTroops = startTroops;\n        this.src = src;\n        // TODO: make this configurable\n        this.ticksPerMove = 1;\n        this.active = true;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    init(mg, ticks) {\n        if (this.targetID !== null && !mg.hasPlayer(this.targetID)) {\n            console.warn(`TransportShipExecution: target ${this.targetID} not found`);\n            this.active = false;\n            return;\n        }\n        if (!mg.isValidRef(this.ref)) {\n            console.warn(`TransportShipExecution: ref ${this.ref} not valid`);\n            this.active = false;\n            return;\n        }\n        if (this.src !== null && !mg.isValidRef(this.src)) {\n            console.warn(`TransportShipExecution: src ${this.src} not valid`);\n            this.active = false;\n            return;\n        }\n        this.lastMove = ticks;\n        this.mg = mg;\n        this.pathFinder = _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_3__.PathFinder.Mini(mg, 10000, true, 100);\n        if (this.attacker.unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip) >=\n            mg.config().boatMaxNumber()) {\n            mg.displayMessage(`No boats available, max ${mg.config().boatMaxNumber()}`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.ATTACK_FAILED, this.attacker.id());\n            this.active = false;\n            return;\n        }\n        if (this.targetID === null ||\n            this.targetID === this.mg.terraNullius().id()) {\n            this.target = mg.terraNullius();\n        }\n        else {\n            this.target = mg.player(this.targetID);\n        }\n        this.startTroops ?? (this.startTroops = this.mg\n            .config()\n            .boatAttackAmount(this.attacker, this.target));\n        this.startTroops = Math.min(this.startTroops, this.attacker.troops());\n        this.dst = (0,_game_TransportShipUtils__WEBPACK_IMPORTED_MODULE_1__.targetTransportTile)(this.mg, this.ref);\n        if (this.dst === null) {\n            console.warn(`${this.attacker} cannot send ship to ${this.target}, cannot find attack tile`);\n            this.active = false;\n            return;\n        }\n        const closestTileSrc = this.attacker.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip, this.dst);\n        if (closestTileSrc === false) {\n            console.warn(`can't build transport ship`);\n            this.active = false;\n            return;\n        }\n        if (this.src === null) {\n            // Only update the src if it's not already set\n            // because we assume that the src is set to the best spawn tile\n            this.src = closestTileSrc;\n        }\n        else {\n            if (this.mg.owner(this.src) !== this.attacker ||\n                !this.mg.isShore(this.src)) {\n                console.warn(`src is not a shore tile or not owned by: ${this.attacker.name()}`);\n                this.src = closestTileSrc;\n            }\n        }\n        this.boat = this.attacker.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip, this.src, {\n            troops: this.startTroops,\n        });\n        if (this.dst !== null) {\n            this.boat.setTargetTile(this.dst);\n        }\n        else {\n            this.boat.setTargetTile(undefined);\n        }\n        // Notify the target player about the incoming naval invasion\n        if (this.targetID && this.targetID !== mg.terraNullius().id()) {\n            mg.displayIncomingUnit(this.boat.id(), \n            // TODO TranslateText\n            `Naval invasion incoming from ${this.attacker.displayName()}`, _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.NAVAL_INVASION_INBOUND, this.targetID);\n        }\n        // Record stats\n        this.mg\n            .stats()\n            .boatSendTroops(this.attacker, this.target, this.boat.troops());\n    }\n    tick(ticks) {\n        if (this.dst === null) {\n            this.active = false;\n            return;\n        }\n        if (!this.active) {\n            return;\n        }\n        if (!this.boat.isActive()) {\n            this.active = false;\n            return;\n        }\n        if (ticks - this.lastMove < this.ticksPerMove) {\n            return;\n        }\n        this.lastMove = ticks;\n        if (this.boat.retreating()) {\n            this.dst = this.src; // src is guaranteed to be set at this point\n            if (this.boat.targetTile() !== this.dst) {\n                this.boat.setTargetTile(this.dst);\n            }\n        }\n        const result = this.pathFinder.nextTile(this.boat.tile(), this.dst);\n        switch (result.type) {\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.Completed:\n                if (this.mg.owner(this.dst) === this.attacker) {\n                    this.attacker.addTroops(this.boat.troops());\n                    this.boat.delete(false);\n                    this.active = false;\n                    // Record stats\n                    this.mg\n                        .stats()\n                        .boatArriveTroops(this.attacker, this.target, this.boat.troops());\n                    return;\n                }\n                this.attacker.conquer(this.dst);\n                if (this.target.isPlayer() && this.attacker.isFriendly(this.target)) {\n                    this.attacker.addTroops(this.boat.troops());\n                }\n                else {\n                    this.mg.addExecution(new _AttackExecution__WEBPACK_IMPORTED_MODULE_4__.AttackExecution(this.boat.troops(), this.attacker, this.targetID, this.dst, false));\n                }\n                this.boat.delete(false);\n                this.active = false;\n                // Record stats\n                this.mg\n                    .stats()\n                    .boatArriveTroops(this.attacker, this.target, this.boat.troops());\n                return;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.NextTile:\n                this.boat.move(result.node);\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.Pending:\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_2__.PathFindResultType.PathNotFound:\n                // TODO: add to poisoned port list\n                console.warn(`path not found to dst`);\n                this.attacker.addTroops(this.boat.troops());\n                this.boat.delete(false);\n                this.active = false;\n                return;\n        }\n    }\n    owner() {\n        return this.attacker;\n    }\n    isActive() {\n        return this.active;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/TransportShipExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/UpgradeStructureExecution.ts":
/*!*********************************************************!*\
  !*** ./src/core/execution/UpgradeStructureExecution.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UpgradeStructureExecution: () => (/* binding */ UpgradeStructureExecution)\n/* harmony export */ });\nclass UpgradeStructureExecution {\n    constructor(player, unitId) {\n        this.player = player;\n        this.unitId = unitId;\n    }\n    init(mg, ticks) {\n        this.structure = this.player\n            .units()\n            .find((unit) => unit.id() === this.unitId);\n        if (this.structure === undefined) {\n            console.warn(`structure is undefined`);\n            return;\n        }\n        if (!this.player.canUpgradeUnit(this.structure.type())) {\n            console.warn(`[UpgradeStructureExecution] unit type ${this.structure.type()} cannot be upgraded`);\n            return;\n        }\n        this.player.upgradeUnit(this.structure);\n        return;\n    }\n    tick(ticks) {\n        return;\n    }\n    isActive() {\n        return false;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/UpgradeStructureExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/Util.ts":
/*!************************************!*\
  !*** ./src/core/execution/Util.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestTile: () => (/* binding */ closestTile),\n/* harmony export */   closestTwoTiles: () => (/* binding */ closestTwoTiles),\n/* harmony export */   getSpawnTiles: () => (/* binding */ getSpawnTiles)\n/* harmony export */ });\n/* harmony import */ var _game_GameMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/GameMap */ \"./src/core/game/GameMap.ts\");\n\nfunction getSpawnTiles(gm, tile) {\n    return Array.from(gm.bfs(tile, (0,_game_GameMap__WEBPACK_IMPORTED_MODULE_0__.euclDistFN)(tile, 4, true))).filter((t) => !gm.hasOwner(t) && gm.isLand(t));\n}\nfunction closestTile(gm, refs, tile) {\n    let minDistance = Infinity;\n    let minRef = null;\n    for (const ref of refs) {\n        const distance = gm.manhattanDist(ref, tile);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minRef = ref;\n        }\n    }\n    return [minRef, minDistance];\n}\nfunction closestTwoTiles(gm, x, y) {\n    const xSorted = Array.from(x).sort((a, b) => gm.x(a) - gm.x(b));\n    const ySorted = Array.from(y).sort((a, b) => gm.x(a) - gm.x(b));\n    if (xSorted.length === 0 || ySorted.length === 0) {\n        return null;\n    }\n    let i = 0;\n    let j = 0;\n    let minDistance = Infinity;\n    let result = { x: xSorted[0], y: ySorted[0] };\n    while (i < xSorted.length && j < ySorted.length) {\n        const currentX = xSorted[i];\n        const currentY = ySorted[j];\n        const distance = Math.abs(gm.x(currentX) - gm.x(currentY)) +\n            Math.abs(gm.y(currentX) - gm.y(currentY));\n        if (distance < minDistance) {\n            minDistance = distance;\n            result = { x: currentX, y: currentY };\n        }\n        // If we're at the end of X, must move Y forward\n        if (i === xSorted.length - 1) {\n            j++;\n        }\n        // If we're at the end of Y, must move X forward\n        else if (j === ySorted.length - 1) {\n            i++;\n        }\n        // Otherwise, move whichever pointer has smaller x value\n        else if (gm.x(currentX) < gm.x(currentY)) {\n            i++;\n        }\n        else {\n            j++;\n        }\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/Util.ts?\n}");

/***/ }),

/***/ "./src/core/execution/WarshipExecution.ts":
/*!************************************************!*\
  !*** ./src/core/execution/WarshipExecution.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WarshipExecution: () => (/* binding */ WarshipExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/AStar */ \"./src/core/pathfinding/AStar.ts\");\n/* harmony import */ var _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pathfinding/PathFinding */ \"./src/core/pathfinding/PathFinding.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _ShellExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShellExecution */ \"./src/core/execution/ShellExecution.ts\");\n\n\n\n\n\nclass WarshipExecution {\n    constructor(input) {\n        this.input = input;\n        this.lastShellAttack = 0;\n        this.alreadySentShell = new Set();\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        this.pathfinder = _pathfinding_PathFinding__WEBPACK_IMPORTED_MODULE_2__.PathFinder.Mini(mg, 10000, true, 100);\n        this.random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_3__.PseudoRandom(mg.ticks());\n        if ((0,_game_Game__WEBPACK_IMPORTED_MODULE_0__.isUnit)(this.input)) {\n            this.warship = this.input;\n        }\n        else {\n            const spawn = this.input.owner.canBuild(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship, this.input.patrolTile);\n            if (spawn === false) {\n                console.warn(`Failed to spawn warship for ${this.input.owner.name()} at ${this.input.patrolTile}`);\n                return;\n            }\n            this.warship = this.input.owner.buildUnit(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship, spawn, this.input);\n        }\n    }\n    tick(ticks) {\n        if (this.warship.health() <= 0) {\n            this.warship.delete();\n            return;\n        }\n        if (this.warship.owner().isDisconnected()) {\n            this.warship.delete();\n            return;\n        }\n        const hasPort = this.warship.owner().unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port) > 0;\n        if (hasPort) {\n            this.warship.modifyHealth(1);\n        }\n        this.warship.setTargetUnit(this.findTargetUnit());\n        if (this.warship.targetUnit()?.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TradeShip) {\n            this.huntDownTradeShip();\n            return;\n        }\n        this.patrol();\n        if (this.warship.targetUnit() !== undefined) {\n            this.shootTarget();\n            return;\n        }\n    }\n    findTargetUnit() {\n        const hasPort = this.warship.owner().unitCount(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port) > 0;\n        const patrolRangeSquared = this.mg.config().warshipPatrolRange() ** 2;\n        const ships = this.mg.nearbyUnits(this.warship.tile(), this.mg.config().warshipTargettingRange(), [_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship, _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TradeShip]);\n        const potentialTargets = [];\n        for (const { unit, distSquared } of ships) {\n            if (unit.owner() === this.warship.owner() ||\n                unit === this.warship ||\n                unit.owner().isFriendly(this.warship.owner()) ||\n                this.alreadySentShell.has(unit)) {\n                continue;\n            }\n            if (unit.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TradeShip) {\n                if (!hasPort ||\n                    unit.isSafeFromPirates() ||\n                    unit.targetUnit()?.owner() === this.warship.owner() || // trade ship is coming to my port\n                    unit.targetUnit()?.owner().isFriendly(this.warship.owner()) // trade ship is coming to my ally\n                ) {\n                    continue;\n                }\n                if (this.mg.euclideanDistSquared(this.warship.patrolTile(), unit.tile()) > patrolRangeSquared) {\n                    // Prevent warship from chasing trade ship that is too far away from\n                    // the patrol tile to prevent warships from wandering around the map.\n                    continue;\n                }\n            }\n            potentialTargets.push({ unit: unit, distSquared });\n        }\n        return potentialTargets.sort((a, b) => {\n            const { unit: unitA, distSquared: distA } = a;\n            const { unit: unitB, distSquared: distB } = b;\n            // Prioritize Transport Ships above all other units\n            if (unitA.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip &&\n                unitB.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip)\n                return -1;\n            if (unitA.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip &&\n                unitB.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip)\n                return 1;\n            // Then prioritize Warships.\n            if (unitA.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship &&\n                unitB.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship)\n                return -1;\n            if (unitA.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship &&\n                unitB.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Warship)\n                return 1;\n            // If both are the same type, sort by distance (lower `distSquared` means closer)\n            return distA - distB;\n        })[0]?.unit;\n    }\n    shootTarget() {\n        const shellAttackRate = this.mg.config().warshipShellAttackRate();\n        if (this.mg.ticks() - this.lastShellAttack > shellAttackRate) {\n            if (this.warship.targetUnit()?.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.TransportShip) {\n                // Warships don't need to reload when attacking transport ships.\n                this.lastShellAttack = this.mg.ticks();\n            }\n            this.mg.addExecution(new _ShellExecution__WEBPACK_IMPORTED_MODULE_4__.ShellExecution(this.warship.tile(), this.warship.owner(), this.warship, this.warship.targetUnit()));\n            if (!this.warship.targetUnit().hasHealth()) {\n                // Don't send multiple shells to target that can be oneshotted\n                this.alreadySentShell.add(this.warship.targetUnit());\n                this.warship.setTargetUnit(undefined);\n                return;\n            }\n        }\n    }\n    huntDownTradeShip() {\n        for (let i = 0; i < 2; i++) {\n            // target is trade ship so capture it.\n            const result = this.pathfinder.nextTile(this.warship.tile(), this.warship.targetUnit().tile(), 5);\n            switch (result.type) {\n                case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed:\n                    this.warship.owner().captureUnit(this.warship.targetUnit());\n                    this.warship.setTargetUnit(undefined);\n                    this.warship.move(this.warship.tile());\n                    return;\n                case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.NextTile:\n                    this.warship.move(result.node);\n                    break;\n                case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Pending:\n                    this.warship.touch();\n                    break;\n                case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound:\n                    console.log(`path not found to target`);\n                    break;\n            }\n        }\n    }\n    patrol() {\n        if (this.warship.targetTile() === undefined) {\n            this.warship.setTargetTile(this.randomTile());\n            if (this.warship.targetTile() === undefined) {\n                return;\n            }\n        }\n        const result = this.pathfinder.nextTile(this.warship.tile(), this.warship.targetTile());\n        switch (result.type) {\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed:\n                this.warship.setTargetTile(undefined);\n                this.warship.move(result.node);\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.NextTile:\n                this.warship.move(result.node);\n                break;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Pending:\n                this.warship.touch();\n                return;\n            case _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound:\n                console.warn(`path not found to target tile`);\n                this.warship.setTargetTile(undefined);\n                break;\n        }\n    }\n    isActive() {\n        return this.warship?.isActive();\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n    randomTile(allowShoreline = false) {\n        let warshipPatrolRange = this.mg.config().warshipPatrolRange();\n        const maxAttemptBeforeExpand = 500;\n        let attempts = 0;\n        let expandCount = 0;\n        while (expandCount < 3) {\n            const x = this.mg.x(this.warship.patrolTile()) +\n                this.random.nextInt(-warshipPatrolRange / 2, warshipPatrolRange / 2);\n            const y = this.mg.y(this.warship.patrolTile()) +\n                this.random.nextInt(-warshipPatrolRange / 2, warshipPatrolRange / 2);\n            if (!this.mg.isValidCoord(x, y)) {\n                continue;\n            }\n            const tile = this.mg.ref(x, y);\n            if (!this.mg.isOcean(tile) ||\n                (!allowShoreline && this.mg.isShoreline(tile))) {\n                attempts++;\n                if (attempts === maxAttemptBeforeExpand) {\n                    expandCount++;\n                    attempts = 0;\n                    warshipPatrolRange =\n                        warshipPatrolRange + Math.floor(warshipPatrolRange / 2);\n                }\n                continue;\n            }\n            return tile;\n        }\n        console.warn(`Failed to find random tile for warship for ${this.warship.owner().name()}`);\n        if (!allowShoreline) {\n            // If we failed to find a tile on the ocean, try again but allow shoreline\n            return this.randomTile(true);\n        }\n        return undefined;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/WarshipExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/WinCheckExecution.ts":
/*!*************************************************!*\
  !*** ./src/core/execution/WinCheckExecution.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WinCheckExecution: () => (/* binding */ WinCheckExecution),\n/* harmony export */   WinEvent: () => (/* binding */ WinEvent)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n\nclass WinEvent {\n    constructor(winner) {\n        this.winner = winner;\n    }\n}\nclass WinCheckExecution {\n    constructor() {\n        this.active = true;\n        this.mg = null;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n    }\n    tick(ticks) {\n        if (ticks % 10 !== 0) {\n            return;\n        }\n        if (this.mg === null)\n            throw new Error(\"Not initialized\");\n        if (this.mg.config().gameConfig().gameMode === _game_Game__WEBPACK_IMPORTED_MODULE_0__.GameMode.FFA) {\n            this.checkWinnerFFA();\n        }\n        else {\n            this.checkWinnerTeam();\n        }\n    }\n    checkWinnerFFA() {\n        if (this.mg === null)\n            throw new Error(\"Not initialized\");\n        const sorted = this.mg\n            .players()\n            .sort((a, b) => b.numTilesOwned() - a.numTilesOwned());\n        if (sorted.length === 0) {\n            return;\n        }\n        const max = sorted[0];\n        const timeElapsed = (this.mg.ticks() - this.mg.config().numSpawnPhaseTurns()) / 10;\n        const numTilesWithoutFallout = this.mg.numLandTiles() - this.mg.numTilesWithFallout();\n        if ((max.numTilesOwned() / numTilesWithoutFallout) * 100 >\n            this.mg.config().percentageTilesOwnedToWin() ||\n            (this.mg.config().gameConfig().maxTimerValue !== undefined &&\n                timeElapsed - this.mg.config().gameConfig().maxTimerValue * 60 >= 0)) {\n            this.mg.setWinner(max, this.mg.stats().stats());\n            console.log(`${max.name()} has won the game`);\n            this.active = false;\n        }\n    }\n    checkWinnerTeam() {\n        if (this.mg === null)\n            throw new Error(\"Not initialized\");\n        const teamToTiles = new Map();\n        for (const player of this.mg.players()) {\n            const team = player.team();\n            // Sanity check, team should not be null here\n            if (team === null)\n                continue;\n            teamToTiles.set(team, (teamToTiles.get(team) ?? 0) + player.numTilesOwned());\n        }\n        const sorted = Array.from(teamToTiles.entries()).sort((a, b) => b[1] - a[1]);\n        if (sorted.length === 0) {\n            return;\n        }\n        const max = sorted[0];\n        const timeElapsed = (this.mg.ticks() - this.mg.config().numSpawnPhaseTurns()) / 10;\n        const numTilesWithoutFallout = this.mg.numLandTiles() - this.mg.numTilesWithFallout();\n        const percentage = (max[1] / numTilesWithoutFallout) * 100;\n        if (percentage > this.mg.config().percentageTilesOwnedToWin() ||\n            (this.mg.config().gameConfig().maxTimerValue !== undefined &&\n                timeElapsed - this.mg.config().gameConfig().maxTimerValue * 60 >= 0)) {\n            if (max[0] === _game_Game__WEBPACK_IMPORTED_MODULE_0__.ColoredTeams.Bot)\n                return;\n            this.mg.setWinner(max[0], this.mg.stats().stats());\n            console.log(`${max[0]} has won the game`);\n            this.active = false;\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/WinCheckExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/alliance/AllianceExtensionExecution.ts":
/*!*******************************************************************!*\
  !*** ./src/core/execution/alliance/AllianceExtensionExecution.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllianceExtensionExecution: () => (/* binding */ AllianceExtensionExecution)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/Game */ \"./src/core/game/Game.ts\");\n\nclass AllianceExtensionExecution {\n    constructor(from, toID) {\n        this.from = from;\n        this.toID = toID;\n    }\n    init(mg, ticks) {\n        if (!mg.hasPlayer(this.toID)) {\n            console.warn(`[AllianceExtensionExecution] Player ${this.toID} not found`);\n            return;\n        }\n        const to = mg.player(this.toID);\n        if (!this.from.isAlive() || !to.isAlive()) {\n            console.info(`[AllianceExtensionExecution] Player ${this.from.id()} or ${this.toID} is not alive`);\n            return;\n        }\n        const alliance = this.from.allianceWith(to);\n        if (!alliance) {\n            console.warn(`[AllianceExtensionExecution] No alliance to extend between ${this.from.id()} and ${this.toID}`);\n            return;\n        }\n        // Mark this player's intent to extend\n        alliance.addExtensionRequest(this.from);\n        if (alliance.bothAgreedToExtend()) {\n            alliance.extend();\n            mg.displayMessage(\"events_display.alliance_renewed\", _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.ALLIANCE_ACCEPTED, this.from.id(), undefined, { name: to.displayName() });\n            mg.displayMessage(\"events_display.alliance_renewed\", _game_Game__WEBPACK_IMPORTED_MODULE_0__.MessageType.ALLIANCE_ACCEPTED, this.toID, undefined, { name: this.from.displayName() });\n        }\n    }\n    tick(ticks) {\n        // No-op\n    }\n    isActive() {\n        return false;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/alliance/AllianceExtensionExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/alliance/AllianceRequestExecution.ts":
/*!*****************************************************************!*\
  !*** ./src/core/execution/alliance/AllianceRequestExecution.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllianceRequestExecution: () => (/* binding */ AllianceRequestExecution)\n/* harmony export */ });\nclass AllianceRequestExecution {\n    constructor(requestor, recipientID) {\n        this.requestor = requestor;\n        this.recipientID = recipientID;\n        this.req = null;\n        this.active = true;\n    }\n    init(mg, ticks) {\n        this.mg = mg;\n        if (!mg.hasPlayer(this.recipientID)) {\n            console.warn(`AllianceRequestExecution recipient ${this.recipientID} not found`);\n            return;\n        }\n        const recipient = mg.player(this.recipientID);\n        if (!this.requestor.canSendAllianceRequest(recipient)) {\n            console.warn(\"cannot send alliance request\");\n            this.active = false;\n        }\n        else {\n            const incoming = recipient\n                .outgoingAllianceRequests()\n                .find((r) => r.recipient() === this.requestor);\n            if (incoming) {\n                // If the recipient already has pending alliance request,\n                // then accept it instead of creating a new one.\n                this.active = false;\n                incoming.accept();\n            }\n            else {\n                this.req = this.requestor.createAllianceRequest(recipient);\n            }\n        }\n    }\n    tick(ticks) {\n        if (this.req?.status() === \"accepted\" ||\n            this.req?.status() === \"rejected\") {\n            this.active = false;\n            return;\n        }\n        if (this.mg.ticks() - (this.req?.createdAt() ?? 0) >\n            this.mg.config().allianceRequestDuration()) {\n            this.req?.reject();\n            this.active = false;\n        }\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/alliance/AllianceRequestExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/alliance/AllianceRequestReplyExecution.ts":
/*!**********************************************************************!*\
  !*** ./src/core/execution/alliance/AllianceRequestReplyExecution.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllianceRequestReplyExecution: () => (/* binding */ AllianceRequestReplyExecution)\n/* harmony export */ });\nclass AllianceRequestReplyExecution {\n    constructor(requestorID, recipient, accept) {\n        this.requestorID = requestorID;\n        this.recipient = recipient;\n        this.accept = accept;\n        this.active = true;\n        this.requestor = null;\n    }\n    init(mg, ticks) {\n        if (!mg.hasPlayer(this.requestorID)) {\n            console.warn(`AllianceRequestReplyExecution requester ${this.requestorID} not found`);\n            this.active = false;\n            return;\n        }\n        this.requestor = mg.player(this.requestorID);\n    }\n    tick(ticks) {\n        if (this.requestor === null) {\n            throw new Error(\"Not initialized\");\n        }\n        if (this.requestor.isFriendly(this.recipient)) {\n            console.warn(\"already allied\");\n        }\n        else {\n            const request = this.requestor\n                .outgoingAllianceRequests()\n                .find((ar) => ar.recipient() === this.recipient);\n            if (request === undefined) {\n                console.warn(\"no alliance request found\");\n            }\n            else {\n                if (this.accept) {\n                    request.accept();\n                    this.requestor.updateRelation(this.recipient, 100);\n                    this.recipient.updateRelation(this.requestor, 100);\n                }\n                else {\n                    request.reject();\n                }\n            }\n        }\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/alliance/AllianceRequestReplyExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/alliance/BreakAllianceExecution.ts":
/*!***************************************************************!*\
  !*** ./src/core/execution/alliance/BreakAllianceExecution.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BreakAllianceExecution: () => (/* binding */ BreakAllianceExecution)\n/* harmony export */ });\nclass BreakAllianceExecution {\n    constructor(requestor, recipientID) {\n        this.requestor = requestor;\n        this.recipientID = recipientID;\n        this.active = true;\n        this.recipient = null;\n        this.mg = null;\n    }\n    init(mg, ticks) {\n        if (!mg.hasPlayer(this.recipientID)) {\n            console.warn(`BreakAllianceExecution: recipient ${this.recipientID} not found`);\n            this.active = false;\n            return;\n        }\n        this.recipient = mg.player(this.recipientID);\n        this.mg = mg;\n    }\n    tick(ticks) {\n        if (this.mg === null ||\n            this.requestor === null ||\n            this.recipient === null) {\n            throw new Error(\"Not initialized\");\n        }\n        const alliance = this.requestor.allianceWith(this.recipient);\n        if (alliance === null) {\n            console.warn(\"cant break alliance, not allied\");\n        }\n        else {\n            this.requestor.breakAlliance(alliance);\n            this.recipient.updateRelation(this.requestor, -200);\n            for (const player of this.mg.players()) {\n                if (player !== this.requestor && !player.isOnSameTeam(this.requestor)) {\n                    player.updateRelation(this.requestor, -40);\n                }\n            }\n        }\n        this.active = false;\n    }\n    isActive() {\n        return this.active;\n    }\n    activeDuringSpawnPhase() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/alliance/BreakAllianceExecution.ts?\n}");

/***/ }),

/***/ "./src/core/execution/nation/structureSpawnTileValue.ts":
/*!**************************************************************!*\
  !*** ./src/core/execution/nation/structureSpawnTileValue.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   structureSpawnTileValue: () => (/* binding */ structureSpawnTileValue)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/execution/Util.ts\");\n\n\nfunction structureSpawnTileValue(mg, player, type) {\n    const borderTiles = player.borderTiles();\n    const otherUnits = player.units(type);\n    // Prefer spacing structures out of atom bomb range\n    const borderSpacing = mg.config().nukeMagnitudes(_game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.AtomBomb).outer;\n    const structureSpacing = borderSpacing * 2;\n    switch (type) {\n        case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City:\n        case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory:\n        case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo: {\n            return (tile) => {\n                let w = 0;\n                // Prefer higher elevations\n                w += mg.magnitude(tile);\n                // Prefer to be away from the border\n                const [, closestBorderDist] = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTile)(mg, borderTiles, tile);\n                w += Math.min(closestBorderDist, borderSpacing);\n                // Prefer to be away from other structures of the same type\n                const otherTiles = new Set(otherUnits.map((u) => u.tile()));\n                otherTiles.delete(tile);\n                const closestOther = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTwoTiles)(mg, otherTiles, [tile]);\n                if (closestOther !== null) {\n                    const d = mg.manhattanDist(closestOther.x, tile);\n                    w += Math.min(d, structureSpacing);\n                }\n                // TODO: Cities and factories should consider train range limits\n                return w;\n            };\n        }\n        case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port: {\n            return (tile) => {\n                let w = 0;\n                // Prefer to be away from other structures of the same type\n                const otherTiles = new Set(otherUnits.map((u) => u.tile()));\n                otherTiles.delete(tile);\n                const [, closestOtherDist] = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTile)(mg, otherTiles, tile);\n                w += Math.min(closestOtherDist, structureSpacing);\n                return w;\n            };\n        }\n        case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.DefensePost: {\n            return (tile) => {\n                let w = 0;\n                // Prefer higher elevations\n                w += mg.magnitude(tile);\n                const [closest, closestBorderDist] = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTile)(mg, borderTiles, tile);\n                if (closest !== null) {\n                    // Prefer to be borderSpacing tiles from the border\n                    w += Math.max(0, borderSpacing - Math.abs(borderSpacing - closestBorderDist));\n                    // Prefer adjacent players who are hostile\n                    const neighbors = new Set();\n                    for (const tile of mg.neighbors(closest)) {\n                        if (!mg.isLand(tile))\n                            continue;\n                        const id = mg.ownerID(tile);\n                        if (id === player.smallID())\n                            continue;\n                        const neighbor = mg.playerBySmallID(id);\n                        if (!neighbor.isPlayer())\n                            continue;\n                        neighbors.add(neighbor);\n                    }\n                    for (const neighbor of neighbors) {\n                        w +=\n                            borderSpacing * (_game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Friendly - player.relation(neighbor));\n                    }\n                }\n                // Prefer to be away from other structures of the same type\n                const otherTiles = new Set(otherUnits.map((u) => u.tile()));\n                otherTiles.delete(tile);\n                const closestOther = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTwoTiles)(mg, otherTiles, [tile]);\n                if (closestOther !== null) {\n                    const d = mg.manhattanDist(closestOther.x, tile);\n                    w += Math.min(d, structureSpacing);\n                }\n                return w;\n            };\n        }\n        case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.SAMLauncher: {\n            const protectTiles = new Set();\n            for (const unit of player.units()) {\n                switch (unit.type()) {\n                    case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.City:\n                    case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Factory:\n                    case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.MissileSilo:\n                    case _game_Game__WEBPACK_IMPORTED_MODULE_0__.UnitType.Port:\n                        protectTiles.add(unit.tile());\n                }\n            }\n            const range = mg.config().defaultSamRange();\n            const rangeSquared = range * range;\n            return (tile) => {\n                let w = 0;\n                // Prefer higher elevations\n                w += mg.magnitude(tile);\n                // Prefer to be away from the border\n                const closestBorder = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTwoTiles)(mg, borderTiles, [tile]);\n                if (closestBorder !== null) {\n                    const d = mg.manhattanDist(closestBorder.x, tile);\n                    w += Math.min(d, borderSpacing);\n                }\n                // Prefer to be away from other structures of the same type\n                const otherTiles = new Set(otherUnits.map((u) => u.tile()));\n                otherTiles.delete(tile);\n                const closestOther = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.closestTwoTiles)(mg, otherTiles, [tile]);\n                if (closestOther !== null) {\n                    const d = mg.manhattanDist(closestOther.x, tile);\n                    w += Math.min(d, structureSpacing);\n                }\n                // Prefer to be in range of other structures\n                for (const maybeProtected of protectTiles) {\n                    const distanceSquared = mg.euclideanDistSquared(tile, maybeProtected);\n                    if (distanceSquared > rangeSquared)\n                        continue;\n                    w += structureSpacing;\n                }\n                return w;\n            };\n        }\n        default:\n            throw new Error(`Value function not implemented for ${type}`);\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/nation/structureSpawnTileValue.ts?\n}");

/***/ }),

/***/ "./src/core/execution/utils/BotBehavior.ts":
/*!*************************************************!*\
  !*** ./src/core/execution/utils/BotBehavior.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BotBehavior: () => (/* binding */ BotBehavior),\n/* harmony export */   EMOJI_HECKLE: () => (/* binding */ EMOJI_HECKLE)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _alliance_AllianceExtensionExecution__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../alliance/AllianceExtensionExecution */ \"./src/core/execution/alliance/AllianceExtensionExecution.ts\");\n/* harmony import */ var _AttackExecution__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../AttackExecution */ \"./src/core/execution/AttackExecution.ts\");\n/* harmony import */ var _EmojiExecution__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../EmojiExecution */ \"./src/core/execution/EmojiExecution.ts\");\n\n\n\n\n\nconst emojiId = (e) => _Util__WEBPACK_IMPORTED_MODULE_1__.flattenedEmojiTable.indexOf(e);\nconst EMOJI_ASSIST_ACCEPT = [\"ðŸ‘\", \"â›µ\", \"ðŸ¤\", \"ðŸŽ¯\"].map(emojiId);\nconst EMOJI_RELATION_TOO_LOW = [\"ðŸ¥±\", \"ðŸ¤¦â€â™‚ï¸\"].map(emojiId);\nconst EMOJI_TARGET_ME = [\"ðŸ¥º\", \"ðŸ’€\"].map(emojiId);\nconst EMOJI_TARGET_ALLY = [\"ðŸ•Šï¸\", \"ðŸ‘Ž\"].map(emojiId);\nconst EMOJI_HECKLE = [\"ðŸ¤¡\", \"ðŸ˜¡\"].map(emojiId);\nclass BotBehavior {\n    constructor(random, game, player, triggerRatio, reserveRatio, expandRatio) {\n        this.random = random;\n        this.game = game;\n        this.player = player;\n        this.triggerRatio = triggerRatio;\n        this.reserveRatio = reserveRatio;\n        this.expandRatio = expandRatio;\n        this.enemy = null;\n    }\n    handleAllianceRequests() {\n        for (const req of this.player.incomingAllianceRequests()) {\n            if (shouldAcceptAllianceRequest(this.player, req)) {\n                req.accept();\n            }\n            else {\n                req.reject();\n            }\n        }\n    }\n    handleAllianceExtensionRequests() {\n        for (const alliance of this.player.alliances()) {\n            // Alliance expiration tracked by Events Panel, only human ally can click Request to Renew\n            // Skip if no expiration yet/ ally didn't request extension yet/ bot already agreed to extend\n            if (!alliance.onlyOneAgreedToExtend())\n                continue;\n            // Nation is either Friendly or Neutral as an ally. Bot has no attitude\n            // If Friendly or Bot, always agree to extend. If Neutral, have random chance decide\n            const human = alliance.other(this.player);\n            if (this.player.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.FakeHuman &&\n                this.player.relation(human) === _game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Neutral) {\n                if (!this.random.chance(1.5))\n                    continue;\n            }\n            this.game.addExecution(new _alliance_AllianceExtensionExecution__WEBPACK_IMPORTED_MODULE_2__.AllianceExtensionExecution(this.player, human.id()));\n        }\n    }\n    emoji(player, emoji) {\n        if (player.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Human)\n            return;\n        this.game.addExecution(new _EmojiExecution__WEBPACK_IMPORTED_MODULE_4__.EmojiExecution(this.player, player.id(), emoji));\n    }\n    setNewEnemy(newEnemy, force = false) {\n        if (newEnemy !== null && !force && !this.shouldAttack(newEnemy))\n            return;\n        this.enemy = newEnemy;\n        this.enemyUpdated = this.game.ticks();\n    }\n    shouldAttack(other) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        if (this.player.isOnSameTeam(other)) {\n            return false;\n        }\n        const shouldAttack = this.attackChance(other);\n        if (shouldAttack && this.player.isAlliedWith(other)) {\n            this.betray(other);\n            return true;\n        }\n        return shouldAttack;\n    }\n    betray(target) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        const alliance = this.player.allianceWith(target);\n        if (!alliance)\n            return;\n        this.player.breakAlliance(alliance);\n    }\n    attackChance(other) {\n        if (this.player === null)\n            throw new Error(\"not initialized\");\n        if (this.player.isAlliedWith(other)) {\n            return this.shouldDiscourageAttack(other)\n                ? this.random.chance(200)\n                : this.random.chance(50);\n        }\n        else {\n            return this.shouldDiscourageAttack(other) ? this.random.chance(4) : true;\n        }\n    }\n    shouldDiscourageAttack(other) {\n        if (other.isTraitor()) {\n            return false;\n        }\n        const { difficulty } = this.game.config().gameConfig();\n        if (difficulty === _game_Game__WEBPACK_IMPORTED_MODULE_0__.Difficulty.Hard ||\n            difficulty === _game_Game__WEBPACK_IMPORTED_MODULE_0__.Difficulty.Impossible) {\n            return false;\n        }\n        if (other.type() !== _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Human) {\n            return false;\n        }\n        // Only discourage attacks on Humans who are not traitors on easy or medium difficulty.\n        return true;\n    }\n    clearEnemy() {\n        this.enemy = null;\n    }\n    forgetOldEnemies() {\n        // Forget old enemies\n        if (this.game.ticks() - (this.enemyUpdated ?? 0) > 100) {\n            this.clearEnemy();\n        }\n    }\n    hasReserveRatioTroops() {\n        const maxTroops = this.game.config().maxTroops(this.player);\n        const ratio = this.player.troops() / maxTroops;\n        return ratio >= this.reserveRatio;\n    }\n    hasTriggerRatioTroops() {\n        const maxTroops = this.game.config().maxTroops(this.player);\n        const ratio = this.player.troops() / maxTroops;\n        return ratio >= this.triggerRatio;\n    }\n    checkIncomingAttacks() {\n        // Switch enemies if we're under attack\n        const incomingAttacks = this.player.incomingAttacks();\n        let largestAttack = 0;\n        let largestAttacker;\n        for (const attack of incomingAttacks) {\n            if (attack.troops() <= largestAttack)\n                continue;\n            largestAttack = attack.troops();\n            largestAttacker = attack.attacker();\n        }\n        if (largestAttacker !== undefined) {\n            this.setNewEnemy(largestAttacker, true);\n        }\n    }\n    getNeighborTraitorToAttack() {\n        const traitors = this.player\n            .neighbors()\n            .filter((n) => n.isPlayer() && n.isTraitor());\n        return traitors.length > 0 ? this.random.randElement(traitors) : null;\n    }\n    assistAllies() {\n        for (const ally of this.player.allies()) {\n            if (ally.targets().length === 0)\n                continue;\n            if (this.player.relation(ally) < _game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Friendly) {\n                this.emoji(ally, this.random.randElement(EMOJI_RELATION_TOO_LOW));\n                continue;\n            }\n            for (const target of ally.targets()) {\n                if (target === this.player) {\n                    this.emoji(ally, this.random.randElement(EMOJI_TARGET_ME));\n                    continue;\n                }\n                if (this.player.isAlliedWith(target)) {\n                    this.emoji(ally, this.random.randElement(EMOJI_TARGET_ALLY));\n                    continue;\n                }\n                // All checks passed, assist them\n                this.player.updateRelation(ally, -20);\n                this.setNewEnemy(target);\n                this.emoji(ally, this.random.randElement(EMOJI_ASSIST_ACCEPT));\n                return;\n            }\n        }\n    }\n    selectEnemy(enemies) {\n        if (this.enemy === null) {\n            // Save up troops until we reach the reserve ratio\n            if (!this.hasReserveRatioTroops())\n                return null;\n            // Maybe save up troops until we reach the trigger ratio\n            if (!this.hasTriggerRatioTroops() && !this.random.chance(10))\n                return null;\n            // Prefer neighboring bots\n            const bots = this.player\n                .neighbors()\n                .filter((n) => n.isPlayer() && n.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.Bot);\n            if (bots.length > 0) {\n                const density = (p) => p.troops() / p.numTilesOwned();\n                let lowestDensityBot;\n                let lowestDensity = Infinity;\n                for (const bot of bots) {\n                    const currentDensity = density(bot);\n                    if (currentDensity < lowestDensity) {\n                        lowestDensity = currentDensity;\n                        lowestDensityBot = bot;\n                    }\n                }\n                if (lowestDensityBot !== undefined) {\n                    this.setNewEnemy(lowestDensityBot);\n                }\n            }\n            // Retaliate against incoming attacks\n            if (this.enemy === null) {\n                // Only after clearing bots\n                this.checkIncomingAttacks();\n            }\n            // Select the most hated player\n            if (this.enemy === null && this.random.chance(2)) {\n                // 50% chance\n                const mostHated = this.player.allRelationsSorted()[0];\n                if (mostHated !== undefined &&\n                    mostHated.relation === _game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Hostile) {\n                    this.setNewEnemy(mostHated.player);\n                }\n            }\n            // Select the weakest player\n            if (this.enemy === null && enemies.length > 0) {\n                this.setNewEnemy(enemies[0]);\n            }\n            // Select a random player\n            if (this.enemy === null && enemies.length > 0) {\n                this.setNewEnemy(this.random.randElement(enemies));\n            }\n        }\n        // Sanity check, don't attack our allies or teammates\n        return this.enemySanityCheck();\n    }\n    selectRandomEnemy() {\n        if (this.enemy === null) {\n            // Save up troops until we reach the trigger ratio\n            if (!this.hasTriggerRatioTroops())\n                return null;\n            // Choose a new enemy randomly\n            const neighbors = this.player.neighbors();\n            for (const neighbor of this.random.shuffleArray(neighbors)) {\n                if (!neighbor.isPlayer())\n                    continue;\n                if (this.player.isFriendly(neighbor))\n                    continue;\n                if (neighbor.type() === _game_Game__WEBPACK_IMPORTED_MODULE_0__.PlayerType.FakeHuman) {\n                    if (this.random.chance(2)) {\n                        continue;\n                    }\n                }\n                this.setNewEnemy(neighbor);\n            }\n            // Retaliate against incoming attacks\n            if (this.enemy === null) {\n                this.checkIncomingAttacks();\n            }\n            // Select a traitor as an enemy\n            if (this.enemy === null) {\n                const toAttack = this.getNeighborTraitorToAttack();\n                if (toAttack !== null) {\n                    if (!this.player.isFriendly(toAttack) && this.random.chance(3)) {\n                        this.setNewEnemy(toAttack);\n                    }\n                }\n            }\n        }\n        // Sanity check, don't attack our allies or teammates\n        return this.enemySanityCheck();\n    }\n    enemySanityCheck() {\n        if (this.enemy && this.player.isFriendly(this.enemy)) {\n            this.clearEnemy();\n        }\n        return this.enemy;\n    }\n    forceSendAttack(target) {\n        this.game.addExecution(new _AttackExecution__WEBPACK_IMPORTED_MODULE_3__.AttackExecution(this.player.troops() / 2, this.player, target.isPlayer() ? target.id() : this.game.terraNullius().id()));\n    }\n    sendAttack(target) {\n        // Skip attacking friendly targets (allies or teammates) - decision to break alliances should be made by caller\n        if (target.isPlayer() && this.player.isFriendly(target))\n            return;\n        const maxTroops = this.game.config().maxTroops(this.player);\n        const reserveRatio = target.isPlayer()\n            ? this.reserveRatio\n            : this.expandRatio;\n        const targetTroops = maxTroops * reserveRatio;\n        const troops = this.player.troops() - targetTroops;\n        if (troops < 1)\n            return;\n        this.game.addExecution(new _AttackExecution__WEBPACK_IMPORTED_MODULE_3__.AttackExecution(troops, this.player, target.isPlayer() ? target.id() : this.game.terraNullius().id()));\n    }\n}\nfunction shouldAcceptAllianceRequest(player, request) {\n    if (player.relation(request.requestor()) < _game_Game__WEBPACK_IMPORTED_MODULE_0__.Relation.Neutral) {\n        return false; // Reject if hasMalice\n    }\n    if (request.requestor().isTraitor()) {\n        return false; // Reject if isTraitor\n    }\n    if (request.requestor().numTilesOwned() > player.numTilesOwned() * 3) {\n        return true; // Accept if requestorIsMuchLarger\n    }\n    if (request.requestor().alliances().length >= 3) {\n        return false; // Reject if tooManyAlliances\n    }\n    return true; // Accept otherwise\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/utils/BotBehavior.ts?\n}");

/***/ }),

/***/ "./src/core/execution/utils/BotNames.ts":
/*!**********************************************!*\
  !*** ./src/core/execution/utils/BotNames.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BOT_NAME_PREFIXES: () => (/* binding */ BOT_NAME_PREFIXES),\n/* harmony export */   BOT_NAME_SUFFIXES: () => (/* binding */ BOT_NAME_SUFFIXES)\n/* harmony export */ });\nconst BOT_NAME_PREFIXES = [\n    \"Akkadian\",\n    \"Babylonian\",\n    \"Sumerian\",\n    \"Hittite\",\n    \"Phoenician\",\n    \"Canaanite\",\n    \"Minoan\",\n    \"Mycenaean\",\n    \"Etruscan\",\n    \"Scythian\",\n    \"Thracian\",\n    \"Dacian\",\n    \"Illyrian\",\n    \"Median\",\n    \"Chaldean\",\n    \"Roman\",\n    \"Greek\",\n    \"Byzantine\",\n    \"Persian\",\n    \"Parthian\",\n    \"Seleucid\",\n    \"Ptolemaic\",\n    \"Palmyrene\",\n    \"Macedonian\",\n    \"Carthaginian\",\n    \"Ming\",\n    \"Tang\",\n    \"Song\",\n    \"Yuan\",\n    \"Mauryan\",\n    \"Kushan\",\n    \"Rajput\",\n    \"Mughal\",\n    \"Satavahana\",\n    \"Vijayanagara\",\n    \"Egyptian\",\n    \"Nubian\",\n    \"Kushite\",\n    \"Aksumite\",\n    \"Ethiopian\",\n    \"Songhai\",\n    \"Malian\",\n    \"Ghanaian\",\n    \"Benin\",\n    \"Ashanti\",\n    \"Zulu\",\n    \"Tuareg\",\n    \"Berber\",\n    \"Kanem-Bornu\",\n    \"Buganda\",\n    \"Mossi\",\n    \"Swahili\",\n    \"Somali\",\n    \"Wolof\",\n    \"Umayyad\",\n    \"Abbasid\",\n    \"Ayyubid\",\n    \"Fatimid\",\n    \"Mamluk\",\n    \"Seljuk\",\n    \"Safavid\",\n    \"Ottoman\",\n    \"Almoravid\",\n    \"Almohad\",\n    \"Rashidun\",\n    \"Ziyarid\",\n    \"Frankish\",\n    \"Visigothic\",\n    \"Ostrogothic\",\n    \"Viking\",\n    \"Norman\",\n    \"Saxon\",\n    \"Anglo-Saxon\",\n    \"Celtic\",\n    \"Gaulish\",\n    \"Carolingian\",\n    \"Merovingian\",\n    \"Capetian\",\n    \"Plantagenet\",\n    \"Tudor\",\n    \"Stuart\",\n    \"Habsburg\",\n    \"Romanov\",\n    \"Lancaster\",\n    \"York\",\n    \"Bourbon\",\n    \"Napoleonic\",\n    \"British\",\n    \"French\",\n    \"Spanish\",\n    \"Portuguese\",\n    \"Dutch\",\n    \"Russian\",\n    \"German\",\n    \"Italian\",\n    \"Swedish\",\n    \"Norwegian\",\n    \"Danish\",\n    \"Polish\",\n    \"Hungarian\",\n    \"Austrian\",\n    \"Swiss\",\n    \"Czech\",\n    \"Slovak\",\n    \"Serbian\",\n    \"Croatian\",\n    \"Bosnian\",\n    \"Montenegrin\",\n    \"Bulgarian\",\n    \"Romanian\",\n    \"Apache\",\n    \"Sioux\",\n    \"Cherokee\",\n    \"Navajo\",\n    \"Iroquois\",\n    \"Inuit\",\n    \"Arawak\",\n    \"Carib\",\n    \"Taino\",\n    \"Aztec\",\n    \"Mayan\",\n    \"Incan\",\n    \"Mapuche\",\n    \"Guarani\",\n    \"Tupi\",\n    \"Yanomami\",\n    \"Zuni\",\n    \"Hopi\",\n    \"Kiowa\",\n    \"Comanche\",\n    \"Shoshone\",\n    \"Japanese\",\n    \"Ryukyu\",\n    \"Ainu\",\n    \"Cham\",\n    \"Khmer\",\n    \"Thai\",\n    \"Vietnamese\",\n    \"Burmese\",\n    \"Balinese\",\n    \"Malay\",\n    \"Filipino\",\n    \"Mongolian\",\n    \"Korean\",\n    \"Tibetan\",\n    \"Manchu\",\n    \"Uyghur\",\n    \"Hmong\",\n    \"Karen\",\n    \"Pyu\",\n    \"Hawaiian\",\n    \"Fijian\",\n    \"Tongan\",\n    \"Samoan\",\n    \"Maori\",\n    \"Micronesian\",\n    \"Hebrew\",\n    \"Armenian\",\n    \"Circassian\",\n    \"Georgian\",\n    \"Phoenician\",\n    \"Chaldean\",\n    \"Kurdish\",\n    \"Turkic\",\n    \"Kazakh\",\n    \"Uzbek\",\n    \"Kyrgyz\",\n    \"Tajik\",\n    \"Uighur\",\n    \"Pashtun\",\n    \"Baloch\",\n    \"Afghan\",\n    \"Persian\",\n    \"Kenyan\",\n    \"Ugandan\",\n    \"Bhutanese\",\n    \"Latin\",\n    \"Moldovan\",\n    \"Militant\",\n    \"Spartan\",\n];\nconst BOT_NAME_SUFFIXES = [\n    \"Empire\",\n    \"Dynasty\",\n    \"Kingdom\",\n    \"Queendom\",\n    \"Sultanate\",\n    \"Confederation\",\n    \"Union\",\n    \"Republic\",\n    \"Caliphate\",\n    \"Dominion\",\n    \"Realm\",\n    \"State\",\n    \"Federation\",\n    \"Territory\",\n    \"Commonwealth\",\n    \"League\",\n    \"Duchy\",\n    \"Province\",\n    \"Protectorate\",\n    \"Colony\",\n    \"Mandate\",\n    \"Free State\",\n    \"Canton\",\n    \"Region\",\n    \"Nation\",\n    \"Assembly\",\n    \"Hierarchy\",\n    \"Archduchy\",\n    \"Grand Duchy\",\n    \"Metropolis\",\n    \"Cluster\",\n    \"Alliance\",\n    \"Tribunal\",\n    \"Council\",\n    \"Confederacy\",\n    \"Order\",\n    \"Regime\",\n    \"Dominion\",\n    \"Syndicate\",\n    \"Guild\",\n    \"Corporation\",\n    \"Patriarchy\",\n    \"Matriarchy\",\n    \"Legion\",\n    \"Horde\",\n    \"Clan\",\n    \"Brotherhood\",\n    \"Sisterhood\",\n    \"Ascendancy\",\n    \"Supremacy\",\n    \"Province\",\n    \"Tribe\",\n    \"Dominion\",\n    \"Assembly\",\n    \"Republics\",\n    \"Army\",\n    \"Dictatorship\",\n    \"Country\",\n    \"Oligarchy\",\n    \"Monkdom\",\n    \"Throng\",\n    \"Host\",\n    \"Area\",\n    \"District\",\n    \"Fief\",\n    \"Wilderness\",\n    \"Settlement\",\n    \"Parliament\",\n    \"Anarchy\",\n    \"Democracy\",\n    \"Autocracy\",\n];\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/utils/BotNames.ts?\n}");

/***/ }),

/***/ "./src/core/execution/utils/FlatBinaryHeap.ts":
/*!****************************************************!*\
  !*** ./src/core/execution/utils/FlatBinaryHeap.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlatBinaryHeap: () => (/* binding */ FlatBinaryHeap)\n/* harmony export */ });\n/**\n * Lightweight min-heap specialised for (priority:number, tile:TileRef) pairs.\n * - priorities stored in a contiguous Float32Array\n * - tiles stored in a parallel object array\n */\nclass FlatBinaryHeap {\n    constructor(capacity = 1024) {\n        this.len = 0; // current number of elements\n        this.pri = new Float32Array(capacity);\n        this.tiles = new Array(capacity);\n    }\n    /** remove every element without reallocating */\n    clear() {\n        this.len = 0;\n    }\n    /** current heap size */\n    size() {\n        return this.len;\n    }\n    //insert tiles\n    enqueue(tile, priority) {\n        if (this.len === this.pri.length)\n            this.grow(); // ensure space\n        let i = this.len++;\n        /* sift-up */\n        while (i > 0) {\n            const parent = (i - 1) >> 1;\n            if (priority >= this.pri[parent])\n                break;\n            this.pri[i] = this.pri[parent];\n            this.tiles[i] = this.tiles[parent];\n            i = parent;\n        }\n        this.pri[i] = priority;\n        this.tiles[i] = tile;\n    }\n    //remove tiles\n    dequeue() {\n        if (this.len === 0)\n            throw new Error(\"heap empty\");\n        const topTile = this.tiles[0];\n        const topPri = this.pri[0];\n        const lastPri = this.pri[--this.len];\n        const lastTile = this.tiles[this.len];\n        /* sift-down */\n        let i = 0;\n        while (true) {\n            const left = (i << 1) + 1;\n            if (left >= this.len)\n                break;\n            const right = left + 1;\n            const child = right < this.len && this.pri[right] < this.pri[left] ? right : left;\n            if (lastPri <= this.pri[child])\n                break;\n            this.pri[i] = this.pri[child];\n            this.tiles[i] = this.tiles[child];\n            i = child;\n        }\n        this.pri[i] = lastPri;\n        this.tiles[i] = lastTile;\n        return [topTile, topPri];\n    }\n    /** double the underlying storage */\n    grow() {\n        const newCap = this.pri.length << 1;\n        const newPri = new Float32Array(newCap);\n        newPri.set(this.pri);\n        this.pri = newPri;\n        this.tiles.length = newCap;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/execution/utils/FlatBinaryHeap.ts?\n}");

/***/ }),

/***/ "./src/core/game/AllianceImpl.ts":
/*!***************************************!*\
  !*** ./src/core/game/AllianceImpl.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllianceImpl: () => (/* binding */ AllianceImpl)\n/* harmony export */ });\nclass AllianceImpl {\n    constructor(mg, requestor_, recipient_, createdAt_, id_) {\n        this.mg = mg;\n        this.requestor_ = requestor_;\n        this.recipient_ = recipient_;\n        this.createdAt_ = createdAt_;\n        this.id_ = id_;\n        this.extensionRequestedRequestor_ = false;\n        this.extensionRequestedRecipient_ = false;\n        this.expiresAt_ = createdAt_ + mg.config().allianceDuration();\n    }\n    other(player) {\n        if (this.requestor_ === player) {\n            return this.recipient_;\n        }\n        return this.requestor_;\n    }\n    requestor() {\n        return this.requestor_;\n    }\n    recipient() {\n        return this.recipient_;\n    }\n    createdAt() {\n        return this.createdAt_;\n    }\n    expire() {\n        this.mg.expireAlliance(this);\n    }\n    addExtensionRequest(player) {\n        if (this.requestor_ === player) {\n            this.extensionRequestedRequestor_ = true;\n        }\n        else if (this.recipient_ === player) {\n            this.extensionRequestedRecipient_ = true;\n        }\n    }\n    bothAgreedToExtend() {\n        return (this.extensionRequestedRequestor_ && this.extensionRequestedRecipient_);\n    }\n    onlyOneAgreedToExtend() {\n        // Requestor / Recipient of the original alliance request, not of the extension request\n        // False if: no expiration or neither requested extension yet (both false), or both agreed to extend (both true)\n        // True if: one requested extension, other didn't yet or actively ignored (one true, one false)\n        return (this.extensionRequestedRequestor_ !== this.extensionRequestedRecipient_);\n    }\n    id() {\n        return this.id_;\n    }\n    extend() {\n        this.extensionRequestedRequestor_ = false;\n        this.extensionRequestedRecipient_ = false;\n        this.expiresAt_ = this.mg.ticks() + this.mg.config().allianceDuration();\n    }\n    expiresAt() {\n        return this.expiresAt_;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/AllianceImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/AllianceRequestImpl.ts":
/*!**********************************************!*\
  !*** ./src/core/game/AllianceRequestImpl.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllianceRequestImpl: () => (/* binding */ AllianceRequestImpl)\n/* harmony export */ });\n/* harmony import */ var _GameUpdates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n\nclass AllianceRequestImpl {\n    constructor(requestor_, recipient_, tickCreated, game) {\n        this.requestor_ = requestor_;\n        this.recipient_ = recipient_;\n        this.tickCreated = tickCreated;\n        this.game = game;\n        this.status_ = \"pending\";\n    }\n    status() {\n        return this.status_;\n    }\n    requestor() {\n        return this.requestor_;\n    }\n    recipient() {\n        return this.recipient_;\n    }\n    createdAt() {\n        return this.tickCreated;\n    }\n    accept() {\n        this.status_ = \"accepted\";\n        this.game.acceptAllianceRequest(this);\n    }\n    reject() {\n        this.status_ = \"rejected\";\n        this.game.rejectAllianceRequest(this);\n    }\n    toUpdate() {\n        return {\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_0__.GameUpdateType.AllianceRequest,\n            requestorID: this.requestor_.smallID(),\n            recipientID: this.recipient_.smallID(),\n            createdAt: this.tickCreated,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/AllianceRequestImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/AttackImpl.ts":
/*!*************************************!*\
  !*** ./src/core/game/AttackImpl.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttackImpl: () => (/* binding */ AttackImpl)\n/* harmony export */ });\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n\nclass AttackImpl {\n    constructor(_id, _target, _attacker, _troops, _sourceTile, _border, _mg) {\n        this._id = _id;\n        this._target = _target;\n        this._attacker = _attacker;\n        this._troops = _troops;\n        this._sourceTile = _sourceTile;\n        this._border = _border;\n        this._mg = _mg;\n        this._isActive = true;\n        this._borderSize = 0;\n        this._retreating = false;\n        this._retreated = false;\n    }\n    sourceTile() {\n        return this._sourceTile;\n    }\n    target() {\n        return this._target;\n    }\n    attacker() {\n        return this._attacker;\n    }\n    troops() {\n        return this._troops;\n    }\n    setTroops(troops) {\n        this._troops = troops;\n    }\n    isActive() {\n        return this._isActive;\n    }\n    id() {\n        return this._id;\n    }\n    delete() {\n        if (this._target.isPlayer()) {\n            this._target._incomingAttacks = this._target._incomingAttacks.filter((a) => a !== this);\n        }\n        this._attacker._outgoingAttacks = this._attacker._outgoingAttacks.filter((a) => a !== this);\n        this._isActive = false;\n    }\n    orderRetreat() {\n        this._retreating = true;\n    }\n    executeRetreat() {\n        this._retreated = true;\n    }\n    retreating() {\n        return this._retreating;\n    }\n    retreated() {\n        return this._retreated;\n    }\n    borderSize() {\n        return this._borderSize;\n    }\n    clearBorder() {\n        this._borderSize = 0;\n        this._border.clear();\n    }\n    addBorderTile(tile) {\n        if (!this._border.has(tile)) {\n            this._borderSize += 1;\n            this._border.add(tile);\n        }\n    }\n    removeBorderTile(tile) {\n        if (this._border.has(tile)) {\n            this._borderSize -= 1;\n            this._border.delete(tile);\n        }\n    }\n    averagePosition() {\n        if (this._borderSize === 0) {\n            if (this.sourceTile() === null) {\n                // No border tiles and no source tileâ€”return a default position or throw an error\n                return null;\n            }\n            // No border tiles yetâ€”use the source tile's location\n            const tile = this.sourceTile();\n            return new _Game__WEBPACK_IMPORTED_MODULE_0__.Cell(this._mg.map().x(tile), this._mg.map().y(tile));\n        }\n        let averageX = 0;\n        let averageY = 0;\n        for (const t of this._border) {\n            averageX += this._mg.map().x(t);\n            averageY += this._mg.map().y(t);\n        }\n        averageX = averageX / this._borderSize;\n        averageY = averageY / this._borderSize;\n        return new _Game__WEBPACK_IMPORTED_MODULE_0__.Cell(averageX, averageY);\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/AttackImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/FetchGameMapLoader.ts":
/*!*********************************************!*\
  !*** ./src/core/game/FetchGameMapLoader.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchGameMapLoader: () => (/* binding */ FetchGameMapLoader)\n/* harmony export */ });\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n\nclass FetchGameMapLoader {\n    constructor(prefix, cacheBuster) {\n        this.prefix = prefix;\n        this.cacheBuster = cacheBuster;\n        this.maps = new Map();\n    }\n    getMapData(map) {\n        const cachedMap = this.maps.get(map);\n        if (cachedMap) {\n            return cachedMap;\n        }\n        const key = Object.keys(_Game__WEBPACK_IMPORTED_MODULE_0__.GameMapType).find((k) => _Game__WEBPACK_IMPORTED_MODULE_0__.GameMapType[k] === map);\n        const fileName = key?.toLowerCase();\n        if (!fileName) {\n            throw new Error(`Unknown map: ${map}`);\n        }\n        const mapData = {\n            mapBin: () => this.loadBinaryFromUrl(this.url(fileName, \"map.bin\")),\n            map4xBin: () => this.loadBinaryFromUrl(this.url(fileName, \"map4x.bin\")),\n            map16xBin: () => this.loadBinaryFromUrl(this.url(fileName, \"map16x.bin\")),\n            manifest: () => this.loadJsonFromUrl(this.url(fileName, \"manifest.json\")),\n            webpPath: async () => this.url(fileName, \"thumbnail.webp\"),\n        };\n        this.maps.set(map, mapData);\n        return mapData;\n    }\n    url(map, path) {\n        let url = `${this.prefix}/${map}/${path}`;\n        if (this.cacheBuster) {\n            url += `${url.includes(\"?\") ? \"&\" : \"?\"}v=${this.cacheBuster}`;\n        }\n        return url;\n    }\n    async loadBinaryFromUrl(url) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to load ${url}: ${response.statusText}`);\n        }\n        const data = await response.arrayBuffer();\n        return new Uint8Array(data);\n    }\n    async loadJsonFromUrl(url) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`Failed to load ${url}: ${response.statusText}`);\n        }\n        return response.json();\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/FetchGameMapLoader.ts?\n}");

/***/ }),

/***/ "./src/core/game/Game.ts":
/*!*******************************!*\
  !*** ./src/core/game/Game.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllPlayers: () => (/* binding */ AllPlayers),\n/* harmony export */   Cell: () => (/* binding */ Cell),\n/* harmony export */   ColoredTeams: () => (/* binding */ ColoredTeams),\n/* harmony export */   Difficulty: () => (/* binding */ Difficulty),\n/* harmony export */   Duos: () => (/* binding */ Duos),\n/* harmony export */   GameMapSize: () => (/* binding */ GameMapSize),\n/* harmony export */   GameMapType: () => (/* binding */ GameMapType),\n/* harmony export */   GameMode: () => (/* binding */ GameMode),\n/* harmony export */   GameType: () => (/* binding */ GameType),\n/* harmony export */   MESSAGE_TYPE_CATEGORIES: () => (/* binding */ MESSAGE_TYPE_CATEGORIES),\n/* harmony export */   MessageCategory: () => (/* binding */ MessageCategory),\n/* harmony export */   MessageType: () => (/* binding */ MessageType),\n/* harmony export */   Nation: () => (/* binding */ Nation),\n/* harmony export */   PlayerInfo: () => (/* binding */ PlayerInfo),\n/* harmony export */   PlayerType: () => (/* binding */ PlayerType),\n/* harmony export */   Quads: () => (/* binding */ Quads),\n/* harmony export */   Relation: () => (/* binding */ Relation),\n/* harmony export */   TerrainType: () => (/* binding */ TerrainType),\n/* harmony export */   TrainType: () => (/* binding */ TrainType),\n/* harmony export */   Trios: () => (/* binding */ Trios),\n/* harmony export */   UnitType: () => (/* binding */ UnitType),\n/* harmony export */   getMessageCategory: () => (/* binding */ getMessageCategory),\n/* harmony export */   isDifficulty: () => (/* binding */ isDifficulty),\n/* harmony export */   isGameMode: () => (/* binding */ isGameMode),\n/* harmony export */   isGameType: () => (/* binding */ isGameType),\n/* harmony export */   isStructureType: () => (/* binding */ isStructureType),\n/* harmony export */   isUnit: () => (/* binding */ isUnit),\n/* harmony export */   mapCategories: () => (/* binding */ mapCategories),\n/* harmony export */   nukeTypes: () => (/* binding */ nukeTypes)\n/* harmony export */ });\nfunction isEnumValue(enumObj, value) {\n    return Object.values(enumObj).includes(value);\n}\nconst AllPlayers = \"AllPlayers\";\nvar Difficulty;\n(function (Difficulty) {\n    Difficulty[\"Easy\"] = \"Easy\";\n    Difficulty[\"Medium\"] = \"Medium\";\n    Difficulty[\"Hard\"] = \"Hard\";\n    Difficulty[\"Impossible\"] = \"Impossible\";\n})(Difficulty || (Difficulty = {}));\nconst isDifficulty = (value) => isEnumValue(Difficulty, value);\nconst Duos = \"Duos\";\nconst Trios = \"Trios\";\nconst Quads = \"Quads\";\nconst ColoredTeams = {\n    Red: \"Red\",\n    Blue: \"Blue\",\n    Teal: \"Teal\",\n    Purple: \"Purple\",\n    Yellow: \"Yellow\",\n    Orange: \"Orange\",\n    Green: \"Green\",\n    Bot: \"Bot\",\n};\nvar GameMapType;\n(function (GameMapType) {\n    GameMapType[\"World\"] = \"World\";\n    GameMapType[\"GiantWorldMap\"] = \"Giant World Map\";\n    GameMapType[\"Europe\"] = \"Europe\";\n    GameMapType[\"EuropeClassic\"] = \"Europe Classic\";\n    GameMapType[\"Mena\"] = \"Mena\";\n    GameMapType[\"NorthAmerica\"] = \"North America\";\n    GameMapType[\"SouthAmerica\"] = \"South America\";\n    GameMapType[\"Oceania\"] = \"Oceania\";\n    GameMapType[\"BlackSea\"] = \"Black Sea\";\n    GameMapType[\"Africa\"] = \"Africa\";\n    GameMapType[\"Pangaea\"] = \"Pangaea\";\n    GameMapType[\"Asia\"] = \"Asia\";\n    GameMapType[\"Mars\"] = \"Mars\";\n    GameMapType[\"Britannia\"] = \"Britannia\";\n    GameMapType[\"GatewayToTheAtlantic\"] = \"Gateway to the Atlantic\";\n    GameMapType[\"Australia\"] = \"Australia\";\n    GameMapType[\"Iceland\"] = \"Iceland\";\n    GameMapType[\"EastAsia\"] = \"East Asia\";\n    GameMapType[\"BetweenTwoSeas\"] = \"Between Two Seas\";\n    GameMapType[\"FaroeIslands\"] = \"Faroe Islands\";\n    GameMapType[\"DeglaciatedAntarctica\"] = \"Deglaciated Antarctica\";\n    GameMapType[\"FalklandIslands\"] = \"Falkland Islands\";\n    GameMapType[\"Baikal\"] = \"Baikal\";\n    GameMapType[\"Halkidiki\"] = \"Halkidiki\";\n    GameMapType[\"StraitOfGibraltar\"] = \"Strait of Gibraltar\";\n    GameMapType[\"Italia\"] = \"Italia\";\n    GameMapType[\"Japan\"] = \"Japan\";\n    GameMapType[\"Yenisei\"] = \"Yenisei\";\n    GameMapType[\"Pluto\"] = \"Pluto\";\n    GameMapType[\"Montreal\"] = \"Montreal\";\n})(GameMapType || (GameMapType = {}));\nconst mapCategories = {\n    continental: [\n        GameMapType.World,\n        GameMapType.GiantWorldMap,\n        GameMapType.NorthAmerica,\n        GameMapType.SouthAmerica,\n        GameMapType.Europe,\n        GameMapType.EuropeClassic,\n        GameMapType.Asia,\n        GameMapType.Africa,\n        GameMapType.Oceania,\n    ],\n    regional: [\n        GameMapType.BlackSea,\n        GameMapType.Britannia,\n        GameMapType.GatewayToTheAtlantic,\n        GameMapType.BetweenTwoSeas,\n        GameMapType.Iceland,\n        GameMapType.EastAsia,\n        GameMapType.Mena,\n        GameMapType.Australia,\n        GameMapType.FaroeIslands,\n        GameMapType.FalklandIslands,\n        GameMapType.Baikal,\n        GameMapType.Halkidiki,\n        GameMapType.StraitOfGibraltar,\n        GameMapType.Italia,\n        GameMapType.Japan,\n        GameMapType.Yenisei,\n        GameMapType.Montreal,\n    ],\n    fantasy: [\n        GameMapType.Pangaea,\n        GameMapType.Pluto,\n        GameMapType.Mars,\n        GameMapType.DeglaciatedAntarctica,\n    ],\n};\nvar GameType;\n(function (GameType) {\n    GameType[\"Singleplayer\"] = \"Singleplayer\";\n    GameType[\"Public\"] = \"Public\";\n    GameType[\"Private\"] = \"Private\";\n})(GameType || (GameType = {}));\nconst isGameType = (value) => isEnumValue(GameType, value);\nvar GameMode;\n(function (GameMode) {\n    GameMode[\"FFA\"] = \"Free For All\";\n    GameMode[\"Team\"] = \"Team\";\n})(GameMode || (GameMode = {}));\nconst isGameMode = (value) => isEnumValue(GameMode, value);\nvar GameMapSize;\n(function (GameMapSize) {\n    GameMapSize[\"Compact\"] = \"Compact\";\n    GameMapSize[\"Normal\"] = \"Normal\";\n})(GameMapSize || (GameMapSize = {}));\nvar UnitType;\n(function (UnitType) {\n    UnitType[\"TransportShip\"] = \"Transport\";\n    UnitType[\"Warship\"] = \"Warship\";\n    UnitType[\"Shell\"] = \"Shell\";\n    UnitType[\"SAMMissile\"] = \"SAMMissile\";\n    UnitType[\"Port\"] = \"Port\";\n    UnitType[\"AtomBomb\"] = \"Atom Bomb\";\n    UnitType[\"HydrogenBomb\"] = \"Hydrogen Bomb\";\n    UnitType[\"TradeShip\"] = \"Trade Ship\";\n    UnitType[\"MissileSilo\"] = \"Missile Silo\";\n    UnitType[\"DefensePost\"] = \"Defense Post\";\n    UnitType[\"SAMLauncher\"] = \"SAM Launcher\";\n    UnitType[\"City\"] = \"City\";\n    UnitType[\"MIRV\"] = \"MIRV\";\n    UnitType[\"MIRVWarhead\"] = \"MIRV Warhead\";\n    UnitType[\"Construction\"] = \"Construction\";\n    UnitType[\"Train\"] = \"Train\";\n    UnitType[\"Factory\"] = \"Factory\";\n})(UnitType || (UnitType = {}));\nvar TrainType;\n(function (TrainType) {\n    TrainType[\"Engine\"] = \"Engine\";\n    TrainType[\"Carriage\"] = \"Carriage\";\n})(TrainType || (TrainType = {}));\nconst _structureTypes = new Set([\n    UnitType.City,\n    UnitType.Construction,\n    UnitType.DefensePost,\n    UnitType.SAMLauncher,\n    UnitType.MissileSilo,\n    UnitType.Port,\n]);\nfunction isStructureType(type) {\n    return _structureTypes.has(type);\n}\nconst nukeTypes = [\n    UnitType.AtomBomb,\n    UnitType.HydrogenBomb,\n    UnitType.MIRVWarhead,\n    UnitType.MIRV,\n];\nvar Relation;\n(function (Relation) {\n    Relation[Relation[\"Hostile\"] = 0] = \"Hostile\";\n    Relation[Relation[\"Distrustful\"] = 1] = \"Distrustful\";\n    Relation[Relation[\"Neutral\"] = 2] = \"Neutral\";\n    Relation[Relation[\"Friendly\"] = 3] = \"Friendly\";\n})(Relation || (Relation = {}));\nclass Nation {\n    constructor(spawnCell, strength, playerInfo) {\n        this.spawnCell = spawnCell;\n        this.strength = strength;\n        this.playerInfo = playerInfo;\n    }\n}\nclass Cell {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.strRepr = `Cell[${this.x},${this.y}]`;\n    }\n    pos() {\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    toString() {\n        return this.strRepr;\n    }\n}\nvar TerrainType;\n(function (TerrainType) {\n    TerrainType[TerrainType[\"Plains\"] = 0] = \"Plains\";\n    TerrainType[TerrainType[\"Highland\"] = 1] = \"Highland\";\n    TerrainType[TerrainType[\"Mountain\"] = 2] = \"Mountain\";\n    TerrainType[TerrainType[\"Lake\"] = 3] = \"Lake\";\n    TerrainType[TerrainType[\"Ocean\"] = 4] = \"Ocean\";\n})(TerrainType || (TerrainType = {}));\nvar PlayerType;\n(function (PlayerType) {\n    PlayerType[\"Bot\"] = \"BOT\";\n    PlayerType[\"Human\"] = \"HUMAN\";\n    PlayerType[\"FakeHuman\"] = \"FAKEHUMAN\";\n})(PlayerType || (PlayerType = {}));\nclass PlayerInfo {\n    constructor(name, playerType, \n    // null if bot.\n    clientID, \n    // TODO: make player id the small id\n    id, nation) {\n        this.name = name;\n        this.playerType = playerType;\n        this.clientID = clientID;\n        this.id = id;\n        this.nation = nation;\n        // Compute clan from name\n        if (!name.startsWith(\"[\") || !name.includes(\"]\")) {\n            this.clan = null;\n        }\n        else {\n            const clanMatch = name.match(/^\\[([a-zA-Z]{2,5})\\]/);\n            this.clan = clanMatch ? clanMatch[1] : null;\n        }\n    }\n}\nfunction isUnit(unit) {\n    return (unit &&\n        typeof unit === \"object\" &&\n        \"isUnit\" in unit &&\n        typeof unit.isUnit === \"function\" &&\n        unit.isUnit());\n}\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"ATTACK_FAILED\"] = 0] = \"ATTACK_FAILED\";\n    MessageType[MessageType[\"ATTACK_CANCELLED\"] = 1] = \"ATTACK_CANCELLED\";\n    MessageType[MessageType[\"ATTACK_REQUEST\"] = 2] = \"ATTACK_REQUEST\";\n    MessageType[MessageType[\"CONQUERED_PLAYER\"] = 3] = \"CONQUERED_PLAYER\";\n    MessageType[MessageType[\"MIRV_INBOUND\"] = 4] = \"MIRV_INBOUND\";\n    MessageType[MessageType[\"NUKE_INBOUND\"] = 5] = \"NUKE_INBOUND\";\n    MessageType[MessageType[\"HYDROGEN_BOMB_INBOUND\"] = 6] = \"HYDROGEN_BOMB_INBOUND\";\n    MessageType[MessageType[\"NAVAL_INVASION_INBOUND\"] = 7] = \"NAVAL_INVASION_INBOUND\";\n    MessageType[MessageType[\"SAM_MISS\"] = 8] = \"SAM_MISS\";\n    MessageType[MessageType[\"SAM_HIT\"] = 9] = \"SAM_HIT\";\n    MessageType[MessageType[\"CAPTURED_ENEMY_UNIT\"] = 10] = \"CAPTURED_ENEMY_UNIT\";\n    MessageType[MessageType[\"UNIT_CAPTURED_BY_ENEMY\"] = 11] = \"UNIT_CAPTURED_BY_ENEMY\";\n    MessageType[MessageType[\"UNIT_DESTROYED\"] = 12] = \"UNIT_DESTROYED\";\n    MessageType[MessageType[\"ALLIANCE_ACCEPTED\"] = 13] = \"ALLIANCE_ACCEPTED\";\n    MessageType[MessageType[\"ALLIANCE_REJECTED\"] = 14] = \"ALLIANCE_REJECTED\";\n    MessageType[MessageType[\"ALLIANCE_REQUEST\"] = 15] = \"ALLIANCE_REQUEST\";\n    MessageType[MessageType[\"ALLIANCE_BROKEN\"] = 16] = \"ALLIANCE_BROKEN\";\n    MessageType[MessageType[\"ALLIANCE_EXPIRED\"] = 17] = \"ALLIANCE_EXPIRED\";\n    MessageType[MessageType[\"SENT_GOLD_TO_PLAYER\"] = 18] = \"SENT_GOLD_TO_PLAYER\";\n    MessageType[MessageType[\"RECEIVED_GOLD_FROM_PLAYER\"] = 19] = \"RECEIVED_GOLD_FROM_PLAYER\";\n    MessageType[MessageType[\"RECEIVED_GOLD_FROM_TRADE\"] = 20] = \"RECEIVED_GOLD_FROM_TRADE\";\n    MessageType[MessageType[\"SENT_TROOPS_TO_PLAYER\"] = 21] = \"SENT_TROOPS_TO_PLAYER\";\n    MessageType[MessageType[\"RECEIVED_TROOPS_FROM_PLAYER\"] = 22] = \"RECEIVED_TROOPS_FROM_PLAYER\";\n    MessageType[MessageType[\"CHAT\"] = 23] = \"CHAT\";\n    MessageType[MessageType[\"RENEW_ALLIANCE\"] = 24] = \"RENEW_ALLIANCE\";\n})(MessageType || (MessageType = {}));\n// Message categories used for filtering events in the EventsDisplay\nvar MessageCategory;\n(function (MessageCategory) {\n    MessageCategory[\"ATTACK\"] = \"ATTACK\";\n    MessageCategory[\"NUKE\"] = \"NUKE\";\n    MessageCategory[\"ALLIANCE\"] = \"ALLIANCE\";\n    MessageCategory[\"TRADE\"] = \"TRADE\";\n    MessageCategory[\"CHAT\"] = \"CHAT\";\n})(MessageCategory || (MessageCategory = {}));\n// Ensures that all message types are included in a category\nconst MESSAGE_TYPE_CATEGORIES = {\n    [MessageType.ATTACK_FAILED]: MessageCategory.ATTACK,\n    [MessageType.ATTACK_CANCELLED]: MessageCategory.ATTACK,\n    [MessageType.ATTACK_REQUEST]: MessageCategory.ATTACK,\n    [MessageType.CONQUERED_PLAYER]: MessageCategory.ATTACK,\n    [MessageType.MIRV_INBOUND]: MessageCategory.NUKE,\n    [MessageType.NUKE_INBOUND]: MessageCategory.NUKE,\n    [MessageType.HYDROGEN_BOMB_INBOUND]: MessageCategory.NUKE,\n    [MessageType.NAVAL_INVASION_INBOUND]: MessageCategory.ATTACK,\n    [MessageType.SAM_MISS]: MessageCategory.ATTACK,\n    [MessageType.SAM_HIT]: MessageCategory.ATTACK,\n    [MessageType.CAPTURED_ENEMY_UNIT]: MessageCategory.ATTACK,\n    [MessageType.UNIT_CAPTURED_BY_ENEMY]: MessageCategory.ATTACK,\n    [MessageType.UNIT_DESTROYED]: MessageCategory.ATTACK,\n    [MessageType.ALLIANCE_ACCEPTED]: MessageCategory.ALLIANCE,\n    [MessageType.ALLIANCE_REJECTED]: MessageCategory.ALLIANCE,\n    [MessageType.ALLIANCE_REQUEST]: MessageCategory.ALLIANCE,\n    [MessageType.ALLIANCE_BROKEN]: MessageCategory.ALLIANCE,\n    [MessageType.ALLIANCE_EXPIRED]: MessageCategory.ALLIANCE,\n    [MessageType.RENEW_ALLIANCE]: MessageCategory.ALLIANCE,\n    [MessageType.SENT_GOLD_TO_PLAYER]: MessageCategory.TRADE,\n    [MessageType.RECEIVED_GOLD_FROM_PLAYER]: MessageCategory.TRADE,\n    [MessageType.RECEIVED_GOLD_FROM_TRADE]: MessageCategory.TRADE,\n    [MessageType.SENT_TROOPS_TO_PLAYER]: MessageCategory.TRADE,\n    [MessageType.RECEIVED_TROOPS_FROM_PLAYER]: MessageCategory.TRADE,\n    [MessageType.CHAT]: MessageCategory.CHAT,\n};\n/**\n * Get the category of a message type\n */\nfunction getMessageCategory(messageType) {\n    return MESSAGE_TYPE_CATEGORIES[messageType];\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/Game.ts?\n}");

/***/ }),

/***/ "./src/core/game/GameImpl.ts":
/*!***********************************!*\
  !*** ./src/core/game/GameImpl.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameImpl: () => (/* binding */ GameImpl),\n/* harmony export */   createGame: () => (/* binding */ createGame)\n/* harmony export */ });\n/* harmony import */ var _client_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../client/Utils */ \"./src/client/Utils.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _AllianceImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AllianceImpl */ \"./src/core/game/AllianceImpl.ts\");\n/* harmony import */ var _AllianceRequestImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AllianceRequestImpl */ \"./src/core/game/AllianceRequestImpl.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _GameUpdates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n/* harmony import */ var _PlayerImpl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./PlayerImpl */ \"./src/core/game/PlayerImpl.ts\");\n/* harmony import */ var _RailNetworkImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RailNetworkImpl */ \"./src/core/game/RailNetworkImpl.ts\");\n/* harmony import */ var _StatsImpl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./StatsImpl */ \"./src/core/game/StatsImpl.ts\");\n/* harmony import */ var _TeamAssignment__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TeamAssignment */ \"./src/core/game/TeamAssignment.ts\");\n/* harmony import */ var _TerraNulliusImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TerraNulliusImpl */ \"./src/core/game/TerraNulliusImpl.ts\");\n/* harmony import */ var _UnitGrid__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./UnitGrid */ \"./src/core/game/UnitGrid.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createGame(humans, nations, gameMap, miniGameMap, config) {\n    const stats = new _StatsImpl__WEBPACK_IMPORTED_MODULE_8__.StatsImpl();\n    return new GameImpl(humans, nations, gameMap, miniGameMap, config, stats);\n}\nclass GameImpl {\n    constructor(_humans, _nations, _map, miniGameMap, _config, _stats) {\n        this._humans = _humans;\n        this._nations = _nations;\n        this._map = _map;\n        this.miniGameMap = miniGameMap;\n        this._config = _config;\n        this._stats = _stats;\n        this._ticks = 0;\n        this.unInitExecs = [];\n        this._players = new Map();\n        this._playersBySmallID = [];\n        this.execs = [];\n        this.allianceRequests = [];\n        this.alliances_ = [];\n        this.nextPlayerID = 1;\n        this._nextUnitID = 1;\n        this.updates = createGameUpdatesMap();\n        this.botTeam = _Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Bot;\n        this._railNetwork = (0,_RailNetworkImpl__WEBPACK_IMPORTED_MODULE_7__.createRailNetwork)(this);\n        // Used to assign unique IDs to each new alliance\n        this.nextAllianceID = 0;\n        this._terraNullius = new _TerraNulliusImpl__WEBPACK_IMPORTED_MODULE_10__.TerraNulliusImpl();\n        this._width = _map.width();\n        this._height = _map.height();\n        this.unitGrid = new _UnitGrid__WEBPACK_IMPORTED_MODULE_11__.UnitGrid(this._map);\n        if (_config.gameConfig().gameMode === _Game__WEBPACK_IMPORTED_MODULE_4__.GameMode.Team) {\n            this.populateTeams();\n        }\n        this.addPlayers();\n    }\n    populateTeams() {\n        let numPlayerTeams = this._config.playerTeams();\n        if (typeof numPlayerTeams !== \"number\") {\n            const players = this._humans.length + this._nations.length;\n            switch (numPlayerTeams) {\n                case _Game__WEBPACK_IMPORTED_MODULE_4__.Duos:\n                    numPlayerTeams = Math.ceil(players / 2);\n                    break;\n                case _Game__WEBPACK_IMPORTED_MODULE_4__.Trios:\n                    numPlayerTeams = Math.ceil(players / 3);\n                    break;\n                case _Game__WEBPACK_IMPORTED_MODULE_4__.Quads:\n                    numPlayerTeams = Math.ceil(players / 4);\n                    break;\n                default:\n                    throw new Error(`Unknown TeamCountConfig ${numPlayerTeams}`);\n            }\n        }\n        if (numPlayerTeams < 2) {\n            throw new Error(`Too few teams: ${numPlayerTeams}`);\n        }\n        else if (numPlayerTeams < 8) {\n            this.playerTeams = [_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Red, _Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Blue];\n            if (numPlayerTeams >= 3)\n                this.playerTeams.push(_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Yellow);\n            if (numPlayerTeams >= 4)\n                this.playerTeams.push(_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Green);\n            if (numPlayerTeams >= 5)\n                this.playerTeams.push(_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Purple);\n            if (numPlayerTeams >= 6)\n                this.playerTeams.push(_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Orange);\n            if (numPlayerTeams >= 7)\n                this.playerTeams.push(_Game__WEBPACK_IMPORTED_MODULE_4__.ColoredTeams.Teal);\n        }\n        else {\n            this.playerTeams = [];\n            for (let i = 1; i <= numPlayerTeams; i++) {\n                this.playerTeams.push(`Team ${i}`);\n            }\n        }\n    }\n    addPlayers() {\n        if (this.config().gameConfig().gameMode !== _Game__WEBPACK_IMPORTED_MODULE_4__.GameMode.Team) {\n            this._humans.forEach((p) => this.addPlayer(p));\n            this._nations.forEach((n) => this.addPlayer(n.playerInfo));\n            return;\n        }\n        const allPlayers = [\n            ...this._humans,\n            ...this._nations.map((n) => n.playerInfo),\n        ];\n        const playerToTeam = (0,_TeamAssignment__WEBPACK_IMPORTED_MODULE_9__.assignTeams)(allPlayers, this.playerTeams);\n        for (const [playerInfo, team] of playerToTeam.entries()) {\n            if (team === \"kicked\") {\n                console.warn(`Player ${playerInfo.name} was kicked from team`);\n                continue;\n            }\n            this.addPlayer(playerInfo, team);\n        }\n    }\n    isOnEdgeOfMap(ref) {\n        return this._map.isOnEdgeOfMap(ref);\n    }\n    owner(ref) {\n        return this.playerBySmallID(this.ownerID(ref));\n    }\n    alliances() {\n        return this.alliances_;\n    }\n    playerBySmallID(id) {\n        if (id === 0) {\n            return this.terraNullius();\n        }\n        return this._playersBySmallID[id - 1];\n    }\n    map() {\n        return this._map;\n    }\n    miniMap() {\n        return this.miniGameMap;\n    }\n    addUpdate(update) {\n        this.updates[update.type].push(update);\n    }\n    nextUnitID() {\n        const old = this._nextUnitID;\n        this._nextUnitID++;\n        return old;\n    }\n    setFallout(tile, value) {\n        if (value && this.hasOwner(tile)) {\n            throw Error(`cannot set fallout, tile ${tile} has owner`);\n        }\n        if (this._map.hasFallout(tile)) {\n            return;\n        }\n        this._map.setFallout(tile, value);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.Tile,\n            update: this.toTileUpdate(tile),\n        });\n    }\n    units(...types) {\n        return Array.from(this._players.values()).flatMap((p) => p.units(...types));\n    }\n    unitCount(type) {\n        let total = 0;\n        for (const player of this._players.values()) {\n            total += player.unitCount(type);\n        }\n        return total;\n    }\n    unitInfo(type) {\n        return this.config().unitInfo(type);\n    }\n    nations() {\n        return this._nations;\n    }\n    createAllianceRequest(requestor, recipient) {\n        if (requestor.isAlliedWith(recipient)) {\n            console.log(\"cannot request alliance, already allied\");\n            return null;\n        }\n        if (recipient\n            .incomingAllianceRequests()\n            .find((ar) => ar.requestor() === requestor) !== undefined) {\n            console.log(`duplicate alliance request from ${requestor.name()}`);\n            return null;\n        }\n        const correspondingReq = requestor\n            .incomingAllianceRequests()\n            .find((ar) => ar.requestor() === recipient);\n        if (correspondingReq !== undefined) {\n            console.log(`got corresponding alliance requests, accepting`);\n            correspondingReq.accept();\n            return null;\n        }\n        const ar = new _AllianceRequestImpl__WEBPACK_IMPORTED_MODULE_3__.AllianceRequestImpl(requestor, recipient, this._ticks, this);\n        this.allianceRequests.push(ar);\n        this.addUpdate(ar.toUpdate());\n        return ar;\n    }\n    acceptAllianceRequest(request) {\n        this.allianceRequests = this.allianceRequests.filter((ar) => ar !== request);\n        const requestor = request.requestor();\n        const recipient = request.recipient();\n        const existing = requestor.allianceWith(recipient);\n        if (existing) {\n            throw new Error(`cannot accept alliance request, already allied with ${recipient.name()}`);\n        }\n        // Create and register the new alliance\n        const alliance = new _AllianceImpl__WEBPACK_IMPORTED_MODULE_2__.AllianceImpl(this, requestor, recipient, this._ticks, this.nextAllianceID++);\n        this.alliances_.push(alliance);\n        request.requestor().pastOutgoingAllianceRequests.push(request);\n        // Automatically remove embargoes only if they were automatically created\n        if (requestor.hasEmbargoAgainst(recipient))\n            requestor.endTemporaryEmbargo(recipient);\n        if (recipient.hasEmbargoAgainst(requestor))\n            recipient.endTemporaryEmbargo(requestor);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.AllianceRequestReply,\n            request: request.toUpdate(),\n            accepted: true,\n        });\n    }\n    rejectAllianceRequest(request) {\n        this.allianceRequests = this.allianceRequests.filter((ar) => ar !== request);\n        request.requestor().pastOutgoingAllianceRequests.push(request);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.AllianceRequestReply,\n            request: request.toUpdate(),\n            accepted: false,\n        });\n    }\n    hasPlayer(id) {\n        return this._players.has(id);\n    }\n    config() {\n        return this._config;\n    }\n    inSpawnPhase() {\n        return this._ticks <= this.config().numSpawnPhaseTurns();\n    }\n    ticks() {\n        return this._ticks;\n    }\n    executeNextTick() {\n        this.updates = createGameUpdatesMap();\n        this.execs.forEach((e) => {\n            if ((!this.inSpawnPhase() || e.activeDuringSpawnPhase()) &&\n                e.isActive()) {\n                e.tick(this._ticks);\n            }\n        });\n        const inited = [];\n        const unInited = [];\n        this.unInitExecs.forEach((e) => {\n            if (!this.inSpawnPhase() || e.activeDuringSpawnPhase()) {\n                e.init(this, this._ticks);\n                inited.push(e);\n            }\n            else {\n                unInited.push(e);\n            }\n        });\n        this.removeInactiveExecutions();\n        this.execs.push(...inited);\n        this.unInitExecs = unInited;\n        for (const player of this._players.values()) {\n            // Players change each to so always add them\n            this.addUpdate(player.toUpdate());\n        }\n        if (this.ticks() % 10 === 0) {\n            this.addUpdate({\n                type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.Hash,\n                tick: this.ticks(),\n                hash: this.hash(),\n            });\n        }\n        this._ticks++;\n        return this.updates;\n    }\n    hash() {\n        let hash = 1;\n        this._players.forEach((p) => {\n            hash += p.hash();\n        });\n        return hash;\n    }\n    terraNullius() {\n        return this._terraNullius;\n    }\n    removeInactiveExecutions() {\n        const activeExecs = [];\n        for (const exec of this.execs) {\n            if (this.inSpawnPhase()) {\n                if (exec.activeDuringSpawnPhase()) {\n                    if (exec.isActive()) {\n                        activeExecs.push(exec);\n                    }\n                }\n                else {\n                    activeExecs.push(exec);\n                }\n            }\n            else {\n                if (exec.isActive()) {\n                    activeExecs.push(exec);\n                }\n            }\n        }\n        this.execs = activeExecs;\n    }\n    players() {\n        return Array.from(this._players.values()).filter((p) => p.isAlive());\n    }\n    allPlayers() {\n        return Array.from(this._players.values());\n    }\n    executions() {\n        return [...this.execs, ...this.unInitExecs];\n    }\n    addExecution(...exec) {\n        this.unInitExecs.push(...exec);\n    }\n    removeExecution(exec) {\n        this.execs = this.execs.filter((execution) => execution !== exec);\n        this.unInitExecs = this.unInitExecs.filter((execution) => execution !== exec);\n    }\n    playerView(id) {\n        return this.player(id);\n    }\n    addPlayer(playerInfo, team = null) {\n        const player = new _PlayerImpl__WEBPACK_IMPORTED_MODULE_6__.PlayerImpl(this, this.nextPlayerID, playerInfo, this.config().startManpower(playerInfo), team ?? this.maybeAssignTeam(playerInfo));\n        this._playersBySmallID.push(player);\n        this.nextPlayerID++;\n        this._players.set(playerInfo.id, player);\n        return player;\n    }\n    maybeAssignTeam(player) {\n        if (this._config.gameConfig().gameMode !== _Game__WEBPACK_IMPORTED_MODULE_4__.GameMode.Team) {\n            return null;\n        }\n        if (player.playerType === _Game__WEBPACK_IMPORTED_MODULE_4__.PlayerType.Bot) {\n            return this.botTeam;\n        }\n        const rand = (0,_Util__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(player.id);\n        return this.playerTeams[rand % this.playerTeams.length];\n    }\n    player(id) {\n        const player = this._players.get(id);\n        if (player === undefined) {\n            throw new Error(`Player with id ${id} not found`);\n        }\n        return player;\n    }\n    playerByClientID(id) {\n        for (const [, player] of this._players) {\n            if (player.clientID() === id) {\n                return player;\n            }\n        }\n        return null;\n    }\n    isOnMap(cell) {\n        return (cell.x >= 0 &&\n            cell.x < this._width &&\n            cell.y >= 0 &&\n            cell.y < this._height);\n    }\n    neighborsWithDiag(tile) {\n        const x = this.x(tile);\n        const y = this.y(tile);\n        const ns = [];\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                if (dx === 0 && dy === 0)\n                    continue; // Skip the center tile\n                const newX = x + dx;\n                const newY = y + dy;\n                if (newX >= 0 &&\n                    newX < this._width &&\n                    newY >= 0 &&\n                    newY < this._height) {\n                    ns.push(this._map.ref(newX, newY));\n                }\n            }\n        }\n        return ns;\n    }\n    conquer(owner, tile) {\n        if (!this.isLand(tile)) {\n            throw Error(`cannot conquer water`);\n        }\n        const previousOwner = this.owner(tile);\n        if (previousOwner.isPlayer()) {\n            previousOwner._lastTileChange = this._ticks;\n            previousOwner._tiles.delete(tile);\n            previousOwner._borderTiles.delete(tile);\n        }\n        this._map.setOwnerID(tile, owner.smallID());\n        owner._tiles.add(tile);\n        owner._lastTileChange = this._ticks;\n        this.updateBorders(tile);\n        this._map.setFallout(tile, false);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.Tile,\n            update: this.toTileUpdate(tile),\n        });\n    }\n    relinquish(tile) {\n        if (!this.hasOwner(tile)) {\n            throw new Error(`Cannot relinquish tile because it is unowned`);\n        }\n        if (this.isWater(tile)) {\n            throw new Error(\"Cannot relinquish water\");\n        }\n        const previousOwner = this.owner(tile);\n        previousOwner._lastTileChange = this._ticks;\n        previousOwner._tiles.delete(tile);\n        previousOwner._borderTiles.delete(tile);\n        this._map.setOwnerID(tile, 0);\n        this.updateBorders(tile);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.Tile,\n            update: this.toTileUpdate(tile),\n        });\n    }\n    updateBorders(tile) {\n        const tiles = [];\n        tiles.push(tile);\n        this.neighbors(tile).forEach((t) => tiles.push(t));\n        for (const t of tiles) {\n            if (!this.hasOwner(t)) {\n                continue;\n            }\n            if (this.calcIsBorder(t)) {\n                this.owner(t)._borderTiles.add(t);\n            }\n            else {\n                this.owner(t)._borderTiles.delete(t);\n            }\n        }\n    }\n    calcIsBorder(tile) {\n        if (!this.hasOwner(tile)) {\n            return false;\n        }\n        for (const neighbor of this.neighbors(tile)) {\n            const bordersEnemy = this.owner(tile) !== this.owner(neighbor);\n            if (bordersEnemy) {\n                return true;\n            }\n        }\n        return false;\n    }\n    target(targeter, target) {\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.TargetPlayer,\n            playerID: targeter.smallID(),\n            targetID: target.smallID(),\n        });\n    }\n    breakAlliance(breaker, alliance) {\n        let other;\n        if (alliance.requestor() === breaker) {\n            other = alliance.recipient();\n        }\n        else {\n            other = alliance.requestor();\n        }\n        if (!breaker.isAlliedWith(other)) {\n            throw new Error(`${breaker} not allied with ${other}, cannot break alliance`);\n        }\n        if (!other.isTraitor() && !other.isDisconnected()) {\n            breaker.markTraitor();\n        }\n        const breakerSet = new Set(breaker.alliances());\n        const alliances = other.alliances().filter((a) => breakerSet.has(a));\n        if (alliances.length !== 1) {\n            throw new Error(`must have exactly one alliance, have ${alliances.length}`);\n        }\n        this.alliances_ = this.alliances_.filter((a) => a !== alliances[0]);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.BrokeAlliance,\n            traitorID: breaker.smallID(),\n            betrayedID: other.smallID(),\n        });\n    }\n    expireAlliance(alliance) {\n        const p1Set = new Set(alliance.recipient().alliances());\n        const alliances = alliance\n            .requestor()\n            .alliances()\n            .filter((a) => p1Set.has(a));\n        if (alliances.length !== 1) {\n            throw new Error(`cannot expire alliance: must have exactly one alliance, have ${alliances.length}`);\n        }\n        this.alliances_ = this.alliances_.filter((a) => a !== alliances[0]);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.AllianceExpired,\n            player1ID: alliance.requestor().smallID(),\n            player2ID: alliance.recipient().smallID(),\n        });\n    }\n    sendEmojiUpdate(msg) {\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.Emoji,\n            emoji: msg,\n        });\n    }\n    setWinner(winner, allPlayersStats) {\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.Win,\n            winner: this.makeWinner(winner),\n            allPlayersStats,\n        });\n    }\n    makeWinner(winner) {\n        if (typeof winner === \"string\") {\n            return [\n                \"team\",\n                winner,\n                ...this.players()\n                    .filter((p) => p.team() === winner && p.clientID() !== null)\n                    .map((p) => p.clientID()),\n            ];\n        }\n        else {\n            const clientId = winner.clientID();\n            if (clientId === null)\n                return;\n            return [\n                \"player\",\n                clientId,\n                // TODO: Assists (vote for peace)\n            ];\n        }\n    }\n    teams() {\n        if (this._config.gameConfig().gameMode !== _Game__WEBPACK_IMPORTED_MODULE_4__.GameMode.Team) {\n            return [];\n        }\n        return [this.botTeam, ...this.playerTeams];\n    }\n    displayMessage(message, type, playerID, goldAmount, params) {\n        let id = null;\n        if (playerID !== null) {\n            id = this.player(playerID).smallID();\n        }\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.DisplayEvent,\n            messageType: type,\n            message: message,\n            playerID: id,\n            goldAmount: goldAmount,\n            params: params,\n        });\n    }\n    displayChat(message, category, target, playerID, isFrom, recipient) {\n        let id = null;\n        if (playerID !== null) {\n            id = this.player(playerID).smallID();\n        }\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.DisplayChatEvent,\n            key: message,\n            category: category,\n            target: target,\n            playerID: id,\n            isFrom,\n            recipient: recipient,\n        });\n    }\n    displayIncomingUnit(unitID, message, type, playerID) {\n        const id = this.player(playerID).smallID();\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.UnitIncoming,\n            unitID: unitID,\n            message: message,\n            messageType: type,\n            playerID: id,\n        });\n    }\n    addUnit(u) {\n        this.unitGrid.addUnit(u);\n    }\n    removeUnit(u) {\n        this.unitGrid.removeUnit(u);\n        if (u.hasTrainStation()) {\n            this._railNetwork.removeStation(u);\n        }\n    }\n    updateUnitTile(u) {\n        this.unitGrid.updateUnitCell(u);\n    }\n    hasUnitNearby(tile, searchRange, type, playerId) {\n        return this.unitGrid.hasUnitNearby(tile, searchRange, type, playerId);\n    }\n    nearbyUnits(tile, searchRange, types, predicate) {\n        return this.unitGrid.nearbyUnits(tile, searchRange, types, predicate);\n    }\n    ref(x, y) {\n        return this._map.ref(x, y);\n    }\n    isValidRef(ref) {\n        return this._map.isValidRef(ref);\n    }\n    x(ref) {\n        return this._map.x(ref);\n    }\n    y(ref) {\n        return this._map.y(ref);\n    }\n    cell(ref) {\n        return this._map.cell(ref);\n    }\n    width() {\n        return this._map.width();\n    }\n    height() {\n        return this._map.height();\n    }\n    numLandTiles() {\n        return this._map.numLandTiles();\n    }\n    isValidCoord(x, y) {\n        return this._map.isValidCoord(x, y);\n    }\n    isLand(ref) {\n        return this._map.isLand(ref);\n    }\n    isOceanShore(ref) {\n        return this._map.isOceanShore(ref);\n    }\n    isOcean(ref) {\n        return this._map.isOcean(ref);\n    }\n    isShoreline(ref) {\n        return this._map.isShoreline(ref);\n    }\n    magnitude(ref) {\n        return this._map.magnitude(ref);\n    }\n    ownerID(ref) {\n        return this._map.ownerID(ref);\n    }\n    hasOwner(ref) {\n        return this._map.hasOwner(ref);\n    }\n    setOwnerID(ref, playerId) {\n        return this._map.setOwnerID(ref, playerId);\n    }\n    hasFallout(ref) {\n        return this._map.hasFallout(ref);\n    }\n    isBorder(ref) {\n        return this._map.isBorder(ref);\n    }\n    neighbors(ref) {\n        return this._map.neighbors(ref);\n    }\n    isWater(ref) {\n        return this._map.isWater(ref);\n    }\n    isLake(ref) {\n        return this._map.isLake(ref);\n    }\n    isShore(ref) {\n        return this._map.isShore(ref);\n    }\n    cost(ref) {\n        return this._map.cost(ref);\n    }\n    terrainType(ref) {\n        return this._map.terrainType(ref);\n    }\n    forEachTile(fn) {\n        return this._map.forEachTile(fn);\n    }\n    manhattanDist(c1, c2) {\n        return this._map.manhattanDist(c1, c2);\n    }\n    euclideanDistSquared(c1, c2) {\n        return this._map.euclideanDistSquared(c1, c2);\n    }\n    bfs(tile, filter) {\n        return this._map.bfs(tile, filter);\n    }\n    toTileUpdate(tile) {\n        return this._map.toTileUpdate(tile);\n    }\n    updateTile(tu) {\n        return this._map.updateTile(tu);\n    }\n    numTilesWithFallout() {\n        return this._map.numTilesWithFallout();\n    }\n    stats() {\n        return this._stats;\n    }\n    railNetwork() {\n        return this._railNetwork;\n    }\n    conquerPlayer(conqueror, conquered) {\n        const gold = conquered.gold();\n        this.displayMessage(`Conquered ${conquered.displayName()} received ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderNumber)(gold)} gold`, _Game__WEBPACK_IMPORTED_MODULE_4__.MessageType.CONQUERED_PLAYER, conqueror.id(), gold);\n        conqueror.addGold(gold);\n        conquered.removeGold(gold);\n        this.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType.ConquestEvent,\n            conquerorId: conqueror.id(),\n            conqueredId: conquered.id(),\n            gold,\n        });\n        // Record stats\n        this.stats().goldWar(conqueror, conquered, gold);\n    }\n}\n// Or a more dynamic approach that will catch new enum values:\nconst createGameUpdatesMap = () => {\n    const map = {};\n    Object.values(_GameUpdates__WEBPACK_IMPORTED_MODULE_5__.GameUpdateType)\n        .filter((key) => !isNaN(Number(key))) // Filter out reverse mappings\n        .forEach((key) => {\n        map[key] = [];\n    });\n    return map;\n};\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/GameImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/GameMap.ts":
/*!**********************************!*\
  !*** ./src/core/game/GameMap.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameMapImpl: () => (/* binding */ GameMapImpl),\n/* harmony export */   andFN: () => (/* binding */ andFN),\n/* harmony export */   euclDistFN: () => (/* binding */ euclDistFN),\n/* harmony export */   hexDistFN: () => (/* binding */ hexDistFN),\n/* harmony export */   isometricDistFN: () => (/* binding */ isometricDistFN),\n/* harmony export */   manhattanDistFN: () => (/* binding */ manhattanDistFN),\n/* harmony export */   rectDistFN: () => (/* binding */ rectDistFN)\n/* harmony export */ });\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n\nclass GameMapImpl {\n    // Bit 15 still reserved\n    constructor(width, height, terrainData, numLandTiles_) {\n        this.numLandTiles_ = numLandTiles_;\n        this._numTilesWithFallout = 0;\n        if (terrainData.length !== width * height) {\n            throw new Error(`Terrain data length ${terrainData.length} doesn't match dimensions ${width}x${height}`);\n        }\n        this.width_ = width;\n        this.height_ = height;\n        this.terrain = terrainData;\n        this.state = new Uint16Array(width * height);\n        // Precompute the LUTs\n        let ref = 0;\n        this.refToX = new Array(width * height);\n        this.refToY = new Array(width * height);\n        this.yToRef = new Array(height);\n        for (let y = 0; y < height; y++) {\n            this.yToRef[y] = ref;\n            for (let x = 0; x < width; x++) {\n                this.refToX[ref] = x;\n                this.refToY[ref] = y;\n                ref++;\n            }\n        }\n    }\n    numTilesWithFallout() {\n        return this._numTilesWithFallout;\n    }\n    ref(x, y) {\n        if (!this.isValidCoord(x, y)) {\n            throw new Error(`Invalid coordinates: ${x},${y}`);\n        }\n        return this.yToRef[y] + x;\n    }\n    isValidRef(ref) {\n        return ref >= 0 && ref < this.refToX.length;\n    }\n    x(ref) {\n        return this.refToX[ref];\n    }\n    y(ref) {\n        return this.refToY[ref];\n    }\n    cell(ref) {\n        return new _Game__WEBPACK_IMPORTED_MODULE_0__.Cell(this.x(ref), this.y(ref));\n    }\n    width() {\n        return this.width_;\n    }\n    height() {\n        return this.height_;\n    }\n    numLandTiles() {\n        return this.numLandTiles_;\n    }\n    isValidCoord(x, y) {\n        return x >= 0 && x < this.width_ && y >= 0 && y < this.height_;\n    }\n    // Terrain getters (immutable)\n    isLand(ref) {\n        return Boolean(this.terrain[ref] & (1 << GameMapImpl.IS_LAND_BIT));\n    }\n    isOceanShore(ref) {\n        return (this.isLand(ref) && this.neighbors(ref).some((tr) => this.isOcean(tr)));\n    }\n    isOcean(ref) {\n        return Boolean(this.terrain[ref] & (1 << GameMapImpl.OCEAN_BIT));\n    }\n    isShoreline(ref) {\n        return Boolean(this.terrain[ref] & (1 << GameMapImpl.SHORELINE_BIT));\n    }\n    magnitude(ref) {\n        return this.terrain[ref] & GameMapImpl.MAGNITUDE_MASK;\n    }\n    // State getters and setters (mutable)\n    ownerID(ref) {\n        return this.state[ref] & GameMapImpl.PLAYER_ID_MASK;\n    }\n    hasOwner(ref) {\n        return this.ownerID(ref) !== 0;\n    }\n    setOwnerID(ref, playerId) {\n        if (playerId > GameMapImpl.PLAYER_ID_MASK) {\n            throw new Error(`Player ID ${playerId} exceeds maximum value ${GameMapImpl.PLAYER_ID_MASK}`);\n        }\n        this.state[ref] =\n            (this.state[ref] & ~GameMapImpl.PLAYER_ID_MASK) | playerId;\n    }\n    hasFallout(ref) {\n        return Boolean(this.state[ref] & (1 << GameMapImpl.FALLOUT_BIT));\n    }\n    setFallout(ref, value) {\n        const existingFallout = this.hasFallout(ref);\n        if (value) {\n            if (!existingFallout) {\n                this._numTilesWithFallout++;\n                this.state[ref] |= 1 << GameMapImpl.FALLOUT_BIT;\n            }\n        }\n        else {\n            if (existingFallout) {\n                this._numTilesWithFallout--;\n                this.state[ref] &= ~(1 << GameMapImpl.FALLOUT_BIT);\n            }\n        }\n    }\n    isOnEdgeOfMap(ref) {\n        const x = this.x(ref);\n        const y = this.y(ref);\n        return (x === 0 || x === this.width() - 1 || y === 0 || y === this.height() - 1);\n    }\n    isBorder(ref) {\n        return this.neighbors(ref).some((tr) => this.ownerID(tr) !== this.ownerID(ref));\n    }\n    hasDefenseBonus(ref) {\n        return Boolean(this.state[ref] & (1 << GameMapImpl.DEFENSE_BONUS_BIT));\n    }\n    setDefenseBonus(ref, value) {\n        if (value) {\n            this.state[ref] |= 1 << GameMapImpl.DEFENSE_BONUS_BIT;\n        }\n        else {\n            this.state[ref] &= ~(1 << GameMapImpl.DEFENSE_BONUS_BIT);\n        }\n    }\n    // Helper methods\n    isWater(ref) {\n        return !this.isLand(ref);\n    }\n    isLake(ref) {\n        return !this.isLand(ref) && !this.isOcean(ref);\n    }\n    isShore(ref) {\n        return this.isLand(ref) && this.isShoreline(ref);\n    }\n    cost(ref) {\n        return this.magnitude(ref) < 10 ? 2 : 1;\n    }\n    terrainType(ref) {\n        if (this.isLand(ref)) {\n            const magnitude = this.magnitude(ref);\n            if (magnitude < 10)\n                return _Game__WEBPACK_IMPORTED_MODULE_0__.TerrainType.Plains;\n            if (magnitude < 20)\n                return _Game__WEBPACK_IMPORTED_MODULE_0__.TerrainType.Highland;\n            return _Game__WEBPACK_IMPORTED_MODULE_0__.TerrainType.Mountain;\n        }\n        return this.isOcean(ref) ? _Game__WEBPACK_IMPORTED_MODULE_0__.TerrainType.Ocean : _Game__WEBPACK_IMPORTED_MODULE_0__.TerrainType.Lake;\n    }\n    neighbors(ref) {\n        const neighbors = [];\n        const w = this.width_;\n        const x = this.refToX[ref];\n        if (ref >= w)\n            neighbors.push(ref - w);\n        if (ref < (this.height_ - 1) * w)\n            neighbors.push(ref + w);\n        if (x !== 0)\n            neighbors.push(ref - 1);\n        if (x !== w - 1)\n            neighbors.push(ref + 1);\n        return neighbors;\n    }\n    forEachTile(fn) {\n        for (let ref = 0; ref < this.width_ * this.height_; ref++) {\n            fn(ref);\n        }\n    }\n    manhattanDist(c1, c2) {\n        return (Math.abs(this.x(c1) - this.x(c2)) + Math.abs(this.y(c1) - this.y(c2)));\n    }\n    euclideanDistSquared(c1, c2) {\n        const x = this.x(c1) - this.x(c2);\n        const y = this.y(c1) - this.y(c2);\n        return x * x + y * y;\n    }\n    bfs(tile, filter) {\n        const seen = new Set();\n        const q = [];\n        if (filter(this, tile)) {\n            seen.add(tile);\n            q.push(tile);\n        }\n        while (q.length > 0) {\n            const curr = q.pop();\n            if (curr === undefined)\n                continue;\n            for (const n of this.neighbors(curr)) {\n                if (!seen.has(n) && filter(this, n)) {\n                    seen.add(n);\n                    q.push(n);\n                }\n            }\n        }\n        return seen;\n    }\n    toTileUpdate(tile) {\n        // Pack the tile reference and state into a bigint\n        // Format: [32 bits for tile reference][16 bits for state]\n        return (BigInt(tile) << 16n) | BigInt(this.state[tile]);\n    }\n    updateTile(tu) {\n        // Extract tile reference and state from the TileUpdate\n        // Last 16 bits are state, rest is tile reference\n        const tileRef = Number(tu >> 16n);\n        const state = Number(tu & 0xffffn);\n        const existingFallout = this.hasFallout(tileRef);\n        this.state[tileRef] = state;\n        const newFallout = this.hasFallout(tileRef);\n        if (existingFallout && !newFallout) {\n            this._numTilesWithFallout--;\n        }\n        if (!existingFallout && newFallout) {\n            this._numTilesWithFallout++;\n        }\n        return tileRef;\n    }\n}\n// Terrain bits (Uint8Array)\nGameMapImpl.IS_LAND_BIT = 7;\nGameMapImpl.SHORELINE_BIT = 6;\nGameMapImpl.OCEAN_BIT = 5;\nGameMapImpl.MAGNITUDE_MASK = 0x1f; // 11111 in binary\n// State bits (Uint16Array)\nGameMapImpl.PLAYER_ID_MASK = 0xfff;\nGameMapImpl.FALLOUT_BIT = 13;\nGameMapImpl.DEFENSE_BONUS_BIT = 14;\nfunction euclDistFN(root, dist, center = false) {\n    const dist2 = dist * dist;\n    if (!center) {\n        return (gm, n) => gm.euclideanDistSquared(root, n) <= dist2;\n    }\n    else {\n        return (gm, n) => {\n            // shifts the root tileâ€™s coordinates by -0.5 so that its â€œcenterâ€\n            // center becomes the corner of four pixels rather than the middle of one pixel.\n            // just makes things based off even pixels instead of odd. Used to use 9x9 icons now 10x10 icons etc...\n            const rootX = gm.x(root) - 0.5;\n            const rootY = gm.y(root) - 0.5;\n            const dx = gm.x(n) - rootX;\n            const dy = gm.y(n) - rootY;\n            return dx * dx + dy * dy <= dist2;\n        };\n    }\n}\nfunction manhattanDistFN(root, dist, center = false) {\n    if (!center) {\n        return (gm, n) => gm.manhattanDist(root, n) <= dist;\n    }\n    else {\n        return (gm, n) => {\n            const rootX = gm.x(root) - 0.5;\n            const rootY = gm.y(root) - 0.5;\n            const dx = Math.abs(gm.x(n) - rootX);\n            const dy = Math.abs(gm.y(n) - rootY);\n            return dx + dy <= dist;\n        };\n    }\n}\nfunction rectDistFN(root, dist, center = false) {\n    if (!center) {\n        return (gm, n) => {\n            const dx = Math.abs(gm.x(n) - gm.x(root));\n            const dy = Math.abs(gm.y(n) - gm.y(root));\n            return dx <= dist && dy <= dist;\n        };\n    }\n    else {\n        return (gm, n) => {\n            const rootX = gm.x(root) - 0.5;\n            const rootY = gm.y(root) - 0.5;\n            const dx = Math.abs(gm.x(n) - rootX);\n            const dy = Math.abs(gm.y(n) - rootY);\n            return dx <= dist && dy <= dist;\n        };\n    }\n}\nfunction isInIsometricTile(center, tile, yOffset, distance) {\n    const dx = Math.abs(tile.x - center.x);\n    const dy = Math.abs(tile.y - (center.y + yOffset));\n    return dx + dy * 2 <= distance + 1;\n}\nfunction isometricDistFN(root, dist, center = false) {\n    if (!center) {\n        return (gm, n) => gm.manhattanDist(root, n) <= dist;\n    }\n    else {\n        return (gm, n) => {\n            const rootX = gm.x(root) - 0.5;\n            const rootY = gm.y(root) - 0.5;\n            return isInIsometricTile({ x: rootX, y: rootY }, { x: gm.x(n), y: gm.y(n) }, 0, dist);\n        };\n    }\n}\nfunction hexDistFN(root, dist, center = false) {\n    if (!center) {\n        return (gm, n) => {\n            const dx = Math.abs(gm.x(n) - gm.x(root));\n            const dy = Math.abs(gm.y(n) - gm.y(root));\n            return dx <= dist && dy <= dist && dx + dy <= dist * 1.5;\n        };\n    }\n    else {\n        return (gm, n) => {\n            const rootX = gm.x(root) - 0.5;\n            const rootY = gm.y(root) - 0.5;\n            const dx = Math.abs(gm.x(n) - rootX);\n            const dy = Math.abs(gm.y(n) - rootY);\n            return dx <= dist && dy <= dist && dx + dy <= dist * 1.5;\n        };\n    }\n}\nfunction andFN(x, y) {\n    return (gm, tile) => x(gm, tile) && y(gm, tile);\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/GameMap.ts?\n}");

/***/ }),

/***/ "./src/core/game/GameUpdates.ts":
/*!**************************************!*\
  !*** ./src/core/game/GameUpdates.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameUpdateType: () => (/* binding */ GameUpdateType),\n/* harmony export */   RailType: () => (/* binding */ RailType)\n/* harmony export */ });\nvar GameUpdateType;\n(function (GameUpdateType) {\n    GameUpdateType[GameUpdateType[\"Tile\"] = 0] = \"Tile\";\n    GameUpdateType[GameUpdateType[\"Unit\"] = 1] = \"Unit\";\n    GameUpdateType[GameUpdateType[\"Player\"] = 2] = \"Player\";\n    GameUpdateType[GameUpdateType[\"DisplayEvent\"] = 3] = \"DisplayEvent\";\n    GameUpdateType[GameUpdateType[\"DisplayChatEvent\"] = 4] = \"DisplayChatEvent\";\n    GameUpdateType[GameUpdateType[\"AllianceRequest\"] = 5] = \"AllianceRequest\";\n    GameUpdateType[GameUpdateType[\"AllianceRequestReply\"] = 6] = \"AllianceRequestReply\";\n    GameUpdateType[GameUpdateType[\"BrokeAlliance\"] = 7] = \"BrokeAlliance\";\n    GameUpdateType[GameUpdateType[\"AllianceExpired\"] = 8] = \"AllianceExpired\";\n    GameUpdateType[GameUpdateType[\"AllianceExtension\"] = 9] = \"AllianceExtension\";\n    GameUpdateType[GameUpdateType[\"TargetPlayer\"] = 10] = \"TargetPlayer\";\n    GameUpdateType[GameUpdateType[\"Emoji\"] = 11] = \"Emoji\";\n    GameUpdateType[GameUpdateType[\"Win\"] = 12] = \"Win\";\n    GameUpdateType[GameUpdateType[\"Hash\"] = 13] = \"Hash\";\n    GameUpdateType[GameUpdateType[\"UnitIncoming\"] = 14] = \"UnitIncoming\";\n    GameUpdateType[GameUpdateType[\"BonusEvent\"] = 15] = \"BonusEvent\";\n    GameUpdateType[GameUpdateType[\"RailroadEvent\"] = 16] = \"RailroadEvent\";\n    GameUpdateType[GameUpdateType[\"ConquestEvent\"] = 17] = \"ConquestEvent\";\n    GameUpdateType[GameUpdateType[\"EmbargoEvent\"] = 18] = \"EmbargoEvent\";\n})(GameUpdateType || (GameUpdateType = {}));\nvar RailType;\n(function (RailType) {\n    RailType[RailType[\"VERTICAL\"] = 0] = \"VERTICAL\";\n    RailType[RailType[\"HORIZONTAL\"] = 1] = \"HORIZONTAL\";\n    RailType[RailType[\"TOP_LEFT\"] = 2] = \"TOP_LEFT\";\n    RailType[RailType[\"TOP_RIGHT\"] = 3] = \"TOP_RIGHT\";\n    RailType[RailType[\"BOTTOM_LEFT\"] = 4] = \"BOTTOM_LEFT\";\n    RailType[RailType[\"BOTTOM_RIGHT\"] = 5] = \"BOTTOM_RIGHT\";\n})(RailType || (RailType = {}));\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/GameUpdates.ts?\n}");

/***/ }),

/***/ "./src/core/game/PlayerImpl.ts":
/*!*************************************!*\
  !*** ./src/core/game/PlayerImpl.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayerImpl: () => (/* binding */ PlayerImpl)\n/* harmony export */ });\n/* harmony import */ var _client_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../client/Utils */ \"./src/client/Utils.ts\");\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _validations_username__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../validations/username */ \"./src/core/validations/username.ts\");\n/* harmony import */ var _AttackImpl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AttackImpl */ \"./src/core/game/AttackImpl.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _GameMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GameMap */ \"./src/core/game/GameMap.ts\");\n/* harmony import */ var _GameUpdates__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n/* harmony import */ var _TransportShipUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TransportShipUtils */ \"./src/core/game/TransportShipUtils.ts\");\n/* harmony import */ var _UnitImpl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UnitImpl */ \"./src/core/game/UnitImpl.ts\");\n\n\n\n\n\n\n\n\n\n\nclass Donation {\n    constructor(recipient, tick) {\n        this.recipient = recipient;\n        this.tick = tick;\n    }\n}\nclass PlayerImpl {\n    constructor(mg, _smallID, playerInfo, startTroops, _team) {\n        this.mg = mg;\n        this._smallID = _smallID;\n        this.playerInfo = playerInfo;\n        this._team = _team;\n        this._lastTileChange = 0;\n        this.markedTraitorTick = -1;\n        this.embargoes = new Map();\n        this._borderTiles = new Set();\n        this._units = [];\n        this._tiles = new Set();\n        this.pastOutgoingAllianceRequests = [];\n        this._expiredAlliances = [];\n        this.targets_ = [];\n        this.outgoingEmojis_ = [];\n        this.sentDonations = [];\n        this.relations = new Map();\n        this.lastDeleteUnitTick = -1;\n        this._incomingAttacks = [];\n        this._outgoingAttacks = [];\n        this._outgoingLandAttacks = [];\n        this._hasSpawned = false;\n        this._isDisconnected = false;\n        this.numUnitsConstructed = {};\n        this._name = (0,_validations_username__WEBPACK_IMPORTED_MODULE_3__.sanitizeUsername)(playerInfo.name);\n        this._troops = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.toInt)(startTroops);\n        this._gold = 0n;\n        this._displayName = this._name;\n        this._pseudo_random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_1__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_2__.simpleHash)(this.playerInfo.id));\n    }\n    toUpdate() {\n        const outgoingAllianceRequests = this.outgoingAllianceRequests().map((ar) => ar.recipient().id());\n        const stats = this.mg.stats().getPlayerStats(this);\n        return {\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_7__.GameUpdateType.Player,\n            clientID: this.clientID(),\n            name: this.name(),\n            displayName: this.displayName(),\n            id: this.id(),\n            team: this.team() ?? undefined,\n            smallID: this.smallID(),\n            playerType: this.type(),\n            isAlive: this.isAlive(),\n            isDisconnected: this.isDisconnected(),\n            tilesOwned: this.numTilesOwned(),\n            gold: this._gold,\n            troops: this.troops(),\n            allies: this.alliances().map((a) => a.other(this).smallID()),\n            embargoes: new Set([...this.embargoes.keys()].map((p) => p.toString())),\n            isTraitor: this.isTraitor(),\n            traitorRemainingTicks: this.getTraitorRemainingTicks(),\n            targets: this.targets().map((p) => p.smallID()),\n            outgoingEmojis: this.outgoingEmojis(),\n            outgoingAttacks: this._outgoingAttacks.map((a) => {\n                return {\n                    attackerID: a.attacker().smallID(),\n                    targetID: a.target().smallID(),\n                    troops: a.troops(),\n                    id: a.id(),\n                    retreating: a.retreating(),\n                };\n            }),\n            incomingAttacks: this._incomingAttacks.map((a) => {\n                return {\n                    attackerID: a.attacker().smallID(),\n                    targetID: a.target().smallID(),\n                    troops: a.troops(),\n                    id: a.id(),\n                    retreating: a.retreating(),\n                };\n            }),\n            outgoingAllianceRequests: outgoingAllianceRequests,\n            alliances: this.alliances().map((a) => ({\n                id: a.id(),\n                other: a.other(this).id(),\n                createdAt: a.createdAt(),\n                expiresAt: a.expiresAt(),\n            })),\n            hasSpawned: this.hasSpawned(),\n            betrayals: stats?.betrayals,\n            lastDeleteUnitTick: this.lastDeleteUnitTick,\n        };\n    }\n    smallID() {\n        return this._smallID;\n    }\n    name() {\n        return this._name;\n    }\n    displayName() {\n        return this._displayName;\n    }\n    clientID() {\n        return this.playerInfo.clientID;\n    }\n    id() {\n        return this.playerInfo.id;\n    }\n    type() {\n        return this.playerInfo.playerType;\n    }\n    clan() {\n        return this.playerInfo.clan;\n    }\n    units(...types) {\n        if (types.length === 0) {\n            return this._units;\n        }\n        const ts = new Set(types);\n        return this._units.filter((u) => ts.has(u.type()));\n    }\n    recordUnitConstructed(type) {\n        if (this.numUnitsConstructed[type] !== undefined) {\n            this.numUnitsConstructed[type]++;\n        }\n        else {\n            this.numUnitsConstructed[type] = 1;\n        }\n    }\n    // Count of units built by the player, including construction\n    unitsConstructed(type) {\n        const built = this.numUnitsConstructed[type] ?? 0;\n        let constructing = 0;\n        for (const unit of this._units) {\n            if (unit.type() !== _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Construction)\n                continue;\n            if (unit.constructionType() !== type)\n                continue;\n            constructing++;\n        }\n        const total = constructing + built;\n        return total;\n    }\n    // Count of units owned by the player, not including construction\n    unitCount(type) {\n        let total = 0;\n        for (const unit of this._units) {\n            if (unit.type() === type) {\n                total += unit.level();\n            }\n        }\n        return total;\n    }\n    // Count of units owned by the player, including construction\n    unitsOwned(type) {\n        let total = 0;\n        for (const unit of this._units) {\n            if (unit.type() === type) {\n                total += unit.level();\n                continue;\n            }\n            if (unit.type() !== _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Construction)\n                continue;\n            if (unit.constructionType() !== type)\n                continue;\n            total++;\n        }\n        return total;\n    }\n    sharesBorderWith(other) {\n        for (const border of this._borderTiles) {\n            for (const neighbor of this.mg.map().neighbors(border)) {\n                if (this.mg.map().ownerID(neighbor) === other.smallID()) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    numTilesOwned() {\n        return this._tiles.size;\n    }\n    tiles() {\n        return new Set(this._tiles.values());\n    }\n    borderTiles() {\n        return this._borderTiles;\n    }\n    neighbors() {\n        const ns = new Set();\n        for (const border of this.borderTiles()) {\n            for (const neighbor of this.mg.map().neighbors(border)) {\n                if (this.mg.map().isLand(neighbor)) {\n                    const owner = this.mg.map().ownerID(neighbor);\n                    if (owner !== this.smallID()) {\n                        ns.add(this.mg.playerBySmallID(owner));\n                    }\n                }\n            }\n        }\n        return Array.from(ns);\n    }\n    isPlayer() {\n        return true;\n    }\n    setTroops(troops) {\n        this._troops = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.toInt)(troops);\n    }\n    conquer(tile) {\n        this.mg.conquer(this, tile);\n    }\n    orderRetreat(id) {\n        const attack = this._outgoingAttacks.filter((attack) => attack.id() === id);\n        if (!attack || !attack[0]) {\n            console.warn(`Didn't find outgoing attack with id ${id}`);\n            return;\n        }\n        attack[0].orderRetreat();\n    }\n    executeRetreat(id) {\n        const attack = this._outgoingAttacks.filter((attack) => attack.id() === id);\n        // Execution is delayed so it's not an error that the attack does not exist.\n        if (!attack || !attack[0]) {\n            return;\n        }\n        attack[0].executeRetreat();\n    }\n    relinquish(tile) {\n        if (this.mg.owner(tile) !== this) {\n            throw new Error(`Cannot relinquish tile not owned by this player`);\n        }\n        this.mg.relinquish(tile);\n    }\n    info() {\n        return this.playerInfo;\n    }\n    isAlive() {\n        return this._tiles.size > 0;\n    }\n    hasSpawned() {\n        return this._hasSpawned;\n    }\n    setHasSpawned(hasSpawned) {\n        this._hasSpawned = hasSpawned;\n    }\n    incomingAllianceRequests() {\n        return this.mg.allianceRequests.filter((ar) => ar.recipient() === this);\n    }\n    outgoingAllianceRequests() {\n        return this.mg.allianceRequests.filter((ar) => ar.requestor() === this);\n    }\n    alliances() {\n        return this.mg.alliances_.filter((a) => a.requestor() === this || a.recipient() === this);\n    }\n    expiredAlliances() {\n        return [...this._expiredAlliances];\n    }\n    allies() {\n        return this.alliances().map((a) => a.other(this));\n    }\n    isAlliedWith(other) {\n        if (other === this) {\n            return false;\n        }\n        return this.allianceWith(other) !== null;\n    }\n    allianceWith(other) {\n        if (other === this) {\n            return null;\n        }\n        return (this.alliances().find((a) => a.recipient() === other || a.requestor() === other) ?? null);\n    }\n    canSendAllianceRequest(other) {\n        if (other === this) {\n            return false;\n        }\n        if (this.isFriendly(other) || !this.isAlive()) {\n            return false;\n        }\n        const hasPending = this.outgoingAllianceRequests().some((ar) => ar.recipient() === other);\n        if (hasPending) {\n            return false;\n        }\n        const recent = this.pastOutgoingAllianceRequests\n            .filter((ar) => ar.recipient() === other)\n            .sort((a, b) => b.createdAt() - a.createdAt());\n        if (recent.length === 0) {\n            return true;\n        }\n        const delta = this.mg.ticks() - recent[0].createdAt();\n        return delta >= this.mg.config().allianceRequestCooldown();\n    }\n    breakAlliance(alliance) {\n        this.mg.breakAlliance(this, alliance);\n    }\n    isTraitor() {\n        return this.getTraitorRemainingTicks() > 0;\n    }\n    getTraitorRemainingTicks() {\n        if (this.markedTraitorTick < 0)\n            return 0;\n        const elapsed = this.mg.ticks() - this.markedTraitorTick;\n        const duration = this.mg.config().traitorDuration();\n        const remaining = duration - elapsed;\n        return remaining > 0 ? remaining : 0;\n    }\n    markTraitor() {\n        this.markedTraitorTick = this.mg.ticks();\n        // Record stats\n        this.mg.stats().betray(this);\n    }\n    createAllianceRequest(recipient) {\n        if (this.isAlliedWith(recipient)) {\n            throw new Error(`cannot create alliance request, already allies`);\n        }\n        return this.mg.createAllianceRequest(this, recipient);\n    }\n    relation(other) {\n        if (other === this) {\n            throw new Error(`cannot get relation with self: ${this}`);\n        }\n        const relation = this.relations.get(other) ?? 0;\n        return this.relationFromValue(relation);\n    }\n    relationFromValue(relationValue) {\n        if (relationValue < -50) {\n            return _Game__WEBPACK_IMPORTED_MODULE_5__.Relation.Hostile;\n        }\n        if (relationValue < 0) {\n            return _Game__WEBPACK_IMPORTED_MODULE_5__.Relation.Distrustful;\n        }\n        if (relationValue < 50) {\n            return _Game__WEBPACK_IMPORTED_MODULE_5__.Relation.Neutral;\n        }\n        return _Game__WEBPACK_IMPORTED_MODULE_5__.Relation.Friendly;\n    }\n    allRelationsSorted() {\n        return Array.from(this.relations, ([k, v]) => ({ player: k, relation: v }))\n            .sort((a, b) => a.relation - b.relation)\n            .map((r) => ({\n            player: r.player,\n            relation: this.relationFromValue(r.relation),\n        }));\n    }\n    updateRelation(other, delta) {\n        if (other === this) {\n            throw new Error(`cannot update relation with self: ${this}`);\n        }\n        const relation = this.relations.get(other) ?? 0;\n        const newRelation = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.within)(relation + delta, -100, 100);\n        this.relations.set(other, newRelation);\n    }\n    decayRelations() {\n        this.relations.forEach((r, p) => {\n            const sign = -1 * Math.sign(r);\n            const delta = 0.05;\n            r += sign * delta;\n            if (Math.abs(r) < delta * 2) {\n                r = 0;\n            }\n            this.relations.set(p, r);\n        });\n    }\n    canTarget(other) {\n        if (this === other) {\n            return false;\n        }\n        if (this.isFriendly(other)) {\n            return false;\n        }\n        for (const t of this.targets_) {\n            if (this.mg.ticks() - t.tick < this.mg.config().targetCooldown()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    target(other) {\n        this.targets_.push({ tick: this.mg.ticks(), target: other });\n        this.mg.target(this, other);\n    }\n    targets() {\n        return this.targets_\n            .filter((t) => this.mg.ticks() - t.tick < this.mg.config().targetDuration())\n            .map((t) => t.target);\n    }\n    transitiveTargets() {\n        const ts = this.alliances()\n            .map((a) => a.other(this))\n            .flatMap((ally) => ally.targets());\n        ts.push(...this.targets());\n        return [...new Set(ts)];\n    }\n    sendEmoji(recipient, emoji) {\n        if (recipient === this) {\n            throw Error(`Cannot send emoji to oneself: ${this}`);\n        }\n        const msg = {\n            message: emoji,\n            senderID: this.smallID(),\n            recipientID: recipient === _Game__WEBPACK_IMPORTED_MODULE_5__.AllPlayers ? recipient : recipient.smallID(),\n            createdAt: this.mg.ticks(),\n        };\n        this.outgoingEmojis_.push(msg);\n        this.mg.sendEmojiUpdate(msg);\n    }\n    outgoingEmojis() {\n        return this.outgoingEmojis_\n            .filter((e) => this.mg.ticks() - e.createdAt <\n            this.mg.config().emojiMessageDuration())\n            .sort((a, b) => b.createdAt - a.createdAt);\n    }\n    canSendEmoji(recipient) {\n        if (recipient === this) {\n            return false;\n        }\n        const recipientID = recipient === _Game__WEBPACK_IMPORTED_MODULE_5__.AllPlayers ? _Game__WEBPACK_IMPORTED_MODULE_5__.AllPlayers : recipient.smallID();\n        const prevMsgs = this.outgoingEmojis_.filter((msg) => msg.recipientID === recipientID);\n        for (const msg of prevMsgs) {\n            if (this.mg.ticks() - msg.createdAt <\n                this.mg.config().emojiMessageCooldown()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    canDonateGold(recipient) {\n        if (!this.isAlive() ||\n            !recipient.isAlive() ||\n            !this.isFriendly(recipient)) {\n            return false;\n        }\n        if (recipient.type() === _Game__WEBPACK_IMPORTED_MODULE_5__.PlayerType.Human &&\n            this.mg.config().donateGold() === false) {\n            return false;\n        }\n        for (const donation of this.sentDonations) {\n            if (donation.recipient === recipient) {\n                if (this.mg.ticks() - donation.tick <\n                    this.mg.config().donateCooldown()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    canDonateTroops(recipient) {\n        if (!this.isAlive() ||\n            !recipient.isAlive() ||\n            !this.isFriendly(recipient)) {\n            return false;\n        }\n        if (recipient.type() === _Game__WEBPACK_IMPORTED_MODULE_5__.PlayerType.Human &&\n            this.mg.config().donateTroops() === false) {\n            return false;\n        }\n        for (const donation of this.sentDonations) {\n            if (donation.recipient === recipient) {\n                if (this.mg.ticks() - donation.tick <\n                    this.mg.config().donateCooldown()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    donateTroops(recipient, troops) {\n        if (troops <= 0)\n            return false;\n        const removed = this.removeTroops(troops);\n        if (removed === 0)\n            return false;\n        recipient.addTroops(removed);\n        this.sentDonations.push(new Donation(recipient, this.mg.ticks()));\n        this.mg.displayMessage(`Sent ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderTroops)(troops)} troops to ${recipient.name()}`, _Game__WEBPACK_IMPORTED_MODULE_5__.MessageType.SENT_TROOPS_TO_PLAYER, this.id());\n        this.mg.displayMessage(`Received ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderTroops)(troops)} troops from ${this.name()}`, _Game__WEBPACK_IMPORTED_MODULE_5__.MessageType.RECEIVED_TROOPS_FROM_PLAYER, recipient.id());\n        return true;\n    }\n    donateGold(recipient, gold) {\n        if (gold <= 0n)\n            return false;\n        const removed = this.removeGold(gold);\n        if (removed === 0n)\n            return false;\n        recipient.addGold(removed);\n        this.sentDonations.push(new Donation(recipient, this.mg.ticks()));\n        this.mg.displayMessage(`Sent ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderNumber)(gold)} gold to ${recipient.name()}`, _Game__WEBPACK_IMPORTED_MODULE_5__.MessageType.SENT_GOLD_TO_PLAYER, this.id());\n        this.mg.displayMessage(`Received ${(0,_client_Utils__WEBPACK_IMPORTED_MODULE_0__.renderNumber)(gold)} gold from ${this.name()}`, _Game__WEBPACK_IMPORTED_MODULE_5__.MessageType.RECEIVED_GOLD_FROM_PLAYER, recipient.id(), gold);\n        return true;\n    }\n    canDeleteUnit() {\n        return (this.mg.ticks() - this.lastDeleteUnitTick >=\n            this.mg.config().deleteUnitCooldown());\n    }\n    recordDeleteUnit() {\n        this.lastDeleteUnitTick = this.mg.ticks();\n    }\n    hasEmbargoAgainst(other) {\n        return this.embargoes.has(other.id());\n    }\n    canTrade(other) {\n        const embargo = other.hasEmbargoAgainst(this) || this.hasEmbargoAgainst(other);\n        return !embargo && other.id() !== this.id();\n    }\n    getEmbargoes() {\n        return [...this.embargoes.values()];\n    }\n    addEmbargo(other, isTemporary) {\n        const embargo = this.embargoes.get(other.id());\n        if (embargo !== undefined && !embargo.isTemporary)\n            return;\n        this.mg.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_7__.GameUpdateType.EmbargoEvent,\n            event: \"start\",\n            playerID: this.smallID(),\n            embargoedID: other.smallID(),\n        });\n        this.embargoes.set(other.id(), {\n            createdAt: this.mg.ticks(),\n            isTemporary: isTemporary,\n            target: other,\n        });\n    }\n    stopEmbargo(other) {\n        this.embargoes.delete(other.id());\n        this.mg.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_7__.GameUpdateType.EmbargoEvent,\n            event: \"stop\",\n            playerID: this.smallID(),\n            embargoedID: other.smallID(),\n        });\n    }\n    endTemporaryEmbargo(other) {\n        const embargo = this.embargoes.get(other.id());\n        if (embargo !== undefined && !embargo.isTemporary)\n            return;\n        this.stopEmbargo(other);\n    }\n    tradingPartners() {\n        return this.mg\n            .players()\n            .filter((other) => other !== this && this.canTrade(other));\n    }\n    team() {\n        return this._team;\n    }\n    isOnSameTeam(other) {\n        if (other === this) {\n            return false;\n        }\n        if (this.team() === null || other.team() === null) {\n            return false;\n        }\n        if (this.team() === _Game__WEBPACK_IMPORTED_MODULE_5__.ColoredTeams.Bot || other.team() === _Game__WEBPACK_IMPORTED_MODULE_5__.ColoredTeams.Bot) {\n            return false;\n        }\n        return this._team === other.team();\n    }\n    isFriendly(other) {\n        if (other.isDisconnected()) {\n            return false;\n        }\n        return this.isOnSameTeam(other) || this.isAlliedWith(other);\n    }\n    gold() {\n        return this._gold;\n    }\n    addGold(toAdd, tile) {\n        this._gold += toAdd;\n        if (tile) {\n            this.mg.addUpdate({\n                type: _GameUpdates__WEBPACK_IMPORTED_MODULE_7__.GameUpdateType.BonusEvent,\n                player: this.id(),\n                tile,\n                gold: Number(toAdd),\n                troops: 0,\n            });\n        }\n    }\n    removeGold(toRemove) {\n        if (toRemove <= 0n) {\n            return 0n;\n        }\n        const actualRemoved = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.minInt)(this._gold, toRemove);\n        this._gold -= actualRemoved;\n        return actualRemoved;\n    }\n    troops() {\n        return Number(this._troops);\n    }\n    addTroops(troops) {\n        if (troops < 0) {\n            this.removeTroops(-1 * troops);\n            return;\n        }\n        this._troops += (0,_Util__WEBPACK_IMPORTED_MODULE_2__.toInt)(troops);\n    }\n    removeTroops(troops) {\n        if (troops <= 0) {\n            return 0;\n        }\n        const toRemove = (0,_Util__WEBPACK_IMPORTED_MODULE_2__.minInt)(this._troops, (0,_Util__WEBPACK_IMPORTED_MODULE_2__.toInt)(troops));\n        this._troops -= toRemove;\n        return Number(toRemove);\n    }\n    captureUnit(unit) {\n        if (unit.owner() === this) {\n            throw new Error(`Cannot capture unit, ${this} already owns ${unit}`);\n        }\n        unit.setOwner(this);\n    }\n    buildUnit(type, spawnTile, params) {\n        if (this.mg.config().isUnitDisabled(type)) {\n            throw new Error(`Attempted to build disabled unit ${type} at tile ${spawnTile} by player ${this.name()}`);\n        }\n        const cost = this.mg.unitInfo(type).cost(this);\n        const b = new _UnitImpl__WEBPACK_IMPORTED_MODULE_9__.UnitImpl(type, this.mg, spawnTile, this.mg.nextUnitID(), this, params);\n        this._units.push(b);\n        this.recordUnitConstructed(type);\n        this.removeGold(cost);\n        this.removeTroops(\"troops\" in params ? (params.troops ?? 0) : 0);\n        this.mg.addUpdate(b.toUpdate());\n        this.mg.addUnit(b);\n        return b;\n    }\n    findUnitToUpgrade(type, targetTile) {\n        const range = this.mg.config().structureMinDist();\n        const existing = this.mg\n            .nearbyUnits(targetTile, range, type)\n            .sort((a, b) => a.distSquared - b.distSquared);\n        if (existing.length === 0) {\n            return false;\n        }\n        const unit = existing[0].unit;\n        if (!this.canUpgradeUnit(unit.type())) {\n            return false;\n        }\n        return unit;\n    }\n    canUpgradeUnit(unitType) {\n        if (!this.mg.config().unitInfo(unitType).upgradable) {\n            return false;\n        }\n        if (this.mg.config().isUnitDisabled(unitType)) {\n            return false;\n        }\n        if (this._gold < this.mg.config().unitInfo(unitType).cost(this)) {\n            return false;\n        }\n        return true;\n    }\n    upgradeUnit(unit) {\n        const cost = this.mg.unitInfo(unit.type()).cost(this);\n        this.removeGold(cost);\n        unit.increaseLevel();\n        this.recordUnitConstructed(unit.type());\n    }\n    buildableUnits(tile) {\n        const validTiles = tile !== null ? this.validStructureSpawnTiles(tile) : [];\n        return Object.values(_Game__WEBPACK_IMPORTED_MODULE_5__.UnitType).map((u) => {\n            let canUpgrade = false;\n            if (!this.mg.inSpawnPhase()) {\n                const existingUnit = tile !== null && this.findUnitToUpgrade(u, tile);\n                if (existingUnit !== false) {\n                    canUpgrade = existingUnit.id();\n                }\n            }\n            return {\n                type: u,\n                canBuild: this.mg.inSpawnPhase() || tile === null\n                    ? false\n                    : this.canBuild(u, tile, validTiles),\n                canUpgrade: canUpgrade,\n                cost: this.mg.config().unitInfo(u).cost(this),\n            };\n        });\n    }\n    canBuild(unitType, targetTile, validTiles = null) {\n        if (this.mg.config().isUnitDisabled(unitType)) {\n            return false;\n        }\n        const cost = this.mg.unitInfo(unitType).cost(this);\n        if (!this.isAlive() || this.gold() < cost) {\n            return false;\n        }\n        switch (unitType) {\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.MIRV:\n                if (!this.mg.hasOwner(targetTile)) {\n                    return false;\n                }\n                return this.nukeSpawn(targetTile);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.AtomBomb:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.HydrogenBomb:\n                return this.nukeSpawn(targetTile);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.MIRVWarhead:\n                return targetTile;\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Port:\n                return this.portSpawn(targetTile, validTiles);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Warship:\n                return this.warshipSpawn(targetTile);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Shell:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.SAMMissile:\n                return targetTile;\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.TransportShip:\n                return (0,_TransportShipUtils__WEBPACK_IMPORTED_MODULE_8__.canBuildTransportShip)(this.mg, this, targetTile);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.TradeShip:\n                return this.tradeShipSpawn(targetTile);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Train:\n                return this.landBasedUnitSpawn(targetTile);\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.MissileSilo:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.DefensePost:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.SAMLauncher:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.City:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Factory:\n            case _Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Construction:\n                return this.landBasedStructureSpawn(targetTile, validTiles);\n            default:\n                (0,_Util__WEBPACK_IMPORTED_MODULE_2__.assertNever)(unitType);\n        }\n    }\n    nukeSpawn(tile) {\n        const owner = this.mg.owner(tile);\n        if (owner.isPlayer()) {\n            if (this.isOnSameTeam(owner)) {\n                return false;\n            }\n        }\n        // only get missilesilos that are not on cooldown\n        const spawns = this.units(_Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.MissileSilo)\n            .filter((silo) => {\n            return !silo.isInCooldown();\n        })\n            .sort((0,_Util__WEBPACK_IMPORTED_MODULE_2__.distSortUnit)(this.mg, tile));\n        if (spawns.length === 0) {\n            return false;\n        }\n        return spawns[0].tile();\n    }\n    portSpawn(tile, validTiles) {\n        const spawns = Array.from(this.mg.bfs(tile, (0,_GameMap__WEBPACK_IMPORTED_MODULE_6__.manhattanDistFN)(tile, this.mg.config().radiusPortSpawn())))\n            .filter((t) => this.mg.owner(t) === this && this.mg.isOceanShore(t))\n            .sort((a, b) => this.mg.manhattanDist(a, tile) - this.mg.manhattanDist(b, tile));\n        const validTileSet = new Set(validTiles ?? this.validStructureSpawnTiles(tile));\n        for (const t of spawns) {\n            if (validTileSet.has(t)) {\n                return t;\n            }\n        }\n        return false;\n    }\n    warshipSpawn(tile) {\n        if (!this.mg.isOcean(tile)) {\n            return false;\n        }\n        const spawns = this.units(_Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Port).sort((a, b) => this.mg.manhattanDist(a.tile(), tile) -\n            this.mg.manhattanDist(b.tile(), tile));\n        if (spawns.length === 0) {\n            return false;\n        }\n        return spawns[0].tile();\n    }\n    landBasedUnitSpawn(tile) {\n        return this.mg.isLand(tile) ? tile : false;\n    }\n    landBasedStructureSpawn(tile, validTiles = null) {\n        const tiles = validTiles ?? this.validStructureSpawnTiles(tile);\n        if (tiles.length === 0) {\n            return false;\n        }\n        return tiles[0];\n    }\n    validStructureSpawnTiles(tile) {\n        if (this.mg.owner(tile) !== this) {\n            return [];\n        }\n        const searchRadius = 15;\n        const searchRadiusSquared = searchRadius ** 2;\n        const types = Object.values(_Game__WEBPACK_IMPORTED_MODULE_5__.UnitType).filter((unitTypeValue) => {\n            return this.mg.config().unitInfo(unitTypeValue).territoryBound;\n        });\n        const nearbyUnits = this.mg.nearbyUnits(tile, searchRadius * 2, types);\n        const nearbyTiles = this.mg.bfs(tile, (gm, t) => {\n            return (this.mg.euclideanDistSquared(tile, t) < searchRadiusSquared &&\n                gm.ownerID(t) === this.smallID());\n        });\n        const validSet = new Set(nearbyTiles);\n        const minDistSquared = this.mg.config().structureMinDist() ** 2;\n        for (const t of nearbyTiles) {\n            for (const { unit } of nearbyUnits) {\n                if (this.mg.euclideanDistSquared(unit.tile(), t) < minDistSquared) {\n                    validSet.delete(t);\n                    break;\n                }\n            }\n        }\n        const valid = Array.from(validSet);\n        valid.sort((a, b) => this.mg.euclideanDistSquared(a, tile) -\n            this.mg.euclideanDistSquared(b, tile));\n        return valid;\n    }\n    tradeShipSpawn(targetTile) {\n        const spawns = this.units(_Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Port).filter((u) => u.tile() === targetTile);\n        if (spawns.length === 0) {\n            return false;\n        }\n        return spawns[0].tile();\n    }\n    lastTileChange() {\n        return this._lastTileChange;\n    }\n    isDisconnected() {\n        return this._isDisconnected;\n    }\n    markDisconnected(isDisconnected) {\n        this._isDisconnected = isDisconnected;\n    }\n    hash() {\n        return ((0,_Util__WEBPACK_IMPORTED_MODULE_2__.simpleHash)(this.id()) * (this.troops() + this.numTilesOwned()) +\n            this._units.reduce((acc, unit) => acc + unit.hash(), 0));\n    }\n    toString() {\n        return `Player:{name:${this.info().name},clientID:${this.info().clientID},isAlive:${this.isAlive()},troops:${this._troops},numTileOwned:${this.numTilesOwned()}}]`;\n    }\n    playerProfile() {\n        const rel = {\n            relations: Object.fromEntries(this.allRelationsSorted().map(({ player, relation }) => [\n                player.smallID(),\n                relation,\n            ])),\n            alliances: this.alliances().map((a) => a.other(this).smallID()),\n        };\n        return rel;\n    }\n    createAttack(target, troops, sourceTile, border) {\n        const attack = new _AttackImpl__WEBPACK_IMPORTED_MODULE_4__.AttackImpl(this._pseudo_random.nextID(), target, this, troops, sourceTile, border, this.mg);\n        this._outgoingAttacks.push(attack);\n        if (target.isPlayer()) {\n            target._incomingAttacks.push(attack);\n        }\n        return attack;\n    }\n    outgoingAttacks() {\n        return this._outgoingAttacks;\n    }\n    incomingAttacks() {\n        return this._incomingAttacks;\n    }\n    canAttack(tile) {\n        if (this.mg.hasOwner(tile) &&\n            this.mg.config().numSpawnPhaseTurns() +\n                this.mg.config().spawnImmunityDuration() >\n                this.mg.ticks()) {\n            return false;\n        }\n        if (this.mg.owner(tile) === this) {\n            return false;\n        }\n        const other = this.mg.owner(tile);\n        if (other.isPlayer()) {\n            if (this.isFriendly(other)) {\n                return false;\n            }\n        }\n        if (!this.mg.isLand(tile)) {\n            return false;\n        }\n        if (this.mg.hasOwner(tile)) {\n            return this.sharesBorderWith(other);\n        }\n        else {\n            for (const t of this.mg.bfs(tile, (0,_GameMap__WEBPACK_IMPORTED_MODULE_6__.andFN)((gm, t) => !gm.hasOwner(t) && gm.isLand(t), (0,_GameMap__WEBPACK_IMPORTED_MODULE_6__.manhattanDistFN)(tile, 200)))) {\n                for (const n of this.mg.neighbors(t)) {\n                    if (this.mg.owner(n) === this) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    bestTransportShipSpawn(targetTile) {\n        return (0,_TransportShipUtils__WEBPACK_IMPORTED_MODULE_8__.bestShoreDeploymentSource)(this.mg, this, targetTile);\n    }\n    // It's a probability list, so if an element appears twice it's because it's\n    // twice more likely to be picked later.\n    tradingPorts(port) {\n        const ports = this.mg\n            .players()\n            .filter((p) => p !== port.owner() && p.canTrade(port.owner()))\n            .flatMap((p) => p.units(_Game__WEBPACK_IMPORTED_MODULE_5__.UnitType.Port))\n            .sort((p1, p2) => {\n            return (this.mg.manhattanDist(port.tile(), p1.tile()) -\n                this.mg.manhattanDist(port.tile(), p2.tile()));\n        });\n        const weightedPorts = [];\n        for (const [i, otherPort] of ports.entries()) {\n            const expanded = new Array(otherPort.level()).fill(otherPort);\n            weightedPorts.push(...expanded);\n            if (i < this.mg.config().proximityBonusPortsNb(ports.length)) {\n                weightedPorts.push(...expanded);\n            }\n            if (port.owner().isFriendly(otherPort.owner())) {\n                weightedPorts.push(...expanded);\n            }\n        }\n        return weightedPorts;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/PlayerImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/RailNetworkImpl.ts":
/*!******************************************!*\
  !*** ./src/core/game/RailNetworkImpl.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RailNetworkImpl: () => (/* binding */ RailNetworkImpl),\n/* harmony export */   StationManagerImpl: () => (/* binding */ StationManagerImpl),\n/* harmony export */   createRailNetwork: () => (/* binding */ createRailNetwork)\n/* harmony export */ });\n/* harmony import */ var _execution_RailroadExecution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../execution/RailroadExecution */ \"./src/core/execution/RailroadExecution.ts\");\n/* harmony import */ var _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/AStar */ \"./src/core/pathfinding/AStar.ts\");\n/* harmony import */ var _pathfinding_MiniAStar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pathfinding/MiniAStar */ \"./src/core/pathfinding/MiniAStar.ts\");\n/* harmony import */ var _pathfinding_SerialAStar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pathfinding/SerialAStar */ \"./src/core/pathfinding/SerialAStar.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _Railroad__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Railroad */ \"./src/core/game/Railroad.ts\");\n/* harmony import */ var _TrainStation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TrainStation */ \"./src/core/game/TrainStation.ts\");\n\n\n\n\n\n\n\nclass StationManagerImpl {\n    constructor() {\n        this.stations = new Set();\n    }\n    addStation(station) {\n        this.stations.add(station);\n    }\n    removeStation(station) {\n        this.stations.delete(station);\n    }\n    findStation(unit) {\n        for (const station of this.stations) {\n            if (station.unit === unit)\n                return station;\n        }\n        return null;\n    }\n    getAll() {\n        return this.stations;\n    }\n}\nclass RailPathFinderServiceImpl {\n    constructor(game) {\n        this.game = game;\n    }\n    findTilePath(from, to) {\n        const astar = new _pathfinding_MiniAStar__WEBPACK_IMPORTED_MODULE_2__.MiniAStar(this.game.map(), this.game.miniMap(), from, to, 5000, 20, false, 3);\n        return astar.compute() === _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed\n            ? astar.reconstructPath()\n            : [];\n    }\n    findStationsPath(from, to) {\n        const stationAStar = new _pathfinding_SerialAStar__WEBPACK_IMPORTED_MODULE_3__.SerialAStar(from, to, 5000, 20, new _TrainStation__WEBPACK_IMPORTED_MODULE_6__.TrainStationMapAdapter(this.game));\n        return stationAStar.compute() === _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed\n            ? stationAStar.reconstructPath()\n            : [];\n    }\n}\nfunction createRailNetwork(game) {\n    const stationManager = new StationManagerImpl();\n    const pathService = new RailPathFinderServiceImpl(game);\n    return new RailNetworkImpl(game, stationManager, pathService);\n}\nclass RailNetworkImpl {\n    constructor(game, stationManager, pathService) {\n        this.game = game;\n        this.stationManager = stationManager;\n        this.pathService = pathService;\n        this.maxConnectionDistance = 4;\n    }\n    connectStation(station) {\n        this.stationManager.addStation(station);\n        this.connectToNearbyStations(station);\n    }\n    removeStation(unit) {\n        const station = this.stationManager.findStation(unit);\n        if (!station)\n            return;\n        const neighbors = station.neighbors();\n        this.disconnectFromNetwork(station);\n        this.stationManager.removeStation(station);\n        const cluster = station.getCluster();\n        if (!cluster)\n            return;\n        if (neighbors.length === 1) {\n            cluster.removeStation(station);\n        }\n        else if (neighbors.length > 1) {\n            for (const neighbor of neighbors) {\n                const stations = this.computeCluster(neighbor);\n                const newCluster = new _TrainStation__WEBPACK_IMPORTED_MODULE_6__.Cluster();\n                newCluster.addStations(stations);\n            }\n        }\n        station.unit.setTrainStation(false);\n    }\n    /**\n     * Return the intermediary stations connecting two stations\n     */\n    findStationsPath(from, to) {\n        return this.pathService.findStationsPath(from, to);\n    }\n    connectToNearbyStations(station) {\n        const neighbors = this.game.nearbyUnits(station.tile(), this.game.config().trainStationMaxRange(), [_Game__WEBPACK_IMPORTED_MODULE_4__.UnitType.City, _Game__WEBPACK_IMPORTED_MODULE_4__.UnitType.Factory, _Game__WEBPACK_IMPORTED_MODULE_4__.UnitType.Port]);\n        const editedClusters = new Set();\n        neighbors.sort((a, b) => a.distSquared - b.distSquared);\n        for (const neighbor of neighbors) {\n            if (neighbor.unit === station.unit)\n                continue;\n            const neighborStation = this.stationManager.findStation(neighbor.unit);\n            if (!neighborStation)\n                continue;\n            const distanceToStation = this.distanceFrom(neighborStation, station, this.maxConnectionDistance);\n            const neighborCluster = neighborStation.getCluster();\n            if (neighborCluster === null)\n                continue;\n            const connectionAvailable = distanceToStation > this.maxConnectionDistance ||\n                distanceToStation === -1;\n            if (connectionAvailable &&\n                neighbor.distSquared > this.game.config().trainStationMinRange() ** 2) {\n                if (this.connect(station, neighborStation)) {\n                    neighborCluster.addStation(station);\n                    editedClusters.add(neighborCluster);\n                }\n            }\n        }\n        // If multiple clusters own the new station, merge them into a single cluster\n        if (editedClusters.size > 1) {\n            this.mergeClusters(editedClusters);\n        }\n        else if (editedClusters.size === 0) {\n            // If no cluster owns the station, creates a new one for it\n            const newCluster = new _TrainStation__WEBPACK_IMPORTED_MODULE_6__.Cluster();\n            newCluster.addStation(station);\n        }\n    }\n    disconnectFromNetwork(station) {\n        for (const rail of station.getRailroads()) {\n            rail.delete(this.game);\n        }\n        station.clearRailroads();\n        const cluster = station.getCluster();\n        if (cluster !== null && cluster.size() === 1) {\n            this.deleteCluster(cluster);\n        }\n    }\n    deleteCluster(cluster) {\n        for (const station of cluster.stations) {\n            station.setCluster(null);\n        }\n        cluster.clear();\n    }\n    connect(from, to) {\n        const path = this.pathService.findTilePath(from.tile(), to.tile());\n        if (path.length > 0 && path.length < this.game.config().railroadMaxSize()) {\n            const railRoad = new _Railroad__WEBPACK_IMPORTED_MODULE_5__.Railroad(from, to, path);\n            this.game.addExecution(new _execution_RailroadExecution__WEBPACK_IMPORTED_MODULE_0__.RailroadExecution(railRoad));\n            from.addRailroad(railRoad);\n            to.addRailroad(railRoad);\n            return true;\n        }\n        return false;\n    }\n    distanceFrom(start, dest, maxDistance) {\n        if (start === dest)\n            return 0;\n        const visited = new Set();\n        const queue = [\n            { station: start, distance: 0 },\n        ];\n        while (queue.length > 0) {\n            const { station, distance } = queue.shift();\n            if (visited.has(station))\n                continue;\n            visited.add(station);\n            if (distance >= maxDistance)\n                continue;\n            for (const neighbor of station.neighbors()) {\n                if (neighbor === dest)\n                    return distance + 1;\n                if (!visited.has(neighbor)) {\n                    queue.push({ station: neighbor, distance: distance + 1 });\n                }\n            }\n        }\n        // If destination not found within maxDistance\n        return -1;\n    }\n    computeCluster(start) {\n        const visited = new Set();\n        const queue = [start];\n        while (queue.length > 0) {\n            const current = queue.shift();\n            if (visited.has(current))\n                continue;\n            visited.add(current);\n            for (const neighbor of current.neighbors()) {\n                if (!visited.has(neighbor))\n                    queue.push(neighbor);\n            }\n        }\n        return visited;\n    }\n    mergeClusters(clustersToMerge) {\n        const merged = new _TrainStation__WEBPACK_IMPORTED_MODULE_6__.Cluster();\n        for (const cluster of clustersToMerge) {\n            merged.merge(cluster);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/RailNetworkImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/Railroad.ts":
/*!***********************************!*\
  !*** ./src/core/game/Railroad.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrientedRailroad: () => (/* binding */ OrientedRailroad),\n/* harmony export */   Railroad: () => (/* binding */ Railroad),\n/* harmony export */   getOrientedRailroad: () => (/* binding */ getOrientedRailroad)\n/* harmony export */ });\n/* harmony import */ var _GameUpdates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n\nclass Railroad {\n    constructor(from, to, tiles) {\n        this.from = from;\n        this.to = to;\n        this.tiles = tiles;\n    }\n    delete(game) {\n        const railTiles = this.tiles.map((tile) => ({\n            tile,\n            railType: _GameUpdates__WEBPACK_IMPORTED_MODULE_0__.RailType.VERTICAL,\n        }));\n        game.addUpdate({\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_0__.GameUpdateType.RailroadEvent,\n            isActive: false,\n            railTiles,\n        });\n        this.from.getRailroads().delete(this);\n        this.to.getRailroads().delete(this);\n    }\n}\nfunction getOrientedRailroad(from, to) {\n    for (const railroad of from.getRailroads()) {\n        if (railroad.from === to) {\n            return new OrientedRailroad(railroad, false);\n        }\n        else if (railroad.to === to) {\n            return new OrientedRailroad(railroad, true);\n        }\n    }\n    return null;\n}\n/**\n * Wrap a railroad with a direction so it always starts at tiles[0]\n */\nclass OrientedRailroad {\n    constructor(railroad, forward) {\n        this.railroad = railroad;\n        this.forward = forward;\n        this.tiles = [];\n        this.tiles = this.forward\n            ? this.railroad.tiles\n            : [...this.railroad.tiles].reverse();\n    }\n    getTiles() {\n        return this.tiles;\n    }\n    getStart() {\n        return this.forward ? this.railroad.from : this.railroad.to;\n    }\n    getEnd() {\n        return this.forward ? this.railroad.to : this.railroad.from;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/Railroad.ts?\n}");

/***/ }),

/***/ "./src/core/game/StatsImpl.ts":
/*!************************************!*\
  !*** ./src/core/game/StatsImpl.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StatsImpl: () => (/* binding */ StatsImpl)\n/* harmony export */ });\n/* harmony import */ var _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../StatsSchemas */ \"./src/core/StatsSchemas.ts\");\n\nfunction _bigint(value) {\n    switch (typeof value) {\n        case \"bigint\":\n            return value;\n        case \"number\":\n            return BigInt(Math.floor(value));\n    }\n}\nclass StatsImpl {\n    constructor() {\n        this.data = {};\n    }\n    getPlayerStats(player) {\n        const clientID = player.clientID();\n        if (clientID === null)\n            return undefined;\n        return this.data[clientID];\n    }\n    stats() {\n        return this.data;\n    }\n    _makePlayerStats(player) {\n        const clientID = player.clientID();\n        if (clientID === null)\n            return undefined;\n        if (clientID in this.data) {\n            return this.data[clientID];\n        }\n        const data = {};\n        this.data[clientID] = data;\n        return data;\n    }\n    _addAttack(player, index, value) {\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        p.attacks ?? (p.attacks = [0n]);\n        while (p.attacks.length <= index)\n            p.attacks.push(0n);\n        p.attacks[index] += _bigint(value);\n    }\n    _addBetrayal(player, value) {\n        const data = this._makePlayerStats(player);\n        if (data === undefined)\n            return;\n        if (data.betrayals === undefined) {\n            data.betrayals = _bigint(value);\n        }\n        else {\n            data.betrayals += _bigint(value);\n        }\n    }\n    _addBoat(player, type, index, value) {\n        var _a;\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        p.boats ?? (p.boats = { [type]: [0n] });\n        (_a = p.boats)[type] ?? (_a[type] = [0n]);\n        while (p.boats[type].length <= index)\n            p.boats[type].push(0n);\n        p.boats[type][index] += _bigint(value);\n    }\n    _addBomb(player, nukeType, index, value) {\n        var _a;\n        const type = _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.unitTypeToBombUnit[nukeType];\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        p.bombs ?? (p.bombs = { [type]: [0n] });\n        (_a = p.bombs)[type] ?? (_a[type] = [0n]);\n        while (p.bombs[type].length <= index)\n            p.bombs[type].push(0n);\n        p.bombs[type][index] += _bigint(value);\n    }\n    _addGold(player, index, value) {\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        p.gold ?? (p.gold = [0n]);\n        while (p.gold.length <= index)\n            p.gold.push(0n);\n        p.gold[index] += _bigint(value);\n    }\n    _addOtherUnit(player, otherUnitType, index, value) {\n        var _a;\n        const type = _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.unitTypeToOtherUnit[otherUnitType];\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        p.units ?? (p.units = { [type]: [0n] });\n        (_a = p.units)[type] ?? (_a[type] = [0n]);\n        while (p.units[type].length <= index)\n            p.units[type].push(0n);\n        p.units[type][index] += _bigint(value);\n    }\n    _addConquest(player) {\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        if (p.conquests === undefined) {\n            p.conquests = _bigint(1);\n        }\n        else {\n            p.conquests += _bigint(1);\n        }\n    }\n    _addPlayerKilled(player, tick) {\n        const p = this._makePlayerStats(player);\n        if (p === undefined)\n            return;\n        p.killedAt = _bigint(tick);\n    }\n    attack(player, target, troops) {\n        this._addAttack(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.ATTACK_INDEX_SENT, troops);\n        if (target.isPlayer()) {\n            this._addAttack(target, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.ATTACK_INDEX_RECV, troops);\n        }\n    }\n    attackCancel(player, target, troops) {\n        this._addAttack(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.ATTACK_INDEX_CANCEL, troops);\n        this._addAttack(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.ATTACK_INDEX_SENT, -troops);\n        if (target.isPlayer()) {\n            this._addAttack(target, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.ATTACK_INDEX_RECV, -troops);\n        }\n    }\n    betray(player) {\n        this._addBetrayal(player, 1);\n    }\n    boatSendTrade(player, target) {\n        this._addBoat(player, \"trade\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_SENT, 1);\n    }\n    boatArriveTrade(player, target, gold) {\n        this._addBoat(player, \"trade\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_ARRIVE, 1);\n        this._addGold(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.GOLD_INDEX_TRADE, gold);\n        this._addGold(target, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.GOLD_INDEX_TRADE, gold);\n    }\n    boatCapturedTrade(player, target, gold) {\n        this._addBoat(player, \"trade\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_CAPTURE, 1);\n        this._addGold(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.GOLD_INDEX_STEAL, gold);\n    }\n    boatDestroyTrade(player, target) {\n        this._addBoat(player, \"trade\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_DESTROY, 1);\n    }\n    boatSendTroops(player, target, troops) {\n        this._addBoat(player, \"trans\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_SENT, 1);\n    }\n    boatArriveTroops(player, target, troops) {\n        this._addBoat(player, \"trans\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_ARRIVE, 1);\n    }\n    boatDestroyTroops(player, target, troops) {\n        this._addBoat(player, \"trans\", _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOAT_INDEX_DESTROY, 1);\n    }\n    bombLaunch(player, target, type) {\n        this._addBomb(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOMB_INDEX_LAUNCH, 1);\n    }\n    bombLand(player, target, type) {\n        this._addBomb(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOMB_INDEX_LAND, 1);\n    }\n    bombIntercept(player, type, count) {\n        this._addBomb(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.BOMB_INDEX_INTERCEPT, count);\n    }\n    goldWork(player, gold) {\n        this._addGold(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.GOLD_INDEX_WORK, gold);\n    }\n    goldWar(player, captured, gold) {\n        this._addGold(player, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.GOLD_INDEX_WAR, gold);\n        this._addConquest(player);\n    }\n    unitBuild(player, type) {\n        this._addOtherUnit(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.OTHER_INDEX_BUILT, 1);\n    }\n    unitCapture(player, type) {\n        this._addOtherUnit(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.OTHER_INDEX_CAPTURE, 1);\n    }\n    unitUpgrade(player, type) {\n        this._addOtherUnit(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.OTHER_INDEX_UPGRADE, 1);\n    }\n    unitDestroy(player, type) {\n        this._addOtherUnit(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.OTHER_INDEX_DESTROY, 1);\n    }\n    unitLose(player, type) {\n        this._addOtherUnit(player, type, _StatsSchemas__WEBPACK_IMPORTED_MODULE_0__.OTHER_INDEX_LOST, 1);\n    }\n    playerKilled(player, tick) {\n        this._addPlayerKilled(player, tick);\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/StatsImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/TeamAssignment.ts":
/*!*****************************************!*\
  !*** ./src/core/game/TeamAssignment.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignTeams: () => (/* binding */ assignTeams)\n/* harmony export */ });\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n\n\n\nfunction assignTeams(players, teams) {\n    const result = new Map();\n    const teamPlayerCount = new Map();\n    // Group players by clan\n    const clanGroups = new Map();\n    const noClanPlayers = [];\n    // Sort players into clan groups or no-clan list\n    for (const player of players) {\n        if (player.clan) {\n            if (!clanGroups.has(player.clan)) {\n                clanGroups.set(player.clan, []);\n            }\n            clanGroups.get(player.clan).push(player);\n        }\n        else {\n            noClanPlayers.push(player);\n        }\n    }\n    const maxTeamSize = Math.ceil(players.length / teams.length);\n    // Sort clans by size (largest first)\n    const sortedClans = Array.from(clanGroups.entries()).sort((a, b) => b[1].length - a[1].length);\n    // First, assign clan players\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const [_, clanPlayers] of sortedClans) {\n        // Try to keep the clan together on the team with fewer players\n        let team = null;\n        let teamSize = 0;\n        for (const t of teams) {\n            const p = teamPlayerCount.get(t) ?? 0;\n            if (team !== null && teamSize <= p)\n                continue;\n            teamSize = p;\n            team = t;\n        }\n        if (team === null)\n            continue;\n        for (const player of clanPlayers) {\n            if (teamSize < maxTeamSize) {\n                teamSize++;\n                result.set(player, team);\n            }\n            else {\n                result.set(player, \"kicked\");\n            }\n        }\n        teamPlayerCount.set(team, teamSize);\n    }\n    // Then, assign non-clan players to balance teams\n    let nationPlayers = noClanPlayers.filter((player) => player.playerType === _Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.FakeHuman);\n    if (nationPlayers.length > 0) {\n        // Shuffle only nations to randomize their team assignment\n        const random = new _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__.PseudoRandom((0,_Util__WEBPACK_IMPORTED_MODULE_1__.simpleHash)(nationPlayers[0].id));\n        nationPlayers = random.shuffleArray(nationPlayers);\n    }\n    const otherPlayers = noClanPlayers.filter((player) => player.playerType !== _Game__WEBPACK_IMPORTED_MODULE_2__.PlayerType.FakeHuman);\n    for (const player of otherPlayers.concat(nationPlayers)) {\n        let team = null;\n        let teamSize = 0;\n        for (const t of teams) {\n            const p = teamPlayerCount.get(t) ?? 0;\n            if (team !== null && teamSize <= p)\n                continue;\n            teamSize = p;\n            team = t;\n        }\n        if (team === null)\n            continue;\n        teamPlayerCount.set(team, teamSize + 1);\n        result.set(player, team);\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/TeamAssignment.ts?\n}");

/***/ }),

/***/ "./src/core/game/TerraNulliusImpl.ts":
/*!*******************************************!*\
  !*** ./src/core/game/TerraNulliusImpl.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TerraNulliusImpl: () => (/* binding */ TerraNulliusImpl)\n/* harmony export */ });\nclass TerraNulliusImpl {\n    constructor() { }\n    smallID() {\n        return 0;\n    }\n    clientID() {\n        return \"TERRA_NULLIUS_CLIENT_ID\";\n    }\n    id() {\n        return null;\n    }\n    isPlayer() {\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/TerraNulliusImpl.ts?\n}");

/***/ }),

/***/ "./src/core/game/TerrainMapLoader.ts":
/*!*******************************************!*\
  !*** ./src/core/game/TerrainMapLoader.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   genTerrainFromBin: () => (/* binding */ genTerrainFromBin),\n/* harmony export */   loadTerrainMap: () => (/* binding */ loadTerrainMap)\n/* harmony export */ });\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _GameMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GameMap */ \"./src/core/game/GameMap.ts\");\n\n\nconst loadedMaps = new Map();\nasync function loadTerrainMap(map, mapSize, terrainMapFileLoader) {\n    const cached = loadedMaps.get(map);\n    if (cached !== undefined)\n        return cached;\n    const mapFiles = terrainMapFileLoader.getMapData(map);\n    const manifest = await mapFiles.manifest();\n    const gameMap = mapSize === _Game__WEBPACK_IMPORTED_MODULE_0__.GameMapSize.Normal\n        ? await genTerrainFromBin(manifest.map, await mapFiles.mapBin())\n        : await genTerrainFromBin(manifest.map4x, await mapFiles.map4xBin());\n    const miniMap = mapSize === _Game__WEBPACK_IMPORTED_MODULE_0__.GameMapSize.Normal\n        ? await genTerrainFromBin(mapSize === _Game__WEBPACK_IMPORTED_MODULE_0__.GameMapSize.Normal ? manifest.map4x : manifest.map16x, await mapFiles.map4xBin())\n        : await genTerrainFromBin(manifest.map16x, await mapFiles.map16xBin());\n    if (mapSize === _Game__WEBPACK_IMPORTED_MODULE_0__.GameMapSize.Compact) {\n        manifest.nations.forEach((nation) => {\n            nation.coordinates = [\n                Math.floor(nation.coordinates[0] / 2),\n                Math.floor(nation.coordinates[1] / 2),\n            ];\n        });\n    }\n    const result = {\n        nations: manifest.nations,\n        gameMap: gameMap,\n        miniGameMap: miniMap,\n    };\n    loadedMaps.set(map, result);\n    return result;\n}\nasync function genTerrainFromBin(mapData, data) {\n    if (data.length !== mapData.width * mapData.height) {\n        throw new Error(`Invalid data: buffer size ${data.length} incorrect for ${mapData.width}x${mapData.height} terrain plus 4 bytes for dimensions.`);\n    }\n    return new _GameMap__WEBPACK_IMPORTED_MODULE_1__.GameMapImpl(mapData.width, mapData.height, data, mapData.num_land_tiles);\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/TerrainMapLoader.ts?\n}");

/***/ }),

/***/ "./src/core/game/TrainStation.ts":
/*!***************************************!*\
  !*** ./src/core/game/TrainStation.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cluster: () => (/* binding */ Cluster),\n/* harmony export */   TrainStation: () => (/* binding */ TrainStation),\n/* harmony export */   TrainStationMapAdapter: () => (/* binding */ TrainStationMapAdapter),\n/* harmony export */   createTrainStopHandlers: () => (/* binding */ createTrainStopHandlers)\n/* harmony export */ });\n/* harmony import */ var _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PseudoRandom */ \"./src/core/PseudoRandom.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _GameUpdates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n\n\n\n/**\n * All stop handlers share the same logic for the time being\n * Behavior to be defined\n */\nclass CityStopHandler {\n    onStop(mg, station, trainExecution) {\n        const stationOwner = station.unit.owner();\n        const trainOwner = trainExecution.owner();\n        const goldBonus = mg.config().trainGold(rel(trainOwner, stationOwner));\n        // Share revenue with the station owner if it's not the current player\n        if (trainOwner !== stationOwner) {\n            stationOwner.addGold(goldBonus, station.tile());\n        }\n        trainOwner.addGold(goldBonus, station.tile());\n    }\n}\nclass PortStopHandler {\n    constructor(random) {\n        this.random = random;\n    }\n    onStop(mg, station, trainExecution) {\n        const stationOwner = station.unit.owner();\n        const trainOwner = trainExecution.owner();\n        const goldBonus = mg.config().trainGold(rel(trainOwner, stationOwner));\n        trainOwner.addGold(goldBonus, station.tile());\n        // Share revenue with the station owner if it's not the current player\n        if (trainOwner !== stationOwner) {\n            stationOwner.addGold(goldBonus, station.tile());\n        }\n    }\n}\nclass FactoryStopHandler {\n    onStop(mg, station, trainExecution) { }\n}\nfunction createTrainStopHandlers(random) {\n    return {\n        [_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.City]: new CityStopHandler(),\n        [_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port]: new PortStopHandler(random),\n        [_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Factory]: new FactoryStopHandler(),\n    };\n}\nclass TrainStation {\n    constructor(mg, unit) {\n        this.mg = mg;\n        this.unit = unit;\n        this.stopHandlers = {};\n        this.railroads = new Set();\n        this.stopHandlers = createTrainStopHandlers(new _PseudoRandom__WEBPACK_IMPORTED_MODULE_0__.PseudoRandom(mg.ticks()));\n    }\n    tradeAvailable(otherPlayer) {\n        const player = this.unit.owner();\n        return otherPlayer === player || player.canTrade(otherPlayer);\n    }\n    clearRailroads() {\n        this.railroads.clear();\n    }\n    addRailroad(railRoad) {\n        this.railroads.add(railRoad);\n    }\n    removeNeighboringRails(station) {\n        const toRemove = [...this.railroads].find((r) => r.from === station || r.to === station);\n        if (toRemove) {\n            const railTiles = toRemove.tiles.map((tile) => ({\n                tile,\n                railType: _GameUpdates__WEBPACK_IMPORTED_MODULE_2__.RailType.VERTICAL,\n            }));\n            this.mg.addUpdate({\n                type: _GameUpdates__WEBPACK_IMPORTED_MODULE_2__.GameUpdateType.RailroadEvent,\n                isActive: false,\n                railTiles,\n            });\n            this.railroads.delete(toRemove);\n        }\n    }\n    neighbors() {\n        const neighbors = [];\n        for (const r of this.railroads) {\n            if (r.from !== this) {\n                neighbors.push(r.from);\n            }\n            else {\n                neighbors.push(r.to);\n            }\n        }\n        return neighbors;\n    }\n    tile() {\n        return this.unit.tile();\n    }\n    isActive() {\n        return this.unit.isActive();\n    }\n    getRailroads() {\n        return this.railroads;\n    }\n    setCluster(cluster) {\n        this.cluster = cluster;\n    }\n    getCluster() {\n        return this.cluster;\n    }\n    onTrainStop(trainExecution) {\n        const type = this.unit.type();\n        const handler = this.stopHandlers[type];\n        if (handler) {\n            handler.onStop(this.mg, this, trainExecution);\n        }\n    }\n}\n/**\n * Make the trainstation usable with A*\n */\nclass TrainStationMapAdapter {\n    constructor(game) {\n        this.game = game;\n    }\n    neighbors(node) {\n        return node.neighbors();\n    }\n    cost(node) {\n        return 1;\n    }\n    position(node) {\n        return { x: this.game.x(node.tile()), y: this.game.y(node.tile()) };\n    }\n    isTraversable(from, to) {\n        return true;\n    }\n}\n/**\n * Cluster of connected stations\n */\nclass Cluster {\n    constructor() {\n        this.stations = new Set();\n    }\n    has(station) {\n        return this.stations.has(station);\n    }\n    addStation(station) {\n        this.stations.add(station);\n        station.setCluster(this);\n    }\n    removeStation(station) {\n        this.stations.delete(station);\n    }\n    addStations(stations) {\n        for (const station of stations) {\n            this.addStation(station);\n        }\n    }\n    merge(other) {\n        for (const s of other.stations) {\n            this.addStation(s);\n        }\n    }\n    availableForTrade(player) {\n        const tradingStations = new Set();\n        for (const station of this.stations) {\n            if ((station.unit.type() === _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.City ||\n                station.unit.type() === _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port) &&\n                station.tradeAvailable(player)) {\n                tradingStations.add(station);\n            }\n        }\n        return tradingStations;\n    }\n    size() {\n        return this.stations.size;\n    }\n    clear() {\n        this.stations.clear();\n    }\n}\nfunction rel(player, other) {\n    if (player === other) {\n        return \"self\";\n    }\n    if (player.isOnSameTeam(other)) {\n        return \"team\";\n    }\n    if (player.isAlliedWith(other)) {\n        return \"ally\";\n    }\n    return \"other\";\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/TrainStation.ts?\n}");

/***/ }),

/***/ "./src/core/game/TransportShipUtils.ts":
/*!*********************************************!*\
  !*** ./src/core/game/TransportShipUtils.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bestShoreDeploymentSource: () => (/* binding */ bestShoreDeploymentSource),\n/* harmony export */   canBuildTransportShip: () => (/* binding */ canBuildTransportShip),\n/* harmony export */   candidateShoreTiles: () => (/* binding */ candidateShoreTiles),\n/* harmony export */   closestShoreFromPlayer: () => (/* binding */ closestShoreFromPlayer),\n/* harmony export */   sourceDstOceanShore: () => (/* binding */ sourceDstOceanShore),\n/* harmony export */   targetTransportTile: () => (/* binding */ targetTransportTile)\n/* harmony export */ });\n/* harmony import */ var _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pathfinding/AStar */ \"./src/core/pathfinding/AStar.ts\");\n/* harmony import */ var _pathfinding_MiniAStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../pathfinding/MiniAStar */ \"./src/core/pathfinding/MiniAStar.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _GameMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GameMap */ \"./src/core/game/GameMap.ts\");\n\n\n\n\nfunction canBuildTransportShip(game, player, tile) {\n    if (player.unitCount(_Game__WEBPACK_IMPORTED_MODULE_2__.UnitType.TransportShip) >= game.config().boatMaxNumber()) {\n        return false;\n    }\n    const dst = targetTransportTile(game, tile);\n    if (dst === null) {\n        return false;\n    }\n    const other = game.owner(tile);\n    if (other === player) {\n        return false;\n    }\n    if (other.isPlayer() && player.isFriendly(other)) {\n        return false;\n    }\n    if (game.isOceanShore(dst)) {\n        let myPlayerBordersOcean = false;\n        for (const bt of player.borderTiles()) {\n            if (game.isOceanShore(bt)) {\n                myPlayerBordersOcean = true;\n                break;\n            }\n        }\n        let otherPlayerBordersOcean = false;\n        if (!game.hasOwner(tile)) {\n            otherPlayerBordersOcean = true;\n        }\n        else {\n            for (const bt of other.borderTiles()) {\n                if (game.isOceanShore(bt)) {\n                    otherPlayerBordersOcean = true;\n                    break;\n                }\n            }\n        }\n        if (myPlayerBordersOcean && otherPlayerBordersOcean) {\n            return transportShipSpawn(game, player, dst);\n        }\n        else {\n            return false;\n        }\n    }\n    // Now we are boating in a lake, so do a bfs from target until we find\n    // a border tile owned by the player\n    const tiles = game.bfs(dst, (0,_GameMap__WEBPACK_IMPORTED_MODULE_3__.andFN)((0,_GameMap__WEBPACK_IMPORTED_MODULE_3__.manhattanDistFN)(dst, 300), (_, t) => game.isLake(t) || game.isShore(t)));\n    const sorted = Array.from(tiles).sort((a, b) => game.manhattanDist(dst, a) - game.manhattanDist(dst, b));\n    for (const t of sorted) {\n        if (game.owner(t) === player) {\n            return transportShipSpawn(game, player, t);\n        }\n    }\n    return false;\n}\nfunction transportShipSpawn(game, player, targetTile) {\n    if (!game.isShore(targetTile)) {\n        return false;\n    }\n    const spawn = closestShoreFromPlayer(game, player, targetTile);\n    if (spawn === null) {\n        return false;\n    }\n    return spawn;\n}\nfunction sourceDstOceanShore(gm, src, tile) {\n    const dst = gm.owner(tile);\n    const srcTile = closestShoreFromPlayer(gm, src, tile);\n    let dstTile = null;\n    if (dst.isPlayer()) {\n        dstTile = closestShoreFromPlayer(gm, dst, tile);\n    }\n    else {\n        dstTile = closestShoreTN(gm, tile, 50);\n    }\n    return [srcTile, dstTile];\n}\nfunction targetTransportTile(gm, tile) {\n    const dst = gm.playerBySmallID(gm.ownerID(tile));\n    let dstTile = null;\n    if (dst.isPlayer()) {\n        dstTile = closestShoreFromPlayer(gm, dst, tile);\n    }\n    else {\n        dstTile = closestShoreTN(gm, tile, 50);\n    }\n    return dstTile;\n}\nfunction closestShoreFromPlayer(gm, player, target) {\n    const shoreTiles = Array.from(player.borderTiles()).filter((t) => gm.isShore(t));\n    if (shoreTiles.length === 0) {\n        return null;\n    }\n    return shoreTiles.reduce((closest, current) => {\n        const closestDistance = gm.manhattanDist(target, closest);\n        const currentDistance = gm.manhattanDist(target, current);\n        return currentDistance < closestDistance ? current : closest;\n    });\n}\nfunction bestShoreDeploymentSource(gm, player, target) {\n    const t = targetTransportTile(gm, target);\n    if (t === null)\n        return false;\n    const candidates = candidateShoreTiles(gm, player, t);\n    const aStar = new _pathfinding_MiniAStar__WEBPACK_IMPORTED_MODULE_1__.MiniAStar(gm, gm.miniMap(), candidates, t, 1000000, 1);\n    const result = aStar.compute();\n    if (result !== _pathfinding_AStar__WEBPACK_IMPORTED_MODULE_0__.PathFindResultType.Completed) {\n        console.warn(`bestShoreDeploymentSource: path not found: ${result}`);\n        return false;\n    }\n    const path = aStar.reconstructPath();\n    if (path.length === 0) {\n        return false;\n    }\n    const potential = path[0];\n    // Since mini a* downscales the map, we need to check the neighbors\n    // of the potential tile to find a valid deployment point\n    const neighbors = gm\n        .neighbors(potential)\n        .filter((n) => gm.isShore(n) && gm.owner(n) === player);\n    if (neighbors.length === 0) {\n        return false;\n    }\n    return neighbors[0];\n}\nfunction candidateShoreTiles(gm, player, target) {\n    let closestManhattanDistance = Infinity;\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    let bestByManhattan = null;\n    const extremumTiles = {\n        minX: null,\n        minY: null,\n        maxX: null,\n        maxY: null,\n    };\n    const borderShoreTiles = Array.from(player.borderTiles()).filter((t) => gm.isShore(t));\n    for (const tile of borderShoreTiles) {\n        const distance = gm.manhattanDist(tile, target);\n        const cell = gm.cell(tile);\n        // Manhattan-closest tile\n        if (distance < closestManhattanDistance) {\n            closestManhattanDistance = distance;\n            bestByManhattan = tile;\n        }\n        // Extremum tiles\n        if (cell.x < minX) {\n            minX = cell.x;\n            extremumTiles.minX = tile;\n        }\n        else if (cell.y < minY) {\n            minY = cell.y;\n            extremumTiles.minY = tile;\n        }\n        else if (cell.x > maxX) {\n            maxX = cell.x;\n            extremumTiles.maxX = tile;\n        }\n        else if (cell.y > maxY) {\n            maxY = cell.y;\n            extremumTiles.maxY = tile;\n        }\n    }\n    // Calculate sampling interval to ensure we get at most 50 tiles\n    const samplingInterval = Math.max(10, Math.ceil(borderShoreTiles.length / 50));\n    const sampledTiles = borderShoreTiles.filter((_, index) => index % samplingInterval === 0);\n    const candidates = [\n        bestByManhattan,\n        extremumTiles.minX,\n        extremumTiles.minY,\n        extremumTiles.maxX,\n        extremumTiles.maxY,\n        ...sampledTiles,\n    ].filter(Boolean);\n    return candidates;\n}\nfunction closestShoreTN(gm, tile, searchDist) {\n    const tn = Array.from(gm.bfs(tile, (0,_GameMap__WEBPACK_IMPORTED_MODULE_3__.andFN)((_, t) => !gm.hasOwner(t), (0,_GameMap__WEBPACK_IMPORTED_MODULE_3__.manhattanDistFN)(tile, searchDist))))\n        .filter((t) => gm.isShore(t))\n        .sort((a, b) => gm.manhattanDist(tile, a) - gm.manhattanDist(tile, b));\n    if (tn.length === 0) {\n        return null;\n    }\n    return tn[0];\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/TransportShipUtils.ts?\n}");

/***/ }),

/***/ "./src/core/game/UnitGrid.ts":
/*!***********************************!*\
  !*** ./src/core/game/UnitGrid.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnitGrid: () => (/* binding */ UnitGrid)\n/* harmony export */ });\nclass UnitGrid {\n    constructor(gm) {\n        this.gm = gm;\n        this.cellSize = 100;\n        this.grid = Array(Math.ceil(gm.height() / this.cellSize))\n            .fill(null)\n            .map(() => Array(Math.ceil(gm.width() / this.cellSize))\n            .fill(null)\n            .map(() => new Map()));\n    }\n    // Get grid coordinates from pixel coordinates\n    getGridCoords(x, y) {\n        return [Math.floor(x / this.cellSize), Math.floor(y / this.cellSize)];\n    }\n    // Add a unit to the grid\n    addUnit(unit) {\n        const tile = unit.tile();\n        const [gridX, gridY] = this.getGridCoords(this.gm.x(tile), this.gm.y(tile));\n        if (this.isValidCell(gridX, gridY)) {\n            const unitSet = this.grid[gridY][gridX].get(unit.type());\n            if (unitSet !== undefined) {\n                unitSet.add(unit);\n            }\n            else {\n                this.grid[gridY][gridX].set(unit.type(), new Set([unit]));\n            }\n        }\n    }\n    // Remove a unit from the grid\n    removeUnit(unit) {\n        const tile = unit.tile();\n        this.removeUnitByTile(unit, tile);\n    }\n    removeUnitByTile(unit, tile) {\n        const [gridX, gridY] = this.getGridCoords(this.gm.x(tile), this.gm.y(tile));\n        if (this.isValidCell(gridX, gridY)) {\n            const unitSet = this.grid[gridY][gridX].get(unit.type());\n            if (unitSet !== undefined) {\n                unitSet.delete(unit);\n            }\n        }\n    }\n    /**\n     * Move an unit to its new cell if it changed\n     */\n    updateUnitCell(unit) {\n        const newTile = unit.tile();\n        const oldTile = unit.lastTile();\n        const [gridX, gridY] = this.getGridCoords(this.gm.x(oldTile), this.gm.y(oldTile));\n        const [newGridX, newGridY] = this.getGridCoords(this.gm.x(newTile), this.gm.y(newTile));\n        if (gridX !== newGridX || gridY !== newGridY) {\n            this.removeUnitByTile(unit, oldTile);\n            this.addUnit(unit);\n        }\n    }\n    isValidCell(gridX, gridY) {\n        return (gridX >= 0 &&\n            gridX < this.grid[0].length &&\n            gridY >= 0 &&\n            gridY < this.grid.length);\n    }\n    // Compute the exact cells in range of tile\n    getCellsInRange(tile, range) {\n        const x = this.gm.x(tile);\n        const y = this.gm.y(tile);\n        const cellSize = this.cellSize;\n        const [gridX, gridY] = this.getGridCoords(x, y);\n        const startGridX = Math.max(0, gridX - Math.ceil((range - (x % cellSize)) / cellSize));\n        const endGridX = Math.min(this.grid[0].length - 1, gridX + Math.ceil((range - (cellSize - (x % cellSize))) / cellSize));\n        const startGridY = Math.max(0, gridY - Math.ceil((range - (y % cellSize)) / cellSize));\n        const endGridY = Math.min(this.grid.length - 1, gridY + Math.ceil((range - (cellSize - (y % cellSize))) / cellSize));\n        return { startGridX, endGridX, startGridY, endGridY };\n    }\n    squaredDistanceFromTile(unit, tile) {\n        const x = this.gm.x(tile);\n        const y = this.gm.y(tile);\n        const tileX = this.gm.x(unit.tile());\n        const tileY = this.gm.y(unit.tile());\n        const dx = tileX - x;\n        const dy = tileY - y;\n        const distSquared = dx * dx + dy * dy;\n        return distSquared;\n    }\n    // Get all units within range of a point\n    // Returns [unit, distanceSquared] pairs for efficient filtering\n    nearbyUnits(tile, searchRange, types, predicate) {\n        const nearby = [];\n        const { startGridX, endGridX, startGridY, endGridY } = this.getCellsInRange(tile, searchRange);\n        const rangeSquared = searchRange * searchRange;\n        const typeSet = Array.isArray(types) ? new Set(types) : new Set([types]);\n        for (let cy = startGridY; cy <= endGridY; cy++) {\n            for (let cx = startGridX; cx <= endGridX; cx++) {\n                for (const type of typeSet) {\n                    const unitSet = this.grid[cy][cx].get(type);\n                    if (unitSet === undefined)\n                        continue;\n                    for (const unit of unitSet) {\n                        if (!unit.isActive())\n                            continue;\n                        const distSquared = this.squaredDistanceFromTile(unit, tile);\n                        if (distSquared > rangeSquared)\n                            continue;\n                        const value = { unit, distSquared };\n                        if (predicate !== undefined && !predicate(value))\n                            continue;\n                        nearby.push(value);\n                    }\n                }\n            }\n        }\n        return nearby;\n    }\n    unitIsInRange(unit, tile, rangeSquared, playerId) {\n        if (!unit.isActive()) {\n            return false;\n        }\n        if (playerId !== undefined && unit.owner().id() !== playerId) {\n            return false;\n        }\n        const distSquared = this.squaredDistanceFromTile(unit, tile);\n        return distSquared <= rangeSquared;\n    }\n    // Return true if it finds an owned specific unit in range\n    hasUnitNearby(tile, searchRange, type, playerId) {\n        const { startGridX, endGridX, startGridY, endGridY } = this.getCellsInRange(tile, searchRange);\n        const rangeSquared = searchRange * searchRange;\n        for (let cy = startGridY; cy <= endGridY; cy++) {\n            for (let cx = startGridX; cx <= endGridX; cx++) {\n                const unitSet = this.grid[cy][cx].get(type);\n                if (unitSet === undefined)\n                    continue;\n                for (const unit of unitSet) {\n                    if (this.unitIsInRange(unit, tile, rangeSquared, playerId)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/UnitGrid.ts?\n}");

/***/ }),

/***/ "./src/core/game/UnitImpl.ts":
/*!***********************************!*\
  !*** ./src/core/game/UnitImpl.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UnitImpl: () => (/* binding */ UnitImpl)\n/* harmony export */ });\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _GameUpdates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GameUpdates */ \"./src/core/game/GameUpdates.ts\");\n\n\n\nclass UnitImpl {\n    constructor(_type, mg, _tile, _id, _owner, params = {}) {\n        this._type = _type;\n        this.mg = mg;\n        this._tile = _tile;\n        this._id = _id;\n        this._owner = _owner;\n        this._active = true;\n        this._retreating = false;\n        this._targetedBySAM = false;\n        this._reachedTarget = false;\n        this._lastOwner = null;\n        // Number of missiles in cooldown, if empty all missiles are ready.\n        this._missileTimerQueue = [];\n        this._hasTrainStation = false;\n        this._level = 1;\n        this._targetable = true;\n        // Nuke only\n        this._trajectoryIndex = 0;\n        this._lastTile = _tile;\n        this._health = (0,_Util__WEBPACK_IMPORTED_MODULE_0__.toInt)(this.mg.unitInfo(_type).maxHealth ?? 1);\n        this._targetTile =\n            \"targetTile\" in params ? (params.targetTile ?? undefined) : undefined;\n        this._trajectory = \"trajectory\" in params ? (params.trajectory ?? []) : [];\n        this._troops = \"troops\" in params ? (params.troops ?? 0) : 0;\n        this._lastSetSafeFromPirates =\n            \"lastSetSafeFromPirates\" in params\n                ? (params.lastSetSafeFromPirates ?? 0)\n                : 0;\n        this._patrolTile =\n            \"patrolTile\" in params ? (params.patrolTile ?? undefined) : undefined;\n        this._targetUnit =\n            \"targetUnit\" in params ? (params.targetUnit ?? undefined) : undefined;\n        this._loaded =\n            \"loaded\" in params ? (params.loaded ?? undefined) : undefined;\n        this._trainType = \"trainType\" in params ? params.trainType : undefined;\n        switch (this._type) {\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Warship:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MissileSilo:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.DefensePost:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.SAMLauncher:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.City:\n                this.mg.stats().unitBuild(_owner, this._type);\n        }\n    }\n    setTargetable(targetable) {\n        if (this._targetable !== targetable) {\n            this._targetable = targetable;\n            this.mg.addUpdate(this.toUpdate());\n        }\n    }\n    isTargetable() {\n        return this._targetable;\n    }\n    setPatrolTile(tile) {\n        this._patrolTile = tile;\n    }\n    patrolTile() {\n        return this._patrolTile;\n    }\n    isUnit() {\n        return true;\n    }\n    touch() {\n        this.mg.addUpdate(this.toUpdate());\n    }\n    setTileTarget(tile) {\n        this._targetTile = tile;\n    }\n    tileTarget() {\n        return this._targetTile;\n    }\n    id() {\n        return this._id;\n    }\n    toUpdate() {\n        return {\n            type: _GameUpdates__WEBPACK_IMPORTED_MODULE_2__.GameUpdateType.Unit,\n            unitType: this._type,\n            id: this._id,\n            troops: this._troops,\n            ownerID: this._owner.smallID(),\n            lastOwnerID: this._lastOwner?.smallID(),\n            isActive: this._active,\n            reachedTarget: this._reachedTarget,\n            retreating: this._retreating,\n            pos: this._tile,\n            targetable: this._targetable,\n            lastPos: this._lastTile,\n            health: this.hasHealth() ? Number(this._health) : undefined,\n            constructionType: this._constructionType,\n            targetUnitId: this._targetUnit?.id() ?? undefined,\n            targetTile: this.targetTile() ?? undefined,\n            missileTimerQueue: this._missileTimerQueue,\n            level: this.level(),\n            hasTrainStation: this._hasTrainStation,\n            trainType: this._trainType,\n            loaded: this._loaded,\n        };\n    }\n    type() {\n        return this._type;\n    }\n    lastTile() {\n        return this._lastTile;\n    }\n    move(tile) {\n        if (tile === null) {\n            throw new Error(\"tile cannot be null\");\n        }\n        this._lastTile = this._tile;\n        this._tile = tile;\n        this.mg.updateUnitTile(this);\n        this.mg.addUpdate(this.toUpdate());\n    }\n    setTroops(troops) {\n        this._troops = troops;\n    }\n    troops() {\n        return this._troops;\n    }\n    health() {\n        return Number(this._health);\n    }\n    hasHealth() {\n        return this.info().maxHealth !== undefined;\n    }\n    tile() {\n        return this._tile;\n    }\n    owner() {\n        return this._owner;\n    }\n    info() {\n        return this.mg.unitInfo(this._type);\n    }\n    setOwner(newOwner) {\n        switch (this._type) {\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Warship:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MissileSilo:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.DefensePost:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.SAMLauncher:\n            case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.City:\n                this.mg.stats().unitCapture(newOwner, this._type);\n                this.mg.stats().unitLose(this._owner, this._type);\n                break;\n        }\n        this._lastOwner = this._owner;\n        this._lastOwner._units = this._lastOwner._units.filter((u) => u !== this);\n        this._owner = newOwner;\n        this._owner._units.push(this);\n        this.mg.addUpdate(this.toUpdate());\n        this.mg.displayMessage(`Your ${this.type()} was captured by ${newOwner.displayName()}`, _Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.UNIT_CAPTURED_BY_ENEMY, this._lastOwner.id());\n        this.mg.displayMessage(`Captured ${this.type()} from ${this._lastOwner.displayName()}`, _Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.CAPTURED_ENEMY_UNIT, newOwner.id());\n    }\n    modifyHealth(delta, attacker) {\n        this._health = (0,_Util__WEBPACK_IMPORTED_MODULE_0__.withinInt)(this._health + (0,_Util__WEBPACK_IMPORTED_MODULE_0__.toInt)(delta), 0n, (0,_Util__WEBPACK_IMPORTED_MODULE_0__.toInt)(this.info().maxHealth ?? 1));\n        if (this._health === 0n) {\n            this.delete(true, attacker);\n        }\n    }\n    delete(displayMessage, destroyer) {\n        if (!this.isActive()) {\n            throw new Error(`cannot delete ${this} not active`);\n        }\n        this._owner._units = this._owner._units.filter((b) => b !== this);\n        this._active = false;\n        this.mg.addUpdate(this.toUpdate());\n        this.mg.removeUnit(this);\n        if (displayMessage !== false && this._type !== _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MIRVWarhead) {\n            this.mg.displayMessage(`Your ${this._type} was destroyed`, _Game__WEBPACK_IMPORTED_MODULE_1__.MessageType.UNIT_DESTROYED, this.owner().id());\n        }\n        if (destroyer !== undefined) {\n            switch (this._type) {\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.TransportShip:\n                    this.mg\n                        .stats()\n                        .boatDestroyTroops(destroyer, this._owner, this._troops);\n                    break;\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.TradeShip:\n                    this.mg.stats().boatDestroyTrade(destroyer, this._owner);\n                    break;\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.City:\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.DefensePost:\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MissileSilo:\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Port:\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.SAMLauncher:\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Warship:\n                case _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Factory:\n                    this.mg.stats().unitDestroy(destroyer, this._type);\n                    this.mg.stats().unitLose(this.owner(), this._type);\n                    break;\n            }\n        }\n    }\n    isActive() {\n        return this._active;\n    }\n    retreating() {\n        return this._retreating;\n    }\n    orderBoatRetreat() {\n        if (this.type() !== _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.TransportShip) {\n            throw new Error(`Cannot retreat ${this.type()}`);\n        }\n        this._retreating = true;\n    }\n    constructionType() {\n        if (this.type() !== _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Construction) {\n            throw new Error(`Cannot get construction type on ${this.type()}`);\n        }\n        return this._constructionType ?? null;\n    }\n    setConstructionType(type) {\n        if (this.type() !== _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.Construction) {\n            throw new Error(`Cannot set construction type on ${this.type()}`);\n        }\n        this._constructionType = type;\n        this.mg.addUpdate(this.toUpdate());\n    }\n    hash() {\n        return this.tile() + (0,_Util__WEBPACK_IMPORTED_MODULE_0__.simpleHash)(this.type()) * this._id;\n    }\n    toString() {\n        return `Unit:${this._type},owner:${this.owner().name()}`;\n    }\n    launch() {\n        this._missileTimerQueue.push(this.mg.ticks());\n        this.mg.addUpdate(this.toUpdate());\n    }\n    ticksLeftInCooldown() {\n        return this._missileTimerQueue[0];\n    }\n    isInCooldown() {\n        return this._missileTimerQueue.length === this._level;\n    }\n    missileTimerQueue() {\n        return this._missileTimerQueue;\n    }\n    reloadMissile() {\n        this._missileTimerQueue.shift();\n        this.mg.addUpdate(this.toUpdate());\n    }\n    setTargetTile(targetTile) {\n        this._targetTile = targetTile;\n    }\n    targetTile() {\n        return this._targetTile;\n    }\n    setTrajectoryIndex(i) {\n        const max = this._trajectory.length - 1;\n        this._trajectoryIndex = i < 0 ? 0 : i > max ? max : i;\n    }\n    trajectoryIndex() {\n        return this._trajectoryIndex;\n    }\n    trajectory() {\n        return this._trajectory;\n    }\n    setTargetUnit(target) {\n        this._targetUnit = target;\n    }\n    targetUnit() {\n        return this._targetUnit;\n    }\n    setTargetedBySAM(targeted) {\n        this._targetedBySAM = targeted;\n    }\n    targetedBySAM() {\n        return this._targetedBySAM;\n    }\n    setReachedTarget() {\n        this._reachedTarget = true;\n    }\n    reachedTarget() {\n        return this._reachedTarget;\n    }\n    setSafeFromPirates() {\n        this._lastSetSafeFromPirates = this.mg.ticks();\n    }\n    isSafeFromPirates() {\n        return (this.mg.ticks() - this._lastSetSafeFromPirates <\n            this.mg.config().safeFromPiratesCooldownMax());\n    }\n    level() {\n        return this._level;\n    }\n    setTrainStation(trainStation) {\n        this._hasTrainStation = trainStation;\n        this.mg.addUpdate(this.toUpdate());\n    }\n    hasTrainStation() {\n        return this._hasTrainStation;\n    }\n    increaseLevel() {\n        this._level++;\n        if ([_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MissileSilo, _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.SAMLauncher].includes(this.type())) {\n            this._missileTimerQueue.push(this.mg.ticks());\n        }\n        this.mg.addUpdate(this.toUpdate());\n    }\n    decreaseLevel(destroyer) {\n        this._level--;\n        if ([_Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.MissileSilo, _Game__WEBPACK_IMPORTED_MODULE_1__.UnitType.SAMLauncher].includes(this.type())) {\n            this._missileTimerQueue.pop();\n        }\n        if (this._level <= 0) {\n            this.delete(true, destroyer);\n            return;\n        }\n        this.mg.addUpdate(this.toUpdate());\n    }\n    trainType() {\n        return this._trainType;\n    }\n    isLoaded() {\n        return this._loaded;\n    }\n    setLoaded(loaded) {\n        if (this._loaded !== loaded) {\n            this._loaded = loaded;\n            this.mg.addUpdate(this.toUpdate());\n        }\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/game/UnitImpl.ts?\n}");

/***/ }),

/***/ "./src/core/pathfinding/AStar.ts":
/*!***************************************!*\
  !*** ./src/core/pathfinding/AStar.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PathFindResultType: () => (/* binding */ PathFindResultType)\n/* harmony export */ });\nvar PathFindResultType;\n(function (PathFindResultType) {\n    PathFindResultType[PathFindResultType[\"NextTile\"] = 0] = \"NextTile\";\n    PathFindResultType[PathFindResultType[\"Pending\"] = 1] = \"Pending\";\n    PathFindResultType[PathFindResultType[\"Completed\"] = 2] = \"Completed\";\n    PathFindResultType[PathFindResultType[\"PathNotFound\"] = 3] = \"PathNotFound\";\n})(PathFindResultType || (PathFindResultType = {}));\n\n\n//# sourceURL=webpack://openfront-client/./src/core/pathfinding/AStar.ts?\n}");

/***/ }),

/***/ "./src/core/pathfinding/MiniAStar.ts":
/*!*******************************************!*\
  !*** ./src/core/pathfinding/MiniAStar.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameMapAdapter: () => (/* binding */ GameMapAdapter),\n/* harmony export */   MiniAStar: () => (/* binding */ MiniAStar)\n/* harmony export */ });\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/Game */ \"./src/core/game/Game.ts\");\n/* harmony import */ var _SerialAStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SerialAStar */ \"./src/core/pathfinding/SerialAStar.ts\");\n\n\nclass GameMapAdapter {\n    constructor(gameMap, waterPath) {\n        this.gameMap = gameMap;\n        this.waterPath = waterPath;\n        this.waterPenalty = 3;\n    }\n    neighbors(node) {\n        return this.gameMap.neighbors(node);\n    }\n    cost(node) {\n        let base = this.gameMap.cost(node);\n        // Avoid crossing water when possible\n        if (!this.waterPath && this.gameMap.isWater(node)) {\n            base += this.waterPenalty;\n        }\n        return base;\n    }\n    position(node) {\n        return { x: this.gameMap.x(node), y: this.gameMap.y(node) };\n    }\n    isTraversable(from, to) {\n        const toWater = this.gameMap.isWater(to);\n        if (this.waterPath) {\n            return toWater;\n        }\n        // Allow water access from/to shore\n        const fromShore = this.gameMap.isShoreline(from);\n        const toShore = this.gameMap.isShoreline(to);\n        return !toWater || fromShore || toShore;\n    }\n}\nclass MiniAStar {\n    constructor(gameMap, miniMap, src, dst, iterations, maxTries, waterPath = true, directionChangePenalty = 0) {\n        this.gameMap = gameMap;\n        this.miniMap = miniMap;\n        this.src = src;\n        this.dst = dst;\n        const srcArray = Array.isArray(src) ? src : [src];\n        const miniSrc = srcArray.map((srcPoint) => this.miniMap.ref(Math.floor(gameMap.x(srcPoint) / 2), Math.floor(gameMap.y(srcPoint) / 2)));\n        const miniDst = this.miniMap.ref(Math.floor(gameMap.x(dst) / 2), Math.floor(gameMap.y(dst) / 2));\n        this.aStar = new _SerialAStar__WEBPACK_IMPORTED_MODULE_1__.SerialAStar(miniSrc, miniDst, iterations, maxTries, new GameMapAdapter(miniMap, waterPath), directionChangePenalty);\n    }\n    compute() {\n        return this.aStar.compute();\n    }\n    reconstructPath() {\n        let cellSrc;\n        if (!Array.isArray(this.src)) {\n            cellSrc = new _game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(this.gameMap.x(this.src), this.gameMap.y(this.src));\n        }\n        const cellDst = new _game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(this.gameMap.x(this.dst), this.gameMap.y(this.dst));\n        const upscaled = fixExtremes(upscalePath(this.aStar\n            .reconstructPath()\n            .map((tr) => new _game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(this.miniMap.x(tr), this.miniMap.y(tr)))), cellDst, cellSrc);\n        return upscaled.map((c) => this.gameMap.ref(c.x, c.y));\n    }\n}\nfunction fixExtremes(upscaled, cellDst, cellSrc) {\n    if (cellSrc !== undefined) {\n        const srcIndex = findCell(upscaled, cellSrc);\n        if (srcIndex === -1) {\n            // didnt find the start tile in the path\n            upscaled.unshift(cellSrc);\n        }\n        else if (srcIndex !== 0) {\n            // found start tile but not at the start\n            // remove all tiles before the start tile\n            upscaled = upscaled.slice(srcIndex);\n        }\n    }\n    const dstIndex = findCell(upscaled, cellDst);\n    if (dstIndex === -1) {\n        // didnt find the dst tile in the path\n        upscaled.push(cellDst);\n    }\n    else if (dstIndex !== upscaled.length - 1) {\n        // found dst tile but not at the end\n        // remove all tiles after the dst tile\n        upscaled = upscaled.slice(0, dstIndex + 1);\n    }\n    return upscaled;\n}\nfunction upscalePath(path, scaleFactor = 2) {\n    // Scale up each point\n    const scaledPath = path.map((point) => new _game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(point.x * scaleFactor, point.y * scaleFactor));\n    const smoothPath = [];\n    for (let i = 0; i < scaledPath.length - 1; i++) {\n        const current = scaledPath[i];\n        const next = scaledPath[i + 1];\n        // Add the current point\n        smoothPath.push(current);\n        // Always interpolate between scaled points\n        const dx = next.x - current.x;\n        const dy = next.y - current.y;\n        // Calculate number of steps needed\n        const distance = Math.max(Math.abs(dx), Math.abs(dy));\n        const steps = distance;\n        // Add intermediate points\n        for (let step = 1; step < steps; step++) {\n            smoothPath.push(new _game_Game__WEBPACK_IMPORTED_MODULE_0__.Cell(Math.round(current.x + (dx * step) / steps), Math.round(current.y + (dy * step) / steps)));\n        }\n    }\n    // Add the last point\n    if (scaledPath.length > 0) {\n        smoothPath.push(scaledPath[scaledPath.length - 1]);\n    }\n    return smoothPath;\n}\nfunction findCell(upscaled, cellDst) {\n    for (let i = 0; i < upscaled.length; i++) {\n        if (upscaled[i].x === cellDst.x && upscaled[i].y === cellDst.y) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/pathfinding/MiniAStar.ts?\n}");

/***/ }),

/***/ "./src/core/pathfinding/PathFinding.ts":
/*!*********************************************!*\
  !*** ./src/core/pathfinding/PathFinding.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AirPathFinder: () => (/* binding */ AirPathFinder),\n/* harmony export */   ParabolaPathFinder: () => (/* binding */ ParabolaPathFinder),\n/* harmony export */   PathFinder: () => (/* binding */ PathFinder)\n/* harmony export */ });\n/* harmony import */ var _utilities_Line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities/Line */ \"./src/core/utilities/Line.ts\");\n/* harmony import */ var _AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AStar */ \"./src/core/pathfinding/AStar.ts\");\n/* harmony import */ var _MiniAStar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MiniAStar */ \"./src/core/pathfinding/MiniAStar.ts\");\n\n\n\nconst parabolaMinHeight = 50;\nclass ParabolaPathFinder {\n    constructor(mg) {\n        this.mg = mg;\n    }\n    computeControlPoints(orig, dst, increment = 3, distanceBasedHeight = true) {\n        const p0 = { x: this.mg.x(orig), y: this.mg.y(orig) };\n        const p3 = { x: this.mg.x(dst), y: this.mg.y(dst) };\n        const dx = p3.x - p0.x;\n        const dy = p3.y - p0.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        const maxHeight = distanceBasedHeight\n            ? Math.max(distance / 3, parabolaMinHeight)\n            : 0;\n        // Use a bezier curve always pointing up\n        const p1 = {\n            x: p0.x + (p3.x - p0.x) / 4,\n            y: Math.max(p0.y + (p3.y - p0.y) / 4 - maxHeight, 0),\n        };\n        const p2 = {\n            x: p0.x + ((p3.x - p0.x) * 3) / 4,\n            y: Math.max(p0.y + ((p3.y - p0.y) * 3) / 4 - maxHeight, 0),\n        };\n        this.curve = new _utilities_Line__WEBPACK_IMPORTED_MODULE_0__.DistanceBasedBezierCurve(p0, p1, p2, p3, increment);\n    }\n    nextTile(speed) {\n        if (!this.curve) {\n            throw new Error(\"ParabolaPathFinder not initialized\");\n        }\n        const nextPoint = this.curve.increment(speed);\n        if (!nextPoint) {\n            return true;\n        }\n        return this.mg.ref(Math.floor(nextPoint.x), Math.floor(nextPoint.y));\n    }\n    currentIndex() {\n        if (!this.curve) {\n            return 0;\n        }\n        return this.curve.getCurrentIndex();\n    }\n    allTiles() {\n        if (!this.curve) {\n            return [];\n        }\n        return this.curve\n            .getAllPoints()\n            .map((point) => this.mg.ref(Math.floor(point.x), Math.floor(point.y)));\n    }\n}\nclass AirPathFinder {\n    constructor(mg, random) {\n        this.mg = mg;\n        this.random = random;\n    }\n    nextTile(tile, dst) {\n        const x = this.mg.x(tile);\n        const y = this.mg.y(tile);\n        const dstX = this.mg.x(dst);\n        const dstY = this.mg.y(dst);\n        if (x === dstX && y === dstY) {\n            return true;\n        }\n        // Calculate next position\n        let nextX = x;\n        let nextY = y;\n        const ratio = Math.floor(1 + Math.abs(dstY - y) / (Math.abs(dstX - x) + 1));\n        if (this.random.chance(ratio) && x !== dstX) {\n            if (x < dstX)\n                nextX++;\n            else if (x > dstX)\n                nextX--;\n        }\n        else {\n            if (y < dstY)\n                nextY++;\n            else if (y > dstY)\n                nextY--;\n        }\n        if (nextX === x && nextY === y) {\n            return true;\n        }\n        return this.mg.ref(nextX, nextY);\n    }\n}\nclass PathFinder {\n    constructor(game, newAStar) {\n        this.game = game;\n        this.newAStar = newAStar;\n        this.curr = null;\n        this.dst = null;\n        this.path = null;\n        this.computeFinished = true;\n    }\n    static Mini(game, iterations, waterPath = true, maxTries = 20) {\n        return new PathFinder(game, (curr, dst) => {\n            return new _MiniAStar__WEBPACK_IMPORTED_MODULE_2__.MiniAStar(game.map(), game.miniMap(), curr, dst, iterations, maxTries, waterPath);\n        });\n    }\n    nextTile(curr, dst, dist = 1) {\n        if (curr === null) {\n            console.error(\"curr is null\");\n            return { type: _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound };\n        }\n        if (dst === null) {\n            console.error(\"dst is null\");\n            return { type: _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound };\n        }\n        if (this.game.manhattanDist(curr, dst) < dist) {\n            return { type: _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed, node: curr };\n        }\n        if (this.computeFinished) {\n            if (this.shouldRecompute(curr, dst)) {\n                this.curr = curr;\n                this.dst = dst;\n                this.path = null;\n                this.aStar = this.newAStar(curr, dst);\n                this.computeFinished = false;\n                return this.nextTile(curr, dst);\n            }\n            else {\n                const tile = this.path?.shift();\n                if (tile === undefined) {\n                    throw new Error(\"missing tile\");\n                }\n                return { type: _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.NextTile, node: tile };\n            }\n        }\n        switch (this.aStar.compute()) {\n            case _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed:\n                this.computeFinished = true;\n                this.path = this.aStar.reconstructPath();\n                // Remove the start tile\n                this.path.shift();\n                return this.nextTile(curr, dst);\n            case _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Pending:\n                return { type: _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Pending };\n            case _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound:\n                return { type: _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound };\n            default:\n                throw new Error(\"unexpected compute result\");\n        }\n    }\n    shouldRecompute(curr, dst) {\n        if (this.path === null || this.curr === null || this.dst === null) {\n            return true;\n        }\n        const dist = this.game.manhattanDist(curr, dst);\n        let tolerance = 10;\n        if (dist > 50) {\n            tolerance = 10;\n        }\n        else if (dist > 25) {\n            tolerance = 5;\n        }\n        else {\n            tolerance = 0;\n        }\n        if (this.game.manhattanDist(this.dst, dst) > tolerance) {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/pathfinding/PathFinding.ts?\n}");

/***/ }),

/***/ "./src/core/pathfinding/SerialAStar.ts":
/*!*********************************************!*\
  !*** ./src/core/pathfinding/SerialAStar.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SerialAStar: () => (/* binding */ SerialAStar)\n/* harmony export */ });\n/* harmony import */ var fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fastpriorityqueue */ \"./node_modules/fastpriorityqueue/FastPriorityQueue.js\");\n/* harmony import */ var fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _AStar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AStar */ \"./src/core/pathfinding/AStar.ts\");\n\n\nclass SerialAStar {\n    constructor(src, dst, iterations, maxTries, graph, directionChangePenalty = 0) {\n        this.dst = dst;\n        this.iterations = iterations;\n        this.maxTries = maxTries;\n        this.graph = graph;\n        this.directionChangePenalty = directionChangePenalty;\n        this.fwdCameFrom = new Map();\n        this.bwdCameFrom = new Map();\n        this.fwdGScore = new Map();\n        this.bwdGScore = new Map();\n        this.meetingPoint = null;\n        this.completed = false;\n        this.fwdOpenSet = new (fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0___default())((a, b) => a.fScore < b.fScore);\n        this.bwdOpenSet = new (fastpriorityqueue__WEBPACK_IMPORTED_MODULE_0___default())((a, b) => a.fScore < b.fScore);\n        this.sources = Array.isArray(src) ? src : [src];\n        this.closestSource = this.findClosestSource(dst);\n        // Initialize forward search with source point(s)\n        this.sources.forEach((startPoint) => {\n            this.fwdGScore.set(startPoint, 0);\n            this.fwdOpenSet.add({\n                tile: startPoint,\n                fScore: this.heuristic(startPoint, dst),\n            });\n        });\n        // Initialize backward search from destination\n        this.bwdGScore.set(dst, 0);\n        this.bwdOpenSet.add({\n            tile: dst,\n            fScore: this.heuristic(dst, this.findClosestSource(dst)),\n        });\n    }\n    findClosestSource(tile) {\n        return this.sources.reduce((closest, source) => this.heuristic(tile, source) < this.heuristic(tile, closest)\n            ? source\n            : closest);\n    }\n    compute() {\n        if (this.completed)\n            return _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed;\n        this.maxTries -= 1;\n        let iterations = this.iterations;\n        while (!this.fwdOpenSet.isEmpty() && !this.bwdOpenSet.isEmpty()) {\n            iterations--;\n            if (iterations <= 0) {\n                if (this.maxTries <= 0) {\n                    return _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound;\n                }\n                return _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Pending;\n            }\n            // Process forward search\n            const fwdCurrent = this.fwdOpenSet.poll().tile;\n            // Check if we've found a meeting point\n            if (this.bwdGScore.has(fwdCurrent)) {\n                this.meetingPoint = fwdCurrent;\n                this.completed = true;\n                return _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed;\n            }\n            this.expandNode(fwdCurrent, true);\n            // Process backward search\n            const bwdCurrent = this.bwdOpenSet.poll().tile;\n            // Check if we've found a meeting point\n            if (this.fwdGScore.has(bwdCurrent)) {\n                this.meetingPoint = bwdCurrent;\n                this.completed = true;\n                return _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed;\n            }\n            this.expandNode(bwdCurrent, false);\n        }\n        return this.completed\n            ? _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.Completed\n            : _AStar__WEBPACK_IMPORTED_MODULE_1__.PathFindResultType.PathNotFound;\n    }\n    expandNode(current, isForward) {\n        for (const neighbor of this.graph.neighbors(current)) {\n            if (neighbor !== (isForward ? this.dst : this.closestSource) &&\n                !this.graph.isTraversable(current, neighbor))\n                continue;\n            const gScore = isForward ? this.fwdGScore : this.bwdGScore;\n            const openSet = isForward ? this.fwdOpenSet : this.bwdOpenSet;\n            const cameFrom = isForward ? this.fwdCameFrom : this.bwdCameFrom;\n            const tentativeGScore = gScore.get(current) + this.graph.cost(neighbor);\n            let penalty = 0;\n            // With a direction change penalty, the path will get as straight as possible\n            if (this.directionChangePenalty > 0) {\n                const prev = cameFrom.get(current);\n                if (prev) {\n                    const prevDir = this.getDirection(prev, current);\n                    const newDir = this.getDirection(current, neighbor);\n                    if (prevDir !== newDir) {\n                        penalty = this.directionChangePenalty;\n                    }\n                }\n            }\n            const totalG = tentativeGScore + penalty;\n            if (!gScore.has(neighbor) || totalG < gScore.get(neighbor)) {\n                cameFrom.set(neighbor, current);\n                gScore.set(neighbor, totalG);\n                const fScore = totalG +\n                    this.heuristic(neighbor, isForward ? this.dst : this.closestSource);\n                openSet.add({ tile: neighbor, fScore: fScore });\n            }\n        }\n    }\n    heuristic(a, b) {\n        const posA = this.graph.position(a);\n        const posB = this.graph.position(b);\n        return 2 * (Math.abs(posA.x - posB.x) + Math.abs(posA.y - posB.y));\n    }\n    getDirection(from, to) {\n        const fromPos = this.graph.position(from);\n        const toPos = this.graph.position(to);\n        const dx = toPos.x - fromPos.x;\n        const dy = toPos.y - fromPos.y;\n        return `${Math.sign(dx)},${Math.sign(dy)}`;\n    }\n    reconstructPath() {\n        if (!this.meetingPoint)\n            return [];\n        // Reconstruct path from start to meeting point\n        const fwdPath = [this.meetingPoint];\n        let current = this.meetingPoint;\n        while (this.fwdCameFrom.has(current)) {\n            current = this.fwdCameFrom.get(current);\n            fwdPath.unshift(current);\n        }\n        // Reconstruct path from meeting point to goal\n        current = this.meetingPoint;\n        while (this.bwdCameFrom.has(current)) {\n            current = this.bwdCameFrom.get(current);\n            fwdPath.push(current);\n        }\n        return fwdPath;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/pathfinding/SerialAStar.ts?\n}");

/***/ }),

/***/ "./src/core/utilities/Line.ts":
/*!************************************!*\
  !*** ./src/core/utilities/Line.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezenhamLine: () => (/* binding */ BezenhamLine),\n/* harmony export */   CubicBezierCurve: () => (/* binding */ CubicBezierCurve),\n/* harmony export */   DistanceBasedBezierCurve: () => (/* binding */ DistanceBasedBezierCurve)\n/* harmony export */ });\nclass BezenhamLine {\n    constructor(p1, p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.dx = Math.abs(p2.x - p1.x);\n        this.dy = Math.abs(p2.y - p1.y);\n        this.sx = p1.x < p2.x ? 1 : -1;\n        this.sy = p1.y < p2.y ? 1 : -1;\n        this.error = this.dx - this.dy;\n    }\n    size() {\n        return Math.max(this.dx, this.dy) + 1;\n    }\n    // Increment either by 1 in x or y\n    increment() {\n        if (this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n            return true;\n        }\n        const x = this.p1.x;\n        const y = this.p1.y;\n        const err2 = 2 * this.error;\n        if (err2 > -this.dy) {\n            this.error -= this.dy;\n            this.p1.x += this.sx;\n        }\n        if (err2 < this.dx) {\n            this.error += this.dx;\n            this.p1.y += this.sy;\n        }\n        return { x, y };\n    }\n}\nclass CubicBezierCurve {\n    constructor(p0, p1, p2, p3) {\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n    }\n    getPointAt(t) {\n        const T = 1 - t;\n        const TT = T * T;\n        const TTT = TT * T;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = TTT * this.p0.x +\n            3 * TT * t * this.p1.x +\n            3 * T * tt * this.p2.x +\n            ttt * this.p3.x;\n        const y = TTT * this.p0.y +\n            3 * TT * t * this.p1.y +\n            3 * T * tt * this.p2.y +\n            ttt * this.p3.y;\n        return { x, y };\n    }\n}\n/**\n *  Use a cumulative distance LUT to approximate the traveled distance\n *  Useful to compute regular steps based on the curve rather than a t\n */\nclass DistanceBasedBezierCurve extends CubicBezierCurve {\n    constructor(p0, p1, p2, p3, distanceIncrement) {\n        super(p0, p1, p2, p3);\n        this.totalDistance = 0;\n        this.cachedPoints = [];\n        this.currentIndex = 0;\n        this.computeAllPoints(distanceIncrement, 0.002);\n    }\n    getAllPoints() {\n        return this.cachedPoints;\n    }\n    /**\n     * Move forward along the curve by the given distance.\n     * Returns the next cached point, or null if at the end.\n     */\n    increment(distance) {\n        this.totalDistance += distance;\n        // Step forward through cached points until we're at the correct distance\n        while (this.currentIndex < this.cachedPoints.length - 1 &&\n            this.getDistanceUpToIndex(this.currentIndex + 1) < this.totalDistance) {\n            this.currentIndex++;\n        }\n        if (this.currentIndex >= this.cachedPoints.length - 1) {\n            return null; // End of curve\n        }\n        return this.cachedPoints[this.currentIndex];\n    }\n    getCurrentIndex() {\n        return this.currentIndex;\n    }\n    /**\n     * Precompute all points spaced @p pixelSpacing apart\n     */\n    computeAllPoints(pixelSpacing, precision) {\n        this.cachedPoints = [];\n        this.totalDistance = 0;\n        this.currentIndex = 0;\n        let t = 0;\n        let prevPoint = this.getPointAt(t);\n        this.cachedPoints.push(prevPoint);\n        let cumulativeDistance = 0;\n        while (t < 1) {\n            t = Math.min(t + precision, 1);\n            const currentPoint = this.getPointAt(t);\n            const dx = currentPoint.x - prevPoint.x;\n            const dy = currentPoint.y - prevPoint.y;\n            const segmentLength = Math.sqrt(dx * dx + dy * dy);\n            cumulativeDistance += segmentLength;\n            if (cumulativeDistance >= pixelSpacing) {\n                this.cachedPoints.push(currentPoint);\n                cumulativeDistance = 0;\n            }\n            prevPoint = currentPoint;\n        }\n        // Make sure the last point is exactly at t=1\n        const finalPoint = this.getPointAt(1);\n        if (this.cachedPoints.length === 0 ||\n            finalPoint.x !== this.cachedPoints[this.cachedPoints.length - 1].x ||\n            finalPoint.y !== this.cachedPoints[this.cachedPoints.length - 1].y) {\n            this.cachedPoints.push(finalPoint);\n        }\n    }\n    /**\n     * Optional helper: get distance along the cached points up to a given index\n     */\n    getDistanceUpToIndex(index) {\n        let dist = 0;\n        for (let i = 1; i <= index; i++) {\n            const p1 = this.cachedPoints[i - 1];\n            const p2 = this.cachedPoints[i];\n            const dx = p2.x - p1.x;\n            const dy = p2.y - p1.y;\n            dist += Math.sqrt(dx * dx + dy * dy);\n        }\n        return dist;\n    }\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/utilities/Line.ts?\n}");

/***/ }),

/***/ "./src/core/validations/username.ts":
/*!******************************************!*\
  !*** ./src/core/validations/username.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_USERNAME_LENGTH: () => (/* binding */ MAX_USERNAME_LENGTH),\n/* harmony export */   MIN_USERNAME_LENGTH: () => (/* binding */ MIN_USERNAME_LENGTH),\n/* harmony export */   fixProfaneUsername: () => (/* binding */ fixProfaneUsername),\n/* harmony export */   isProfaneUsername: () => (/* binding */ isProfaneUsername),\n/* harmony export */   sanitizeUsername: () => (/* binding */ sanitizeUsername),\n/* harmony export */   validateUsername: () => (/* binding */ validateUsername)\n/* harmony export */ });\n/* harmony import */ var obscenity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! obscenity */ \"./node_modules/obscenity/dist/index.mjs\");\n/* harmony import */ var _client_Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../client/Utils */ \"./src/client/Utils.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util */ \"./src/core/Util.ts\");\n\n\n\nconst matcher = new obscenity__WEBPACK_IMPORTED_MODULE_0__.RegExpMatcher({\n    ...obscenity__WEBPACK_IMPORTED_MODULE_0__.englishDataset.build(),\n    ...obscenity__WEBPACK_IMPORTED_MODULE_0__.englishRecommendedTransformers,\n    ...(0,obscenity__WEBPACK_IMPORTED_MODULE_0__.resolveConfusablesTransformer)(),\n    ...(0,obscenity__WEBPACK_IMPORTED_MODULE_0__.skipNonAlphabeticTransformer)(),\n    ...(0,obscenity__WEBPACK_IMPORTED_MODULE_0__.collapseDuplicatesTransformer)(),\n    ...(0,obscenity__WEBPACK_IMPORTED_MODULE_0__.resolveLeetSpeakTransformer)(),\n});\nconst MIN_USERNAME_LENGTH = 3;\nconst MAX_USERNAME_LENGTH = 27;\nconst validPattern = /^[a-zA-Z0-9_[\\] ðŸˆðŸ€Ã¼Ãœ]+$/u;\nconst shadowNames = [\n    \"NicePeopleOnly\",\n    \"BeKindPlz\",\n    \"LearningManners\",\n    \"StayClassy\",\n    \"BeNicer\",\n    \"NeedHugs\",\n    \"MakeFriends\",\n];\nfunction fixProfaneUsername(username) {\n    if (isProfaneUsername(username)) {\n        return shadowNames[(0,_Util__WEBPACK_IMPORTED_MODULE_2__.simpleHash)(username) % shadowNames.length];\n    }\n    return username;\n}\nfunction isProfaneUsername(username) {\n    return matcher.hasMatch(username);\n}\nfunction validateUsername(username) {\n    if (typeof username !== \"string\") {\n        return { isValid: false, error: (0,_client_Utils__WEBPACK_IMPORTED_MODULE_1__.translateText)(\"username.not_string\") };\n    }\n    if (username.length < MIN_USERNAME_LENGTH) {\n        return {\n            isValid: false,\n            error: (0,_client_Utils__WEBPACK_IMPORTED_MODULE_1__.translateText)(\"username.too_short\", {\n                min: MIN_USERNAME_LENGTH,\n            }),\n        };\n    }\n    if (username.length > MAX_USERNAME_LENGTH) {\n        return {\n            isValid: false,\n            error: (0,_client_Utils__WEBPACK_IMPORTED_MODULE_1__.translateText)(\"username.too_long\", {\n                max: MAX_USERNAME_LENGTH,\n            }),\n        };\n    }\n    if (!validPattern.test(username)) {\n        return {\n            isValid: false,\n            error: (0,_client_Utils__WEBPACK_IMPORTED_MODULE_1__.translateText)(\"username.invalid_chars\", {\n                max: MAX_USERNAME_LENGTH,\n            }),\n        };\n    }\n    // All checks passed\n    return { isValid: true };\n}\nfunction sanitizeUsername(str) {\n    const sanitized = Array.from(str)\n        .filter((ch) => validPattern.test(ch))\n        .join(\"\")\n        .slice(0, MAX_USERNAME_LENGTH);\n    return sanitized.padEnd(MIN_USERNAME_LENGTH, \"x\");\n}\n\n\n//# sourceURL=webpack://openfront-client/./src/core/validations/username.ts?\n}");

/***/ }),

/***/ "./src/core/worker/Worker.worker.ts":
/*!******************************************!*\
  !*** ./src/core/worker/Worker.worker.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _resources_version_txt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../resources/version.txt */ \"./resources/version.txt\");\n/* harmony import */ var _GameRunner__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GameRunner */ \"./src/core/GameRunner.ts\");\n/* harmony import */ var _game_FetchGameMapLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game/FetchGameMapLoader */ \"./src/core/game/FetchGameMapLoader.ts\");\n\n\n\nconst ctx = self;\nlet gameRunner = null;\nconst mapLoader = new _game_FetchGameMapLoader__WEBPACK_IMPORTED_MODULE_2__.FetchGameMapLoader(`/maps`, _resources_version_txt__WEBPACK_IMPORTED_MODULE_0__);\nfunction gameUpdate(gu) {\n    // skip if ErrorUpdate\n    if (!(\"updates\" in gu)) {\n        return;\n    }\n    sendMessage({\n        type: \"game_update\",\n        gameUpdate: gu,\n    });\n}\nfunction sendMessage(message) {\n    ctx.postMessage(message);\n}\nctx.addEventListener(\"message\", async (e) => {\n    const message = e.data;\n    switch (message.type) {\n        case \"heartbeat\":\n            (await gameRunner)?.executeNextTick();\n            break;\n        case \"init\":\n            try {\n                gameRunner = (0,_GameRunner__WEBPACK_IMPORTED_MODULE_1__.createGameRunner)(message.gameStartInfo, message.clientID, mapLoader, gameUpdate).then((gr) => {\n                    sendMessage({\n                        type: \"initialized\",\n                        id: message.id,\n                    });\n                    return gr;\n                });\n            }\n            catch (error) {\n                console.error(\"Failed to initialize game runner:\", error);\n                throw error;\n            }\n            break;\n        case \"turn\":\n            if (!gameRunner) {\n                throw new Error(\"Game runner not initialized\");\n            }\n            try {\n                const gr = await gameRunner;\n                await gr.addTurn(message.turn);\n            }\n            catch (error) {\n                console.error(\"Failed to process turn:\", error);\n                throw error;\n            }\n            break;\n        case \"player_actions\":\n            if (!gameRunner) {\n                throw new Error(\"Game runner not initialized\");\n            }\n            try {\n                const actions = (await gameRunner).playerActions(message.playerID, message.x, message.y);\n                sendMessage({\n                    type: \"player_actions_result\",\n                    id: message.id,\n                    result: actions,\n                });\n            }\n            catch (error) {\n                console.error(\"Failed to check borders:\", error);\n                throw error;\n            }\n            break;\n        case \"player_profile\":\n            if (!gameRunner) {\n                throw new Error(\"Game runner not initialized\");\n            }\n            try {\n                const profile = (await gameRunner).playerProfile(message.playerID);\n                sendMessage({\n                    type: \"player_profile_result\",\n                    id: message.id,\n                    result: profile,\n                });\n            }\n            catch (error) {\n                console.error(\"Failed to check borders:\", error);\n                throw error;\n            }\n            break;\n        case \"player_border_tiles\":\n            if (!gameRunner) {\n                throw new Error(\"Game runner not initialized\");\n            }\n            try {\n                const borderTiles = (await gameRunner).playerBorderTiles(message.playerID);\n                sendMessage({\n                    type: \"player_border_tiles_result\",\n                    id: message.id,\n                    result: borderTiles,\n                });\n            }\n            catch (error) {\n                console.error(\"Failed to get border tiles:\", error);\n                throw error;\n            }\n            break;\n        case \"attack_average_position\":\n            if (!gameRunner) {\n                throw new Error(\"Game runner not initialized\");\n            }\n            try {\n                const averagePosition = (await gameRunner).attackAveragePosition(message.playerID, message.attackID);\n                sendMessage({\n                    type: \"attack_average_position_result\",\n                    id: message.id,\n                    x: averagePosition ? averagePosition.x : null,\n                    y: averagePosition ? averagePosition.y : null,\n                });\n            }\n            catch (error) {\n                console.error(\"Failed to get attack average position:\", error);\n                throw error;\n            }\n            break;\n        case \"transport_ship_spawn\":\n            if (!gameRunner) {\n                throw new Error(\"Game runner not initialized\");\n            }\n            try {\n                const spawnTile = (await gameRunner).bestTransportShipSpawn(message.playerID, message.targetTile);\n                sendMessage({\n                    type: \"transport_ship_spawn_result\",\n                    id: message.id,\n                    result: spawnTile,\n                });\n            }\n            catch (error) {\n                console.error(\"Failed to spawn transport ship:\", error);\n            }\n            break;\n        default:\n            console.warn(\"Unknown message :\", message);\n    }\n});\n// Error handling\nctx.addEventListener(\"error\", (error) => {\n    console.error(\"Worker error:\", error);\n});\nctx.addEventListener(\"unhandledrejection\", (event) => {\n    console.error(\"Unhandled promise rejection in worker:\", event);\n});\n\n\n//# sourceURL=webpack://openfront-client/./src/core/worker/Worker.worker.ts?\n}");

/***/ }),

/***/ "?d4c0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://openfront-client/crypto_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 		__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 		module = execOptions.module;
/******/ 		execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./src/core/worker/Worker.worker.ts")))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "js/" + chunkId + "." + {"vendors":"c9247807bb2c2ddc4cdd","src_core_worker_Worker_worker_ts":"8ed8032251414627b58d"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("e5eab6034bd9525e4c62." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("a7f9d26b5a03781dd74c")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"src_core_worker_Worker_worker_ts": 1
/******/ 		};
/******/ 		
/******/ 		// importScripts chunk loading
/******/ 		var installChunk = (data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			while(chunkIds.length)
/******/ 				installedChunks[chunkIds.pop()] = 1;
/******/ 			parentChunkLoadingFunction(data);
/******/ 		};
/******/ 		__webpack_require__.f.i = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					importScripts(__webpack_require__.p + __webpack_require__.u(chunkId));
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkopenfront_client"] = self["webpackChunkopenfront_client"] || [];
/******/ 		var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);
/******/ 		chunkLoadingGlobal.push = installChunk;
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdateopenfront_client"] = (_, moreModules, runtime) => {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.p + __webpack_require__.hu(chunkId));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScriptsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScripts = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScripts = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScriptsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			return __webpack_require__.e("vendors").then(next);
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;